{
    "english": {
        "Runtime Types": "Runtime Types",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "Making type information available at runtime in TypeScript changes a lot. It allows new ways of working that were previously only possible in a roundabout way, or not at all. Declaring types and schemas has become a big part of modern development processes. For example, GraphQL, validators, ORMs, and encoders such as ProtoBuf, and many more rely on having schema information available at runtime to provide fundamental functionality in the first place. These tools and libraries sometimes require the developer to learn completely new languages that have been developed very specifically for the use case. For example, ProtoBuf and GraphQL have their own declaration language, also validators are often based on their own schema APIs or even JSON schema, which is also an independent way to define structures. Some of them require code generators to be executed whenever a change is made, in order to provide the schema information to the runtime as well. Another well-known pattern is to use experimental TypeScript decorators to provide meta-information to classes at runtime.",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "But is all this necessary? TypeScript offers a very powerful language to describe even very complex structures. In fact, TypeScript is now touring-complete, which roughly means that theoretically any kind of program can be mapped into TypeScript. Of course, this has its practical limitations, but the important point is that TypeScript is able to completely replace any declaration formats such as GraphQL, ProtoBuf, JSON Schema, and many others. Combined with a type system at runtime, it is possible to cover all the described tools and their use cases in TypeScript itself without any code generator. But why is there not yet a solution that allows exactly this?",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "Historically, TypeScript has undergone a massive transformation over the past few years. It has been completely rewritten several times, received basic features, and undergone a number of iterations and breaking changes. However, TypeScript has now reached a product market fit that greatly slows the rate at which fundamental innovations and breaking changes happen. TypeScript has proven itself and shown what a highly charming type system for a highly dynamic language like JavaScript should look like. The market has gratefully embraced this push and ushered in a new era in JavaScript development.",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "This is exactly the time to build tools on top of the language itself at a fundamental level to make the above possible. Deepkit wants to be the impetus to bring over decades of proven design patterns from the enterprise of languages like Java and PHP not only fundamental to TypeScript, but in a new and better way that works with JavaScript rather than against it. Through type information at runtime, these are now for the first time not only possible in principle, but allow for whole new much simpler design patterns that are not possible with languages like Java and PHP. TypeScript itself has laid the foundation here to make the developer's life considerably easier with completely new approaches in strong combination with the tried and tested.",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zur Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "Reading type information at runtime is the capability on which Deepkit builds its foundation. The API of the Deepkit libraries are largely focused on using as much TypeScript type information as possible to be as efficient as possible. Type system at runtime means that type information is readable at runtime and dynamic types are computable. This means, for example, that for classes all properties and for functions all parameters and return types can be read.",
        "Nehmen wir als Beispiel diese Funktion:": "Let's take this function as an example:",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "In JavaScript itself, several pieces of information can be read at runtime. For example, the name of the function (unless modified with a minimizer):",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "On the other hand, the number of parameters can be read out:",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "With a bit more code it is also possible to read out the names of the parameters. However, this is not easily done without a rudimentary JavaScript parser or RegExp on log.toString(), so that's about it from here. Since TypeScript translates the above function into JavaScript as follows:",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "the information that `message` is of type string and the return type is of type `void` is no longer available. This information has been irrevocably destroyed by TypeScript.",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "However, with a type system at runtime, this information can survive so that one can programmatically read the types of message and the return type.",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit does just that. It hooks into the compilation of TypeScript and ensures that all type information is built into the generated JavaScript. Functions like typeOf() (not to be confused with the operator typeof, with a lowercase o) then allow the developer to access it. Libraries can therefore be developed based on this type information, allowing the developer to use already written TypeScript types for a whole range of application possibilities.",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "To install Deepkit's runtime type system two packages are needed. The type compiler in `@deepkit/type-compiler` and the runtime in `@deepkit/type`. The type compiler can be installed in `package.json` _devDependencies_, because it is only needed at build time.",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "Runtime type information is not generated by default. It must be set `\"reflection\": true` in the `tsconfig.json` file to enable it in all files in the same folder of this file or in all subfolders. If decorators are to be used, `\"experimentalDecorators\": true` must be enabled in `tsconfig.json`. This is not strictly necessary to work with `@deepkit/type`, but necessary for certain functions of other deepkit libraries and in `@deepkit/framework`.",
        "_Datei: tsconfig.json_": "_file: tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript itself does not allow to configure the type compiler via a `tsconfig.json`. It is necessary to either use the TypeScript compiler API directly or a build system like Webpack with _ts-loader_. To avoid this inconvenience for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modules/typescript` when `@deepkit/type-compiler` is installed (this is done via NPM install hooks).",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes _tsc_, Angular, webpack, _ts-node_, and some other tools automatically work with the Deepkit type compiler.",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "If the type compiler could not be successfully installed automatically (for example because NPM install hooks are disabled), this can be done manually with the following command:",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "Note that `deepkit-type-install` must be run if the local typescript version has been updated (for example, if the typescript version in package.json has changed and `npm install` is run).",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "If you want to use the type compiler in a webpack build, you can do so with the `ts-loader` package (or any other typescript loader that supports transformer registration).",
        "_Datei: webpack.config.js_": "_file: webpack.config.js_",
        "Typen-Decorators": "Type Decorators",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "Type decorators are normal TypeScript types that contain meta-information to change the behavior of various functions at runtime. Deepkit already provides some type decorators that cover some use cases. For example, a class property can be marked as primary key, reference, or index. The database library can use this information at runtime to create the correct SQL queries without prior code generation.",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Validator constraints such as `MaxLength`, `Maximum`, or `Positive` can also be added to any type. It is also possible to tell the serializer how to serialize or deserialize a particular value. In addition, it is possible to create completely custom type decorators and read them at runtime, in order to use the type system at runtime in a very individual way.",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit comes with a whole set of type decorators, all of which can be used directly from `@deepkit/type`. They are designed not to come from multiple libraries, so as not to tie code directly to a particular library such as Deepkit RPC or Deepkit Database. This allows easier reuse of types, even in the frontend, although database type decorators are used for example.",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "The following is a list of existing type decorators. The validator and serializer of `@deepkit/type` and `@deepkit/bson` as well as Deepkit Database of `@deepkit/orm` used this information differently. See the corresponding chapters to learn more about this.",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Integer and floats are defined as a base as `number` and has several sub-variants:",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "Here the `id` of the user is a number at runtime, but is interpreted as an integer in the validation and serialization.",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "This means, for example, that floats may not be used in validation and the serializer automatically converts floats to integers.",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "The subtypes can be used in the same way and are useful if a specific range of numbers is to be allowed.",
        "Float": "Float",
        "UUID": "UUID",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4 is usually stored as a binary in the database and as a string in JSON.",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM stores BinaryBigInt as a binary field.",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as a uint: 255 for negative, 0 for zero, or 1 for positive.",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "To change the name of a property in the serialization.",
        "Group": "Group",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.",
        "Data": "Data",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.",
        "Excluded": "Excluded",
        "Each property can be excluded from the serialization process for a specific target.": "Each property can be excluded from the serialization process for a specific target.",
        "Embedded": "Embedded",
        "Marks the field as an embedded type.": "Marks the field as an embedded type.",
        "It's possible to change the prefix (which is per default the property name).": "It's possible to change the prefix (which is per default the property name).",
        "Entity": "Entity",
        "To annotate interfaces with entity information. Only used in the database context.": "To annotate interfaces with entity information. Only used in the database context.",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "Database",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Validation": "Validation",
        "Siehe <<validation-constraint-types>>.": "See <<validation-constraint-types>>.",
        "Benutzerdefinierte Type-Decorators": "Custom Type Decorators",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "A type decorator can be defined as follows:",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "By convention, a type decorator is defined to be an object literal with a single optional property `__meta` that has a tuple as its type. The first entry in this tuple is its unique name and all subsequent tuple entries are arbitrary options. This allows a type decorator to be equipped with additional options.",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "The type decorator is used with the intersection operator `&`. Any number of type decorators can be used on one type.",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "The type decorators can be read out via the type objects of `typeOf<T>()` and `metaAnnotation`:",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "The result in `annotation` is either an array with options if the type decorator `myAnnotation` was used or `undefined` if not. If the type decorator has additional options as seen in `AnnotationOption`, the passed values can be found in the array.",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "Already supplied type decorators like `MapName`, `Group`, `Data`, etc have their own annotation object:",
        "Siehe <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "See <<runtime-types-reflection>> to learn more about this.",
        "External Classes": "External Classes",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "Since TypeScript does not include type information by default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "MyExternalClass` can now be used in serialization functions and in the reflection API.",
        "To following shows how to annotate generic classes:": "To following shows how to annotate generic classes:",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Reflection classes are discussed below. The function `typeOf` returns type objects, which are very simple object literals. It always contains a `kind` which is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "There are a number of possible type objects that can be returned. The simplest ones are `never`, `any`, `unknown`, `void, null,` and `undefined`, which are represented as follows:",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "For example, number 0 is the first entry of the `ReflectionKind` enum, in this case `never`, number 1 is the second entry, here `any`, and so on. Accordingly, primitive types like `string`, `number`, `boolean` are represented as follows:",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "These rather simple types have no further information at the type object, because they were passed directly as type argument to `typeOf`. However, if types are passed via type aliases, additional information can be found at the type object.",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "In this case, the name of the type alias 'Title' is also available. If a type alias is a generic, the types passed will also be available at the type object.",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "If the type passed is the result of an index access operator, the container and the index type are present:",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "Interfaces and object literals are both output as Reflection.objectLiteral and contain the properties and methods in the `types` array.",
        "Index Signatures sind ebenfalls in dem `types` array.": "Index signatures are also in the `types` array.",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "Classes are similar to object literals and also have their properties and methods under a `types` array in addition to `classType` which is a reference to the class itself.",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "Note that the type of Reflection.propertySignature has changed to Reflection.property and Reflection.methodSignature has changed to Reflection.method. Since properties and methods on classes have additional attributes, this information can also be retrieved. The latter additionally include `visibility`, `abstract`, and `default`.",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "Type objects of classes contain only the properties and methods of the class itself and not of the super-classes. This is contrary to type objects of interfaces/object-literals, which have all property signatures and method signatures of all parents resolved into `types`. To resolve the property and method of the super-classes, either ReflectionClass and its `ReflectionClass.getProperties()` (see following sections) or `resolveTypeMembers()` of `@deepkit/type` can be used.",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "There is a whole plethora of type objects. For example for literal, template literals, promise, enum, union, array, tuple, and many more. To find out which ones all exist and what information is available, it is recommended to import `type` from `@deepkit/type`. It is a `union` with all possible subtypes like TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, and many more. There you can find the exact structure.",
        "Type Cache": "Type cache",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "Type objects are cached for type aliases, functions, and classes as soon as no generic argument is passed. This means that a call to `typeOf<MyClass>()` always returns the same object.",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "However, as soon as a generic type is used, new objects are always created, even if the type passed is always the same. This is because an infinite number of combinations are theoretically possible and such a cache would effectively be a memory leak.",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "However, as soon as a type is instantiated multiple times in a recursive type, it is cached. However, the duration of the cache is limited only to the moment the type is computed and does not exist thereafter. Also, although the Type object is cached, a new reference is returned and is not the exact same object.",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "`MyType<string>` is cached as long as `Object` is computed. The PropertySignature of `a` and `b` thus have the same `type` from the cache, but are not the same Type object.",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "All non-root type objects have a parent property, which usually points to the enclosing parent. This is valuable, for example, to find out whether a Type is part of a union or not.",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "Ref 1' points to the actual union type object.",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "For cached type objects as exemplified above, the `parent` properties are not always the real parents. For example, for a class that is used multiple times, although immediate types in `types` (TypePropertySignature and TypeMethodSignature) point to the correct TypeClass, the `type` of these signature types point to the signature types of the TypeClass of the cached entry. This is important to know so as not to infinitely read the parent structure, but only the immediate parent. The fact that the parent does not have infinite precision is due to performance reasons.",
        "JIT Cache": "JIT Cache",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "In the further course some functions and features are described, which are often based on the type objects. To implement some of them in a performant way, a JIT (just in time) cache per type object is needed. This can be provided via `getJitContainer(type)`. This function returns a simple object on which arbitrary data can be stored. As long as no reference to the object is held, it will be deleted automatically by the GC as soon as the Type object itself is also no longer referenced.",
        "Reflection-Klassen": "Reflection classes",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "In addition to the `typeOf<>()` function, there are various reflection classes that provide an OOP alternative to the Type objects. The reflection classes are only available for classes, interface/object literals and functions and their direct sub-types (properties, methods, parameters). All deeper types must be read again with the Type objects.",
        "Typeninformation empfangen": "Receive type information",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "In order to provide functions that operate on types, it can be useful to offer the user to pass a type manually. For example, in a validation function, it might be useful to provide the type to be requested as the first type argument and the data to be validated as the first function argument.",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "In order for this function to receive the type `string`, it must communicate this to the type compiler.",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType` with the reference to the first type arguments `T` signals the type compiler that each call to `validate` should put the type in second place (since `type` is declared in second place). To then read out the information at runtime, the `resolveReceiveType` function is used.",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type` now either a type object is stored or an error is thrown, if for example no type argument was passed, Deepkit's type compiler was not installed correctly, or the emitting of type information is not activated (see the section Installation above).",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "To learn in detail how Deepkit encodes and reads the type information in JavaScript, this chapter is intended. It explains how the types are actually converted into bytecode, emitted in JavaScript, and then interpreted at runtime.",
        "Typen-Compiler": "Type compiler",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "The type compiler (in @deepkit/type-compiler) is responsible for reading the defined types in the TypeScript files and compiling them into a bytecode. This bytecode has everything needed to execute the types in runtime.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "At the time of this writing, the Type compiler is a so-called TypeScript Transformer. This transformer is a plugin for the TypeScript compiler itself and converts a TypeScript AST (Abstract Syntax Tree) into another TypeScript AST. In this process, Deepkit's type compiler reads the AST, produces the corresponding bytecode, and inserts it into the AST.",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript itself does not allow to configure this plugin aka transformer via a tsconfig.json. It is either necessary to use the TypeScript compiler API directly, or a build system like Webpack with `ts-loader`. To avoid this inconvenience for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modules/typescript` when `@deepkit/type-compiler` is installed. This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes tsc, Angular, webpack, ts-node, and some other tools work automatically with Deepkit's type compiler.",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "If the automatic execution of NPM install scripts is not activated and thus the locally installed typescript is not modified, this process must be executed manually if you want to do so. Alternatively, the types compiler can be used manually in a build tool such as webpack. See the Installation section above.",
        "Bytecode Encoding": "Bytecode Encoding",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "The bytecode is a sequence of commands for a virtual machine and is encoded in the JavaScript itself as an array of references and string (the actual bytecode).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as `ReflectionOp` enums. At the time of this writing, the command set is over 81 commands in size.",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "A sequence of commands is encoded as a string to save memory. So a type `string[]` is conceptualized as a bytecode program `[string, array]` which has the bytes `[5, 37]` and encoded with the following algorithm:",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "Accordingly, a 5 becomes an `&` character and a 37 becomes an `F` character. Together they become `&F` and are emitted in Javascript as `['&F']`.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "To prevent naming conflicts, each type is given a \"_Ω\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode is emitted the JavaScript. Classes and functions also receive a bytecode directly as a property.",
        "Virtuelle Maschine": "Virtual machine",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "A virtual machine (in `@deepkit/type` the class Processor) at runtime is responsible for decoding and executing the encoded bytecode. It always returns a type object, see the Reflection section above.",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation is the process of checking data for correctness. Correctness is given if the type is the correct one and additional defined constraints are fulfilled. Deepkit generally distinguishes between type validation and the validation of additional constraints.",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "Validation is used whenever data comes from a source that is considered uncertain. Uncertain means that no guaranteed assumptions can be made about the types or contents of the data, and thus the data could have literally any value at runtime.",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "For example, data from user input is generally not considered secure. Data from an HTTP request (query parameter, body), CLI arguments, or a read-in file must be validated. If a variable is declared as a number, there must also be a number in it, otherwise the program may crash or a security hole may occur.",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "In a controller of an HTTP route, for example, the top priority is to check every user input (query parameter, body). Especially in the TypeScript environment, it is important not to use type casts, as they are fundamentally insecure.",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in <<serialisation>> mehr Informationen.": "This often seen code is a bug that can lead to a program crash or a security vulnerability because a type cast `as number` was used that does not provide any security at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in <<serialization>>.",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "Validation is an essential part of any application and it is better to use it once too often than once too little. Deepkit provides many validation options and has a high-performance implementation, so in most cases there is no need to worry about execution time. Use as much validation as possible, in case of doubt once more, to be on the safe side.",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "In doing so, many components of Deepkit such as the HTTP router, the RPC abstraction, but also the database abstraction itself have validation built in and is performed automatically, so in many cases it is not necessary to do this manually.",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "In the corresponding chapters (<<cli>>, <<http>>, <<rpc>>, <<database>>) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and do not use `any` to make these validations work well and safely automatically. This can save you a lot of manual work to keep the code clean and safe.",
        "Benutzung": "Use",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "The basic function of the validator is to check a value for its type. For example, whether a value is a string. This is not about what the string contains, but only about its type. There are many types in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, and many more. Due to Typescript's powerful type system, a large variety of different types are available.",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "In JavaScript itself, primitive types can be parsed with the `typeof` operator. For more complex types like interfaces, mapped types, or generic set/map this is not so easy anymore and a validator library like `@deepkit/type` becomes necessary. Deepkit is the only solution that allows to validate all TypesScript types directly without any detours.",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` vorgenommen werden.": "In Deepkit, type validation can be done using either the `validate`, `is`, or `assert` function.",
        "Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "The function `is` is a so-called type guard and `assert` is a type assertion. Both will be explained in the next section.",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "The function `validate` returns an array of found errors and on success an empty array. Each entry in this array describes the exact error code and the error message as well as the path when more complex types like objects or arrays are validated.",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "All three functions are used in roughly the same way. The type is specified or referenced as the first type argument and the data is passed as the first function argument.",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "If you work with more complex types like classes or interfaces, the array can also contain several entries.",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "The validator also supports deep recursive types. Paths are then separated with a dot.",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "Take advantage of the benefits that TypeScript offers you. For example, more complex types such as a `user` can be reused in multiple places without having to declare it again and again. For example, if a `user` is to be validated without its `id`, TypeScript utitilies can be used to quickly and efficiently create derived subtypes. Very much in the spirit of DRY (Don't Repeat Yourself).",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit is the only major framework that has the ability to access TypeScripts types in this way at runtime. If you want to use types in frontend and backend, types can be swapped out to a separate file and thus imported anywhere. Use this option to your advantage to keep the code efficient and clean.",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "A type cast (contrary to type guard) in TypeScript is not a construct at runtime, but is only handled in the type system itself. It is not a safe way to assign a type to unknown data.",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "The `as string` code is not safe. The variable `data` could have literally any value, for example `{username: 123}`, or even `{}`, and would have the consequence that `username` is not a string, but something completely different and therefore the code `username.startsWith('@')` will lead to an error, so that in the worst case the program crashes. To guarantee at runtime that `data` here has a property `username` with the type string, type-guards must be used.",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "Type guards are functions that give TypeScript a hint about what type the passed data is guaranteed to have at runtime. Armed with this knowledge, TypeScript then \"narrows\" the type as the code progresses.  For example, `any` can be made into a string, or any other type in a safe way.",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "So if there is data of which the type is not known (`any` or `unknown`), a type guard helps to narrow it down more precisely based on the data itself. However, the type guard is only as safe as its implementation. If you make a mistake, this can have severe consequences, because fundamental assumptions suddenly turn out to be untrue.",
        "Type-Guard": "Type-Guard",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "A type guard on the above used type `User` could look in simplest form as follows. Note that the above explained special features with NaN are not part here and thus this type guard is not quite correct.",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "A type guard always returns a Boolean and is usually used directly in an If operation.",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "Writing a separate function for each type guard, especially for more complex types, and then adapting it every time a type changes is extremely tedious, error-prone, and not efficient. Therefore, Deepkit provides the function `is`, which automatically provides a Type-Guard for any TypeScript type. This then also automatically takes into account special features such as the above-mentioned problem with NaN. The function `is` does the same as `validate`, but instead of an array of errors it simply returns a boolean.",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "A pattern that can be found more often is to return an error directly in case of incorrect validation, so that subsequent code is not executed. This can be used in various places without changing the complete flow of the code.",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "Alternatively, a TypeScript type assertion can be used. The `assert` function automatically throws an error if the given data does not validate correctly to a type. The special signature of the function, which distinguishes TypeScript type assertions, helps TypeScript to automatically narrow the passed variable.",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "Here, too, take advantage of the benefits that TypeScript offers you. Types can be reused or customized using various TypeScript functions.",
        "Error Reporting": "Error Reporting",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "The functions `is`, `assert` and `validates` return a boolean as result. To get exact information about failed validation rules, the `validate` function can be used. It returns an empty array if everything was validated successfully. In case of errors the array will contain one or more entries with the following structure:",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "The function receives as first type argument any TypeScript type and as first argument the data to validate.",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "Complex types such as interfaces, classes, or generics can also be used.",
        "Einschränkungen": "Constraints",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "In addition to checking the types, other arbitrary constraints can be added to a type. The validation of these additional content constraints is done automatically after the types themselves have been validated. This is done in all validation functions like `validate`, `is`, and `assert`. For example, a constraint can be that a string must have a certain minimum or maximum length.",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "These constraints are added to the actual types via the type decorators. There is a whole variety of decorators that can be used. Own decorators can be defined and used at will in case of extended needs.",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "With `&` any number of type decorators can be added to the actual type. The result, here `username`, can then be used in all validation functions but also in other types.",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "The function `validate` gives useful error messages coming from the constraints.",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "These information can be represented for example wonderfully also at a form automatically and be translated by means of the `code`. Through the existing path for objects and arrays, fields in a form can filter out and display the appropriate error.",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "An often useful use case is also to define an email with a RegExp constraint. Once the type is defined, it can be used anywhere.",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "Any number of constraints can be added.",
        "Constraint Types": "Constraint Types",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "Validation using a custom validator function. See next section Custom Validator for more information.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Defines a regular expression as validation pattern. Usually used for email validation or more complex content validation.",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "Validation for alpha characters (a-Z).",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "Validation for alpha and numeric characters.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Validation for ASCII characters.",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Validation of numbers that are a multiple of given number.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "Validation for min/max length for arrays or strings.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "Validation for an array item or sub string being included/excluded",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date)...",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Ensures that the number is an integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.",
        "See Special types: integer/floats for more information": "See Special types: integer/floats for more information",
        "Benutzerdefinierte Validator": "Custom validator",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "If the built-in validators are not sufficient, custom validation functions can be created and used via the `Validate` decorator.",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "Note that your custom validation function is executed after all built-in type validators have been called. If a validator fails, all subsequent validators for the current type are skipped. Only one failure is possible per type.",
        "Generic Validator": "Generic Validator",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "In the Validator function the type object is available which can be used to get more information about the type using the validator. There is also a possibility to define any validator option that must be passed to the validate type and makes the validator configurable. With this information and its parent references, powerful generic validators can be created.",
        "Serialisation": "Serialization",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "Serialization is the process of converting data types into a format suitable for transport or storage, for example. Deserialization is the process of undoing this. This is done losslessly, meaning that data can be converted to and from a serialization target without losing data type information or the data itself.",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "In JavaScript, serialization is usually between JavaScript objects and JSON. JSON supports only String, Number, Boolean, Objects, and Arrays. JavaScript, on the other hand, supports many other types such as BigInt, ArrayBuffer, typed arrays, Date, custom class instances, and many more. Now, to transmit JavaScript data to a server using JSON, you need a serialization process (on the client) and a deserialization process (on the server), or vice versa if the server sends data to the client as JSON. Using `JSON.parse` and `JSON.stringify` is often not sufficient for this, as it is not lossless.",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "This serialization process is absolutely necessary for non-trivial data, since JSON loses its information even for basic types like a date. A `new Date` is finally serialized as a string in JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "As you can see, the result of JSON.stringify is a JSON string. If you deserialize it again with JSON.parse, you will not get a `date` object, but a string.",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "Although there are various workarounds to teach JSON.parse to deserialize Date objects, they are error-prone and poorly performing. To enable type-safe serialization and deserialization for this case and many other types, a serialization process is necessary.",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "There are four main functions available: `serialize`, `cast`/`deserialize` and `validatedDeserialize`. Under the hood of these functions, the globally available JSON serializer from `@deepkit/type` is used by default, but a custom serialization target can also be used.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type supports user-defined serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the <<serialization-custom-serialiser>> section.",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Note that although serializers also validate data for compatibility, these validations are different from the validation in <<validation>>. Only the `cast` function also calls the full validation process from the <<validation>> chapter after successful deserialization, and throws an error if the data is not valid.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe <<validation>>.": "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see <<validation>>.",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "All functions from serialization and validation throw a `ValidationError` from `@deepkit/type` on errors.",
        "Cast": "Cast",
        "Todo": "Todo",
        "Serialisierung": "Serialization",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "The function `serialize` converts the passed data by default with the JSON serializer into a JSON object, that is: String, Number, Boolean, Object, or Array. The result of this can then be safely converted to a JSON using JSON.stringify.",
        "Deserialisierung": "Deserialization",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "The function `deserialize` converts the passed data per default with the JSON serializer into the corresponding specified types. The JSON serializer expects a JSON object, i.e.: string, number, boolean, object, or array. This is usually obtained from a JSON.parse call.",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "If the correct data type is already passed (for example, a Date object in the case of `created`), then this is taken as it is.",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "Not only a class, but any TypeScript type can be specified as the first type argument. So even primitives or very complex types can be passed:",
        "Weiche Typenkonvertierung": "Soft type conversion",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "In the deserialization process a soft type conversion is implemented. This means that String and Number for String types or a Number for a String type can be accepted and converted automatically. This is useful, for example, when data is accepted via a URL and passed to the deserializer. Since the URL is always a string, Deepkit Type still tries to resolve the types for Number and Boolean.",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "The following soft type conversions are built into the JSON serializer:",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*: Number or Bigint accept String, Number, and BigInt. `parseFloat` or `BigInt(x)` are used in case of a necessary conversion.",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*: Boolean accepts Number and String. 0, '0', 'false' is interpreted as `false`. 1, '1', 'true' is interpreted as `true`.",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*string*: String accepts Number, String, Boolean, and many more. All non-string values are automatically converted with `String(x)`.",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "The soft conversion can also be deactivated:",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "In the case of invalid data, no attempt is made to convert it and instead an error message is thrown.",
        "Type-Decorators": "Type Decorators",
        "Integer": "Integer",
        "Mapped": "Mapped",
        "Naming Strategy": "Naming Strategy",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Dependency Injection": "Dependency Injection",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "Dependency Injection (DI) is a design pattern in which classes and functions _receive_ their dependencies. It follows the principle of Inversion of Control (IoC) and helps to better separate complex code in order to significantly improve testability, modularity and clarity. Although there are other design patterns, such as the service locator pattern, for applying the principle of IoC, DI has established itself as the dominant pattern, especially in enterprise software.",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "To illustrate the principle of IoC, here is an example:",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "The UserRepository class has an HttpClient as a dependency. This dependency in itself is nothing remarkable, but it is problematic that UserRepository creates the HttpClient itself. This is obvious at first glance, but it has its drawbacks: What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?",
        "Inversion of Control": "Inversion of Control",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "In the thought of Inversion of Control (IoC) is the following alternative variant that sets the HttpClient as an explicit dependency in the constructor (also known as constructor injection).",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "Now UserRepository is no longer responsible for creating the HttpClient, but the user of UserRepository. This is Inversion of Control (IoC). The control has been reversed or inverted. Specifically, this code applies dependency injection, because dependencies are received (injected) and no longer created or requested. Dependency Injection is only one variant of IoC.",
        "Service Locator": "Service Locator",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "Besides DI, Service Locator (SL) is also a way to apply the IoC principle. This is commonly considered the counterpart to Dependency Injection, as it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a Service Locator pattern.",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "The function `locator.getHttpClient` can have any name. Alternatives would be function calls like `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` or a container call like `container.get(HttpClient)`. An import of a global is a slightly different variant of a service locator, using the module system itself as the locator:",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "All these variants have in common that they explicitly request the HttpClient dependency. This request can happen not only to properties as a default value, but also somewhere in the middle of the code. Since in the middle of the code means that it is not part of a type interface, the use of the HttpClient is hidden. Depending on the variant of how the HttpClient is requested, it can sometimes be very difficult or completely impossible to replace it with another implementation. Especially in the area of unit tests and for the sake of clarity, difficulties can arise here, so that the service locator is now classified as an anti-pattern in certain situations.",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "With Dependency Injection, nothing is requested, but it is explicitly provided by the user or received by the code. As can be seen in the example of Inversion of Control, the dependency injection pattern has already been applied there. Specifically, constructor injection can be seen there, since the dependency is declared in the constructor. So UserRepository must now be used as follows.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether HttpClient should be created each time or the same one should be used each time is now decided by the user of the class and no longer by the class itself. It is no longer requested (from the class's point of view) as in the case of the service locator, or created entirely by itself in the initial example. This inversion of the flow has various advantages:",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "The code is easier to understand because all dependencies are explicitly visible.",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "The code is easier to test because all dependencies are unique and can be easily modified if needed.",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "The code is more modular, as dependencies can be easily exchanged.",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "It promotes the Separation of Concern principle, as UserRepository is no longer responsible for creating very complex dependencies itself when in doubt.",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "But an obvious disadvantage can also be recognized directly: Do I really need to create or manage all dependencies like the HttpClient myself? Yes and No. Yes, there are many cases where it is perfectly legitimate to manage the dependencies yourself. The hallmark of a good API is that dependencies don't get out of hand, and that even then they are pleasant to use. For many applications or complex libraries, this may well be the case. To provide a very complex low-level API with many dependencies in a simplified way to the user, facades are wonderfully suitable.",
        "Dependency Injection Container": "Dependency Injection Container",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "For more complex applications, however, it is not necessary to manage all dependencies yourself, because that is exactly what a so-called dependency injection container is for. This not only creates all objects automatically, but also \"injects\" the dependencies automatically, so that a manual \"new\" call is no longer necessary. There are various types of injection, such as constructor injection, method injection, or property injection. This makes it easy to manage even complicated constructions with many dependencies.",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "A dependency injection container (also called DI container or IoC container) brings Deepkit in `@deepkit/injector` or already ready integrated via app modules in the Deepkit framework. The above code would look like this using a low-level API from the `@deepkit/injector` package.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "The `injector` object in this case is the dependency injection container. Instead of using \"new UserRepository\", the container returns an instance of UserRepository using `get(UserRepository)`. To initialize the container statically a list of providers is passed to the function `InjectorContext.forProviders` (in this case simply the classes).",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "Since DI is all about providing dependencies, the dependencies are provided to the container, hence the technical term \"provider\". There are various types of providers: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. All together, they allow very flexible architectures to be mapped with a DI container.",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "All dependencies between providers are automatically resolved and as soon as an `injector.get()` call occurs, the objects and dependencies are created, cached, and correctly passed either as a constructor argument (constructor injection), set as a property (property injection), or passed to a method call (method injection).",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "Now to exchange the HttpClient with another one, another provider (here the ValueProvider) can be defined for HttpClient:",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "As soon as UserRepository is requested via `injector.get(UserRepository)`, it receives the AnotherHttpClient object. Alternatively, a ClassProvider can be used here very well, so that all dependencies of AnotherHttpClient are also managed by the DI container.",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "All types of providers are listed and explained in the <<dependency-injection-providers>> section.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "It should be mentioned here that Deepkit's DI container only works with Deepkit's runtime types. This means that any code that contains classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter <<runtime-types>>.",
        "Dependency Inversion": "Dependency Inversion",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "The example of UserRepository under Inversion of Control shows that UserRepository depends on a lower level HTTP library. In addition, a concrete implementation (class) is declared as a dependency instead of an abstraction (interface). At first glance, this may seem to be in line with the object-oriented paradigms, but it can lead to problems, especially in complex and large architectures.",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "An alternative variant would be to convert the HttpClient dependency into an abstraction (interface) and thus not import code from an HTTP library into UserRepository.",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "This is called the dependency inversion principle. UserRepository no longer has a dependency directly on an HTTP library and is instead based on an abstraction (interface). It thus solves two fundamental goals in this principle:",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "High-level modules should not import anything from low-level modules.",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "Implementations should be based on abstractions (interfaces).",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "Merging the two implementations (UserRepository with an HTTP library) can now be done via the DI container.",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "Since Deepkit's DI container is capable of resolving abstract dependencies (interfaces) like this one of HttpClientInterface, UserRepository automatically gets the implementation of HttpClient since HttpClient implemented the interface HttpClientInterface. This is done either by HttpClient specifically implementing HttpClientInterface (`class HttpClient implements HttpClientInterface`), or by HttpClient's API simply being compatible with HttpClientInterface.",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "As soon as HttpClient modifies its API (for example, removes the `get` method) and is thus no longer compatible with HttpClientInterface, the DI container throws an error (\"the HttpClientInterface dependency was not provided\").",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "Here the user, who wants to bring both implementations together, is in the obligation to find a solution. As an example, an adapter class could be registered here that implements HttpClientInterface and correctly forwards the method calls to HttpClient.",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "It should be noted here that although in theory the dependency inversion principle has its advantages, in practice it also has significant disadvantages. It not only leads to more code (since more interfaces have to be written), but also to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-use factor, which should be thought through before it is applied.",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "Design patterns should not be used blindly and across the board for even the simplest code. However, if the prerequisites such as a complex architecture, large applications, or a scaling team are given, dependency inversion and other design patterns only unfold their true strength.",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/injector` can be installed by itself or the Deepkit framework which already uses the library under the hood.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Once the library is installed, the API of it can be used directly.",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "To use Dependency Injection now, there are three ways.",
        "Injector API (Low Level)": "Injector API (Low Level)",
        "Module API": "Modules API",
        "App API (Deepkit Framework)": "App API (Deepkit Framework)",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "If `@deepkit/injector` is to be used without the deepkit framework, the first two variants are recommended.",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "The Injector API has already been introduced in the introduction to Dependency Injection. It is characterized by a very simple usage by means of a single class `InjectorContext` which creates a single DI container and is particularly suitable for simpler applications without modules.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "The `injector` object in this case is the dependency injection container. The function `InjectorContext.forProviders` takes an array of providers. See the <<dependency-injection-providers>> section to learn what values can be passed.",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "A more complex API is the `InjectorModule` class, which allows to store the providers in different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import themselves among themselves, providers export, in order to build up so a hierarchy and nicely separated architecture.",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "This API should be used if the application is more complex and the Deepkit framework is not used.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "The `injector` object in this case is the dependency injection container. Providers can be split into different modules and then imported again in different places using module imports. This creates a natural hierarchy that maps the hierarchy of the application or architecture.",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "The InjectorContext should always be given the top module in the hierarchy, also called root module or app module. The InjectorContext then only has an intermediary task: calls to `injector.get()` are simply forwarded to the root module. However, it is also possible to get providers from non-root modules by passing the module as a second argument.",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "All non-root modules are encapsulated by default, so that all providers in this module are only available to itself. If a provider is to be available to other modules, this provider must be exported. By exporting, the provider moves to the parent module of the hierarchy and can be used that way.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "To export all providers by default to the top level, the root module, the option `forRoot` can be used. This allows all providers to be used by all other modules.",
        "App API": "App API",
        "Einführung": "Introduction",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Once the Deepkit framework is used, modules are defined with the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. In addition, it is possible to work with powerful hooks and to define configuration loaders in order to map even more dynamic architectures.",
        "Providers": "Providers",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "There are several ways to provide dependencies in the Dependency Injection container. The simplest variant is simply the specification of a class. This is also known as short ClassProvider.",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "This represents a special provider, since only the class is specified. All other providers must be specified as object literals.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This will cause classes to be recreated each time or factories to be executed each time.",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "Besides the short ClassProvider there is also the regular ClassProvider, which is an object literal instead of a class.",
        "Dies ist Äquivalent zu diesen beiden:": "This is equivalent to these two:",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "It can be used to exchange a provider with another class.",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "In this example, the `OtherUserRepository` class is now also managed in the DI container and all its dependencies are resolved automatically.",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "Static values can be provided with this provider.",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "Since not only class instances can be provided as dependencies, any value can be specified as `useValue`. A symbol or a primitive (string, number, boolean) could also be used as a provider token.",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "Primitive provider tokens must be declared with the Inject type as a dependency.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "The combination of an inject alias and primitive provider tokens can also be used to provide dependencies from packages that do not contain runtime type information.",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "And then declared on the user side as follows:",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "A forwarding to an already defined provider can be defined.",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "A function can be used to provide a value for the provider. This function can also contain parameters, which in turn are provided by the DI container. Thus, other dependencies or configuration options are accessible.",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "In addition to classes and primitives, abstractions (interfaces) can also be provided. This is done via the function `provide` and is particularly useful if the value to be provided does not contain any type information.",
        "Asynchronous Providers": "Asynchronous Providers",
        "Asynchroner Provider sind aufgrund des Designs nicht möglich, da eine asynchroner": "Asynchronous providers are not possible due to the design, since an asynchronous",
        "Dependency Injection Container bedeuten würde, dass das Anfordern von Providern ebenfalls asynchron": "Dependency Injection container would mean that requesting providers would also be asynchronous.",
        "wäre und damit die gesamte Anwendung auf höchster Ebene bereits zur asynchronität gezwungen ist.": "would be and thus the entire application is already forced to asynchrony at the highest level.",
        "Um etwas asynchron zu initialisieren, sollte dieses Initialisieren in den Application Server Bootstrap verlagert werden,": "To initialize something asynchronously, this initialization should be moved to the application server bootstrap,",
        "da dort die Events asynchron sein können. Alternativ kann eine Initialisierung manuell angestossen werden.": "because there the events can be asynchronous. Alternatively, an initialization can be triggered manually.",
        "TODO: Explain it better, maybe example": "TODO: Explain it better, maybe example",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "If multiple providers have implemented the Connection interface, the last provider is used.",
        "Als Argument für provide() sind alle anderen Provider möglich.": "As argument for provide() all other providers are possible.",
        "Constructor/Property Injection": "Constructor/Property Injection",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "In most cases, constructor injection is used. All dependencies are specified as constructor arguments and are automatically injected by the DI container.",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "Optional dependencies should be marked as such, otherwise an error could be triggered if no provider can be found.",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "An alternative to constructor injection is property injection. This is usually used when the dependency is optional or the constructor is otherwise too full. The properties are automatically assigned once the instance is created (and thus the constructor is executed).",
        "Konfiguration": "Configuration",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "The dependency injection container also allows configuration options to be injected. This configuration injection can be received via constructor injection or property injection.",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "The Module API supports the definition of a configuration definition, which is a regular class. By providing such a class with properties, each property acts as a configuration option. Because of the way classes can be defined in TypeScript, this allows defining a type and default values per property.",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "The configuration options `domain` and `debug` can now be used quite conveniently type-safe in providers.",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "The values of the options themselves can be set via `configure()`.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Options that do not have a default value but are still necessary can be provided with a `!`. This forces the user of the module to provide the value, otherwise an error will occur.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Also, all serialization and validation types from the previous <<validation>> and <<serialization>> chapters can be used to specify in great detail what type and content constraints an option must have.",
        "Injection": "Injection",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "Configuration options, like other dependencies, can be safely and easily injected through the DI container as shown earlier. The simplest method is to reference a single option using the index access operator:",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "Configuration options can be referenced not only individually, but also as a group. The TypeScript utility type `Partial` is used for this purpose:",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "To get all configuration options, the configuration class can also be referenced directly:",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "However, it is recommended to reference only the configuration options that are actually used. This not only simplifies unit tests, but also makes it easier to see what is actually needed from the code.",
        "Scopes": "Scopes",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "By default, all providers of the DI container are singletons and are therefore instantiated only once. This means that in the example of UserRepository there is always only one instance of UserRepository during the entire runtime. At no time is a second instance created, unless the user does this manually with the \"new\" keyword.",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "However, there are various use cases where a provider should only be instantiated for a short time or only during a specific event. Such an event could be, for example, an HTTP request or an RPC call. This would mean that a new instance is created for each event and after this instance is no longer used it is automatically removed (by the garbage collector).",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "An HTTP request is a classic example of a scope. For example, providers such as a session, a user object, or other request-related providers can be registered to this scope. To create a scope, simply choose an arbitrary scope name and then specify it with the providers.",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "Once a scope is specified, this provider cannot be obtained directly from the DI container, so the following call will fail:",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "Instead, a scoped DI container must be created. This would happen every time an HTTP request comes in:",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "Providers that are also registered in this scope can now be requested on this scoped DI container, as well as all providers that have not defined a scope.",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "Since all providers are singleton by default, each call to `get(UserSession)` will always return the same instance per scoped container. If you create multiple scoped containers, multiple UserSessions will be created.",
        "Scoped DI Container haben die Fähigkeit, Werte dynamisch von außen zu setzen. So ist es zum Beispiel bei einem HTTP-Scope einfach möglich, die Objekte HttpRequest und HttpResponse zu setzen.": "Scoped DI containers have the ability to set values dynamically from the outside. For example, in an HTTP scope, it is easy to set the HttpRequest and HttpResponse objects.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "Applications using the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See the chapter <<cli>>, <<http>>, or <<rpc>> respectively.",
        "Setup Calls": "Setup Calls",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "Setup calls allow to manipulate the result of a provider. This is useful for example to use another dependency injection variant, the method injection.",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "Setup calls can only be used with the module API or the app API and are registered above the module.",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "The `setupProvider` method thereby returns a proxy object of UserRepository on which its methods can be called. It should be noted that these method calls are merely placed in a queue and are not executed at this time. Accordingly, no return value is returned.",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "In addition to method calls, properties can also be set.",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "This assignment is also simply placed in a queue.",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "The calls or the assignments in the queue are then executed on the actual result of the provider as soon as this is created. That is with a ClassProvider these are applied to the class instance, as soon as the instance is created, with a FactoryProvider on the result of the Factory, and with a ValueProvider on the Provider.",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "To reference not only static values, but also other providers, the function `injectorReference` can be used. This function returns a reference to a provider, which is also requested by the DI container when the setup calls are executed.",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces*",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Setup calls can also be assigned to an interface.",
        "Event System": "Event System",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "An event system allows application components in the same process to communicate with each other by sending and listening for events. It helps modularize the code by sending messages between functions that do not know about each other directly.",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "The application or library opens the possibility to execute additional functions at a certain time of the execution. These additional functions register themselves as so-called event listeners.",
        "Ein Event kann dabei vielfältig sein:": "An event can be multifaceted:",
        "Die Anwendung fährt hoch oder runter.": "The application goes up or down.",
        "Ein neuer User wurde erstellt oder gelöscht.": "A new user has been created or deleted.",
        "Eine Error wurde geworfen.": "An error was thrown.",
        "Ein neuer HTTP-Request ist hereingekommen.": "A new HTTP request has come in.",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit Framework and its libraries already offer various events to which the user can listen and react. However, any number of custom events can be created to make the application modularly extensible.",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "Below is an example of the low-level API of `@deepkit/event`. When using Deepkit framework, event listener registration is not done via `EventDispatcher` directly but via modules.",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since Deepkit's event system is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/event` can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "Note that `@deepkit/event` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.",
        "Event Token": "Event token",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "At the heart of the event system are the event tokens. They are objects that define the unique event ID and the event type. An event can be triggered and an event can be listened to via an event token. Conceptually, the person who triggers the event of an event token is also the owner of this event token. The event token decides accordingly which data is available at the event and whether asynchronous event listeners are allowed.",
        "TODO asynchrone": "TODO asynchronous",
        "Event Types": "Event Types",
        "Propagation": "Propagation",
        "TODO. event.stop()": "TODO. event.stop()",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Command-line Interface (CLI) programs are programs that interact via the terminal in the form of text input and text output. The advantage of interacting with the application in this variant is that only a terminal must exist either locally or via an SSH connection.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "A CLI application in Deepkit has full access to the DI container and can thus access all providers and configuration options.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "The arguments and options of the CLI application are controlled by method parameters via TypeScript types and are automatically serialized and validated.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI is one of three entry points to a Deepkit Framework application. In the Deepkit framework, the application is always launched via a CLI program, which is itself written in TypeScript by the user. Therefore, there is no Deepkit specific global CLI tool to launch a Deepkit application. This is how you launch the HTTP/RPC server, perform migrations, or run your own commands. This is all done through the same entry point, the same file. Once the Deepkit framework is used by importing `FrameworkModule` from `@deepkit/framework`, the application gets additional commands for the application server, migrations, and more.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "The CLI framework allows you to easily register your own commands and is based on simple classes. In fact, it is based on `@deepkit/app`, a small package intended only for this purpose, which can also be used standalone without the deepkit framework. In this package you can find decorators that are needed to decorate the CLI controller class.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "Controllers are managed or instantiated by the dependency injection container and can therefore use other providers. See the <<dependency-injection>> chapter for more details.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have @deepkit/type already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, @deepkit/app can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Note that `@deepkit/app` is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators`.",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "To create a command for your application, you need to create a CLI controller. This is a simple class that has an `exeecute` method and is equipped with information about the command.",
        "_Datei: app.ts_": "_File: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "In the decorator `@cli.controller` the unique name of the CLI application is defined as the first argument. Further options like a description can be optionally added in the object at the second position.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "This code is already a complete CLI application and can be started this way:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "You can see that a \"test\" command is available. To execute this, the name must be passed as an argument:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "It is also possible to make the file executable using `chmod +x app.ts`, so that the command `./app.ts` is already sufficient to start it. Note that then a so-called",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang is necessary. Shebang denotes the character combination `#!` at the beginning of a script program. In the example above this is already present: `&#35;!/usr/bin/env ts-node-script` and uses the script mode of `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "In this way, any number of commands can be created and registered. The unique name specified in `@cli.controller` should be well chosen and allows grouping of commands with the `:` character (e.g. `user:create`, `user:remove`, etc).",
        "Argumente": "Arguments",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "To add arguments, new parameters are added to the `execute` method and decorated with the `@arg` decorator.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "If you execute this command now without specifying a name, an error will be issued:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "By using `--help` you will get more information about the required arguments:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Once the name is passed as an argument, the `execute` method in TestCommand is executed and the name is passed correctly.",
        "Flags": "Flags",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags are another way to pass values to your command. Mostly these are optional, but they don`t have to be. Parameters decorated with `@flag name` can be passed via `--name value` or `--name=value`.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "In the help view you can see in the \"OPTIONS\" that a `--id` flag is necessary. If you enter this flag correctly, the command will receive this value.",
        "Boolean Flags": "Boolean Flags",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flags have the advantage that they can also be used as a worthless flag, for example to activate a certain behavior. As soon as a parameter is marked as an optional Boolean, this behavior is activated.",
        "Multiple Flags": "Multiple Flags",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "To pass multiple values to the same flag, a flag can be marked as an array.",
        "Single Character Flags": "Single Character Flags",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "To allow a flag to be passed as a single character as well, `@flag.char('x')` can be used.",
        "Optional / Default": "Optional / Default",
        "Dasselbe für Parameter mit einem Default-Wert:": "The same for parameters with a default value:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "This also applies to flags in the same way.",
        "Serialization / Validation": "Serialization / Validation",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "All arguments and flags are automatically deserialized based on its types, validated and can be provided with additional constraints.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "Thus, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the feature <<serialization-loosely-conversion>>.",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Additional constraints can be defined with the type decorators from `@deepkit/type`.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "The type `Postive` in `id` indicates that only positive numbers are wanted. If the user now passes a negative number, the code in `execute` will not be executed at all and an error message will be presented.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "If the number is positive, this works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong entries. See the chapter <<validation>> for more information.",
        "Description": "Description",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "To describe a flag or argument, `@flag.description` or `@arg.description` can be used respectively.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "In the help view, this description appears after the flag or argument:",
        "Exit code": "Exit code",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "The exit code is 0 by default, which means that the command was executed successfully. To change the exit code, a number other than 0 should be returned in the `exucute` method.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "The class of the command is managed by the DI Container, so dependencies can be defined that are resolved via the DI Container.",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "Processing HTTP requests is one of the most well-known tasks for a server. It converts an input (HTTP request) into an output (HTTP response) and performs a specific task. A client can send data to the server via an HTTP request in a variety of ways, which must be read and handled correctly. In addition to the HTTP body, HTTP query or HTTP header values are also possible. How data is actually processed depends on the server. It is the server that defines where and how the values are to be sent by the client.",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "The top priority here is not only to correctly execute what the user expects, but to correctly convert (deserialize) and validate any input from the HTTP request.",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "The pipeline through which an HTTP request passes on the server can be varied and complex. Many simple HTTP libraries pass only the HTTP request and the HTTP response for a given route, and expect the developer to process the HTTP response directly. A middleware API allows the pipeline to be extended as needed.",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "This is very well tailored for simple use cases, but quickly becomes confusing as the application grows, since all inputs and outputs must be manually serialized or deserialized and validated. Also, consideration must be given to how objects and services such as a database abstraction can be obtained from the application itself. It forces the developer to put an architecture on top of it that maps these mandatory functionalities.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Deepkit's HTTP library leverages the power of TypeScript and Dependency Injection. Serialization/deserialization and validation of any values happen automatically based on the defined types. It also allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of an architecture.",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "It can be used either with an existing HTTP server like Node's `http` module or with the Deepkit framework. Both API variants have access to the dependency injection container and can thus conveniently retrieve objects such as a database abstraction and configurations from the application.",
        "_Deepkit Beispiel_": "_Deepkit Example_",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since CLI programs in Deepkit are based on runtime types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "Note that `@deepkit/http` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.",
        "Funktionale API": "Functional API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "The functional API is based on functions and can be registered via the router registry, which can be obtained via the DI container of the app.",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "The router registry can also be obtained in Event Listener or in the bootstrap, so that based on modules, configurations and other providers various routes are registered.",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "Once modules are used, functional routes can also be provided dynamically by modules.",
        "Siehe <<framework-modules>>, um mehr über App Module zu erfahren.": "See <<framework-modules>> to learn more about App Modules.",
        "Controller API": "Controller API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "The controller API is based on classes and can be registered via the App-API under the option `controllers`.",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "Once modules are used, controllers can also be provided by modules.",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "To provide controllers dynamically (depending on the configuration option, for example), the `process` hook can be used.",
        "HTTP Server": "HTTP Server",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "If Deepkit Framework is used, an HTTP server is already built in. However, the HTTP library can also be used with its own HTTP server without using the Deepkit framework.",
        "HTTP Client": "HTTP Client",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name that can be referenced when forwarding. Depending on the API, the way a name is defined differs.",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "From all routes with a name the URL can be requested by `Router.resolveUrl()`.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "The router functions as well as the controller classes and controller methods can define arbitrary dependencies, which are resolved by the dependency injection container. For example, it is possible to conveniently get to a database abstraction or logger.",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "For example, if a database has been provided as a provider, it can be injected:",
        "_Funktionaler API:_": "_Functional API:_",
        "_Controller API:_": "_Controller API:_",
        "Siehe <<dependency-injection>> für mehr Informationen.": "See <<dependency-injection>> for more information.",
        "Input": "Input",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "All of the following input variations function in the same way for both the functional and the controller API. They allow to read data from an HTTP request in a type-safe and decoupled way.",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "This leads not only to significantly increased security, but also easier unit testing,",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "since, strictly speaking, not even an HTTP request object needs to exist to test the route.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its <<serialization>> and <<validation>> features.",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "For simplicity, all examples with the functional API are shown below.",
        "Path Parameters": "Path Parameters",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "Path parameters are values extracted from the URL of the route. The type of the value depends on the type at the associated parameter of the function or method.",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "The conversion is done automatically with the <<serialization-loosely-conversion>> feature.",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "If a Path parameter is defined as a type other than string, it will be converted correctly.",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "Additional validation constraints can also be applied to the types.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in <<http-validation>> zu finden.": "All validation types from `@deepkit/type` can be applied. More about this can be found in <<http-validation>>.",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "The Path parameters have `[^/]+` set as a regular expression by default in the URL matching. The RegExp for this can be customized as follows:",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "This is only necessary in exceptional cases, because often the types in combination with validation types themselves already correctly restrict possible values.",
        "Query Parameters": "Query Parameters",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "Query parameters are values from the URL after the `?` character and can be read with the `HttpQuery<T>` type. The name of the parameter corresponds to the name of the query parameter.",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "Query parameters are also automatically deserialized and validated.",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*Warning*: Parameter values are not escaped/sanitized. Returning them directly in a string in a route as HTML opens a security hole (XSS). Make sure never to trust external input and filter/sanitize/convert data where necessary.",
        "Query Model": "Query Model",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "With a large number of query parameters, it can quickly become confusing. To bring order back in here, a model (class or interface) can be used, which summarizes all possible query parameters.",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "The properties in the given model can contain all TypeScript types and validation types that `@deepkit/type` supports. See the <<serialization>> and <<validation>> chapters.",
        "Body": "Body",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "For HTTP methods that allow an HTTP body, a body model can also be specified.",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "The body content type from the HTTP request must be either `application/x-www-form-urlencoded`, `multipart/form-data` or `application/json` so Deepkit can automatically convert this to JavaScript objects.",
        "Header": "Header",
        "Stream": "Stream",
        "Manual Validation Handling": "Manual Validation Handling",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "To manually take over the validation of the body model, a special type `HttpBodyValidation<T>` can be used. It allows to receive also invalid body data and to react very specifically to error messages.",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "As soon as `valid()` returns `false`, the values in the specified model may be in a faulty state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually processed in the same route.",
        "File Upload": "File Upload",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "A special property type on the body model can be used to allow the client to upload files. Any number of `UploadedFile` can be used.",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "By default, Router saves all uploaded files to a temp folder and removes them once the code in the route has been executed. It is therefore necessary to read the file in the specified path in `path` and save it to a permanent location (local disk, cloud storage, database).",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Validation in an HTTP server is a mandatory functionality, because almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "All inputs such as path parameters, query parameters, and body parameters are automatically validated for the specified TypeScript type. If additional constraints are specified via `@deepkit/type` types, these are also checked.",
        "Siehe <<validation>> für mehr Informationen dazu.": "See <<validation>> for more information on this.",
        "Output": "Output",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "A route can return various data structures. Some of them are handled in a special way, such as redirects and templates, and others, such as simple objects, are simply sent as JSON.",
        "JSON": "JSON",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "By default, normal JavaScript values are returned to the client as JSON with the header `application/json; charset=utf-8`.",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "If an explicit return type is specified for the function or method, the data is serialized to JSON with the Deepkit JSON Serializer according to this type.",
        "HTML": "HTML",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "To send HTML there are two possibilities. Either the object `HtmlResponse` or Template Engine with TSX is used.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu <<template>>.": "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See <<template>>.",
        "Custom Content": "Custom Content",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "Besides HTML and JSON it is also possible to send text or binary data with a specific content type. This is done via the object `Response`.",
        "HTTP Errors": "HTTP Errors",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "By throwing various HTTP errors, it is possible to immediately interrupt the processing of an HTTP request and output the corresponding HTTP status of the error.",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "By default, all errors are returned to the client as JSON. This behavior can be customized in the event system under the event `httpWorkflow.onControllerError`. See the section <<http-events>>.",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "The error `HttpAccessDeniedError` is a special case. As soon as it is thrown, the HTTP workflow (see <<http-events>>) does not jump to `controllerError` but to `accessDenied`.",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "Custom HTTP errors can be created and thrown with `createHttpError`.",
        "Zusätzliche Header": "Additional headers",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "To modify the header of an HTTP response, additional methods can be called on the `Response`, `JSONResponse`, and `HTMLResponse` objects.",
        "Redirect": "Redirect",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "To return a 301 or 302 redirect as a response, `Redirect.toRoute` or `Redirect.toUrl` can be used.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "The `Redirect.toRoute` method uses the name of the route. How to set a route name can be seen in the <<http-route-name>> section. If this referenced route (query or path) contains parameters, they can be specified via the second argument:",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "Alternatively, you can redirect to a URL with `Redirect.toUrl`.",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "By default, both use a 302 forwarding. This can be customized via the `statusCode` argument.",
        "Scope": "Scope",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "All HTTP controllers and functional routes are managed within the `http` dependency injection scope. HTTP controllers are instantiated accordingly for each HTTP request. This also means that both can access providers registered for the `http` scope. So additionally `HttpRequest` and `HttpResponse` from `@deepkit/http` are usable as dependencies. If Deepkit Framework is used, `SessionHandler` from `@deepkit/framework` is also available.",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "It can be useful to place providers in the `http` scope, for example to instantiate services for each HTTP request. Once the HTTP request has been processed, the `http` scoped DI container is deleted, thus cleaning up all its provider instances from the garbage collector (GC).",
        "Siehe <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "See <<dependency-injection-scopes>> to learn how to place providers in the `http` scope.",
        "Events": "Events",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "The HTTP module is based on a workflow engine that provides various event tokens that can be used to hook into the entire process of processing an HTTP request.",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "The workflow engine is a finite state machine that creates a new state machine instance for each HTTP request and then jumps from position to position. The first position is the `start` and the last one the `response`. Additional code can be executed in each position.",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "Each event token has its own event type with additional information.",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "Since all HTTP events are based on the workflow engine, its behavior can be modified by using the specified event and jumping there with the `event.next()` method.",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "The HTTP module uses its own event listeners on these event tokens to implement HTTP request processing. All these event listeners have a priority of 100, which means that when you listen for an event, your listener is executed first by default (since the default priority is 0). Add a priority above 100 to run after the HTTP module's event listeners.",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "For example, suppose you want to catch the event when a controller is invoked. If a particular controller is to be invoked, we check if the user has access to it. If the user has access, we continue. But if not, we jump to the next workflow item `accessDenied`. There, the procedure of an access-denied is then automatically processed further.",
        "Security": "Security",
        "Sessions": "Sessions",
        "Middleware": "Middleware",
        "Resolver": "Resolver",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "Router supports a way to resolve complex parameter types. For example, given a route such as `/user/:id`, this `id` can be resolved to a `user` object outside the route using a resolver. This further decouples HTTP abstraction and route code, further simplifying testing and modularity.",
        "Der Decorator in `@http.resolveParameter` gibt dabei an, welche Klasse mit dem `UserResolver` aufgelöst werden soll. Sobald nun die angegebene Klasse `User` als Parameter in der Funktion beziehungsweise Methode angegeben ist, wird der Resolver genutzt, um diese bereitzustellen.": "The decorator in `@http.resolveParameter` specifies which class is to be resolved with the `UserResolver`. As soon as the specified class `User` is specified as a parameter in the function or method, the resolver is used to provide it.",
        "Ist `@http.resolveParameter` an der Klasse angegeben, erhalten all Methoden dieser Klasse diesen Resolver. Der Decorator kann auch pro Methode angewendet werden:": "If `@http.resolveParameter` is specified at the class, all methods of this class get this resolver. The decorator can also be applied per method:",
        "Auch kann die funktionale API genutzt werden:": "Also, the functional API can be used:",
        "Das Objekt `User` muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der Benutzer eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle abbildbar sind.": "The `User` object does not necessarily have to depend on a parameter. It could just as well depend on a session or an HTTP header, and only be provided when the user is logged in. In `RouteParameterResolverContext` a lot of information about the HTTP request is available, so that many use cases can be mapped.",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "In principle, it is also possible to have complex parameter types provided via the Dependency Injection container from the `http` scope, since these are also available in the route function or method. However, this has the disadvantage that no asynchronous function calls can be used, since the DI container is synchronous throughout.",
        "RPC": "RPC",
        "RPC steht für Remote Procedure Call und erlaubt es, Funktionen (procedures) auf einem remote Server so aufzurufen als wäre es eine lokale Funktion. Im Gegensatz zu HTTP Client-Server Kommunikation geschieht die Zuordnung nicht über die HTTP-Methode und einer URL, sondern dem Funktionsnamen. Die zu sendenden Daten werden als normale Funktion-Argumente übergeben und das Resultat des Funktionsaufrufes auf dem Server an den Client zurückgesendet.": "RPC stands for Remote Procedure Call and allows to call functions (procedures) on a remote server as if it were a local function. In contrast to HTTP client-server communication, the assignment is not done via the HTTP method and a URL, but the function name. The data to be sent is passed as normal function arguments and the result of the function call on the server is returned to the client.",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion leichtgewichtiger ist, da weder mit Headern, URLs, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es oft einen speziellen Client benötigt.": "The advantage of RPC is that the client-server abstraction is more lightweight, since no headers, URLs, query strings or the like are used. The disadvantage is that functions on a server via RPC cannot be called easily by a browser and it often requires a special client.",
        "Ein Schlüsselfeature von RPC ist, dass die Daten zwischen dem Client und Server automatisch serialisiert und deserialisiert werden. Aus diesem Grund sind meist typen-sichere RPC-Clients möglich. Manche RPC-Frameworks zwingen den Benutzern daher, die Typen (Parameter-Types und Return-Types) in einem bestimmten Format bereitzustellen. Dies kann in Form von einer eigenen DSL wie bei gRPC (Protocol Buffers) und GraphQL mit einem Code-Generator sein oder in Form von einem JavaScript Schema-Builder. Zusätzliche Validierung der Daten kann das RPC-Framework ebenfalls anbieten, wird aber nicht von allen unterstützt.": "A key feature of RPC is that the data between the client and server is automatically serialized and deserialized. For this reason, type-safe RPC clients are usually possible. Some RPC frameworks therefore force users to provide the types (parameter types and return types) in a specific format. This can be in the form of a custom DSL as in gRPC (Protocol Buffers) and GraphQL with a code generator, or in the form of a JavaScript schema builder. Additional validation of the data can also be provided by the RPC framework, but is not supported by all.",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "In Deepkit RPC, the types from the functions are extracted from the TypeScript code itself (see <<runtime-types>>), so there is no need to use a code generator or define them manually. Deepkit supports automatic serialization and deserialization of parameters and results in this regard. Once additional constraints are defined from <<validation>>, they are also automatically validated. This makes communication via RPC extremely type-safe and effective. The support for streaming via `rxjs` in Deepkit RPC also makes this RPC framework a suitable tool for real-time communication.",
        "Um das Konzept hinter RPC zu veranschaulichen folgender Code:": "To illustrate the concept behind RPC the following code:",
        "Eine Methode wie `hello` wird ganz normal innerhalb einer Klasse auf dem Server implementiert und kann dann von einem remote Client aufgerufen werden.": "A method like `hello` is implemented normally within a class on the server and can then be called from a remote client.",
        "Da RPC fundamental auf asynchroner Kommunikation basiert, ist die Kommunikation meist über HTTP, kann aber auch über TCP oder WebSockets geschehen. Das bedeutet, dass alle Funktionsaufrufe in TypeScript selbst zu einem `Promise` umgewandelt werden. Mit einem entsprechenden `await` kann das Resultat asynchron empfangen werden.": "Since RPC is fundamentally based on asynchronous communication, communication is mostly over HTTP, but can also happen over TCP or WebSockets. This means that all function calls in TypeScript itself are converted to a `promise`. With a corresponding `await` the result can be received asynchronously.",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Sobald ein Projekt im Client (meist Frontend) und Server (backend) TypeScript genutzt wird, spricht man von Isomorphic TypeScript. Ein typen-sicheres RPC Framework, das auf TypeScript's Typen basiert, ist dann besonders profitable für ein solches Projekt, da Typen zwischen Client und Server geteilt werden können.": "As soon as a project uses TypeScript in the client (mostly frontend) and server (backend), it is called Isomorphic TypeScript. A type-safe RPC framework based on TypeScript's types is then particularly profitable for such a project, since types can be shared between client and server.",
        "Um diesen Vorteil zu nutzen, sollten Typen, die auf beiden Seiten genutzt werden, in eine eigene Datei oder Package ausgelagert werden. Das Importieren auf der jeweiligen Seite fügt diese dann wieder zusammen.": "To take advantage of this, types that are used on both sides should be swapped out into a separate file or package. Importing on the respective side will then merge them again.",
        "Das Interface `UserControllerApi` agiert hierbei als Vertrag zwischen Client und Server. Der Server muss dies korrekt implementieren und der Client kann es konsumieren.": "The interface `UserControllerApi` acts here as a contract between client and server. The server must implement this correctly and the client can consume it.",
        "Abwärtskompatiblität kann auf dieselbe Art und Weise umgesetzt werden wie bei einer normalen lokalen API auch: Entweder werden neue Parameter als optional markiert oder es wird eine neue Methode hinzugefügt.": "Backward compatibility can be implemented in the same way as for a normal local API: either new parameters are marked as optional or a new method is added.",
        "Es ist zwar auch möglich, direkt `UserController` via `import type { UserController } from './server.ts` zu importieren, so hat dies jedoch andere Nachteile wie keine Unterstützung für nominale Typen (was bedeutet, dass Klassen-Instanzen nicht mit `instanceof` geprüft werden können).": "While it is also possible to directly import `UserController` via `import type { UserController } from './server.ts`, this has other disadvantages like no support for nominal types (which means that class instances cannot be checked with `instanceof`).",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since Deepkit RPC is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/rpc` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/rpc` can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass Controller-Klassen in `@deepkit/rpc` auf TypeScript-Decorators basieren und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss": "Note that controller classes in `@deepkit/rpc` are based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators`.",
        "Das Paket `@deepkit/rpc` muss auf dem Server und Client installiert werden, sofern beide ihre eigene `package.json` haben.": "The `@deepkit/rpc` package must be installed on the server and client if both have their own `package.json`.",
        "Um über TCP mit dem Server zu kommunizieren, muss das Paket `@deepkit/rpc-tcp` im Client und Server installiert werden.": "To communicate with the server via TCP, the `@deepkit/rpc-tcp` package must be installed in the client and server.",
        "Für eine WebSocket-Kommunikation braucht es das Paket ebenfalls auf dem Server. Der Client im Browser hingegen nutzt `WebSocket` aus dem offiziellen Standard.": "For a WebSocket communication it needs the package on the server as well. The client in the browser, on the other hand, uses `WebSocket` from the official standard.",
        "Sobald der Client über WebSocket auch in einer Umgebung genutzt werden soll, wo `WebSocket` nicht verfügbar ist (zum Beispiel NodeJS), so wird das Paket `ws` in dem Client benötigt.": "As soon as the client is to be used via WebSocket in an environment where `WebSocket` is not available (for example NodeJS), the package `ws` is required in the client.",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend WebSockets und der low-level API von `@deepkit/rpc`. Sobald das Deepkit Framework benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "Below is a fully functional example based on WebSockets and the low-level API of `@deepkit/rpc`. Once the Deepkit framework is used, controllers are provided via app modules and no RpcKernel is instantiated manually.",
        "_Datei: server.ts_": "_file: server.ts_",
        "_Datei: client.ts_": "_file: client.ts_",
        "Server Controller": "Server Controller",
        "Das \"Procedure\" in Remote Procedure Call wird auch gerne Action genannt. Eine solche Action wird als Methode in einer Klasse definiert und mit dem `@rpc.action` Decorator markiert. Die Klasse selbst wird dabei als Controller durch den `@rpc.controller` Decorator markiert und einen eindeutigen Namen vergeben. Dieser Name wird dann im Client referenziert, um den korrekten Controller anzusprechen. Es können beliebig viele Controller definiert und registriert werden.": "The \"Procedure\" in Remote Procedure Call is also called Action. Such an action is defined as a method in a class and marked with the `@rpc.action` decorator. The class itself is marked as controller by the `@rpc.controller` decorator and assigned a unique name. This name is then referenced in the client to address the correct controller. Any number of controllers can be defined and registered.",
        "Nur Methoden, die auch als `@rpc.action()` markiert sind, können von einem Client angesprochen werden.": "Only methods that are also marked as `@rpc.action()` can be accessed by a client.",
        "Typen müssen explizit angeben werden und können nicht inferred werden. Das ist wichtig, da der Serializer genau wissen muss, wie die Typen aussehen, um diese in Binärdaten (BSON) oder JSON umzuwandeln.": "Types must be explicitly specified and cannot be inferred. This is important because the serializer needs to know exactly what the types are in order to convert them to binary data (BSON) or JSON.",
        "Client Controller": "Client Controller",
        "Der normale Flow in RPC ist es, dass der Client Funktionen auf dem Server ausführen kann. Es ist aber in Deepkit RPC auch möglich, dass der Server Funktionen auf dem Client ausführen kann. Um das zu erlauben, kann der Client ebenfalls einen Controller registrieren.": "The normal flow in RPC is that the client can perform functions on the server. However, it is also possible in Deepkit RPC for the server to perform functions on the client. To allow this, the client can also register a controller.",
        "Die Controller-Klassen werden von dem Dependency Injection Container von `@deepkit/injector` verwaltet. Wenn das Deepkit Framework genutzt wird, haben diese Controller automatisch zugriff auf die Provider des Modules, die den Controller bereitstellen.": "The controller classes are managed by the dependency injection container of `@deepkit/injector`. When the Deepkit framework is used, these controllers automatically have access to the module's providers that deploy the controller.",
        "Controller werden in dem Deepkit Framework in dem Dependency Injection Scope `rpc` instantiiert, sodass alle Controller automatisch auf diverse Provider aus diesem Scope zugriff haben. Diese zusätzlichen Provider sind `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, und `ConnectionWriter`.": "Controllers are instantiated in the Deepkit framework in the dependency injection scope `rpc` so that all controllers automatically have access to various providers from this scope. These additional providers are `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, and `ConnectionWriter`.",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden. Der RPC Controller wird dann über diesen DI Container instantiiert.": "However, as soon as a `RpcKernel` is instantiated manually, a DI container can also be passed there. The RPC controller is then instantiated via this DI container.",
        "Siehe <<dependency-injection>>, um mehr zu erfahren.": "See <<dependency-injection>> to learn more.",
        "Nominal Types": "Nominal Types",
        "Wenn Daten auf dem Client von dem Funktionsaufruf empfangen werden, wurden diese zuvor auf dem Server serialisiert und anschließend auf dem Client deserialisiert. Sind in dem Return-Typ der Funktion nun Klassen genutzt, werden diese im Client rekonstruiert, verlieren jedoch ihre nominale Identität und alle Methoden. Um diesem Verhalten entgegenzuwirken, können Klassen als nominale Typen über eine eindeutige ID registriert werden. Dies sollte für alle Klassen gemacht werden, die in einer RPC-API genutzt werden.": "When data is received on the client from the function call, it was previously serialized on the server and then deserialized on the client. If classes are now used in the return type of the function, they are reconstructed in the client, but lose their nominal identity and all methods. To counteract this behavior, classes can be registered as nominal types via a unique ID. This should be done for all classes used in an RPC API.",
        "Um eine Klasse zu registrieren ist das Nutzen von dem Decorator `@entity.name('id')` nötig.": "To register a class it is necessary to use the decorator `@entity.name('id')`.",
        "Sobald diese Klasse nun als Resultat einer Funktion genutzt wird, wird ihre Identität gewahrt.": "As soon as this class is now used as the result of a function, its identity is preserved.",
        "Error Forwarding": "Error Forwarding",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu <<rpc-nominal-types>>.": "RPC functions can throw errors. These errors are forwarded to the client by default and thrown again there. If custom error classes are used, their nominal type should be enabled. See <<rpc-nominal-types>> for this.",
        "Standardmäßig sind alle RPC Funktionen von jedem Client aus aufrufbar. Auch ist das Feature Peer-To-Peer Kommunikation standardmäßig aktiviert. Um hier genau einstellen zu können, welcher Client was darf, kann die Klasse `RpcKernelSecurity` überschrieben werden.": "By default, all RPC functions can be called from any client. Also the feature Peer-To-Peer communication is activated by default. To be able to set exactly which client is allowed to do what, the class `RpcKernelSecurity` can be overridden.",
        "Um diese zu nutzen wird entweder dem `RpcKernel` eine Instanz davon übergeben:": "To use this either the `RpcKernel` is passed an instance of it:",
        "Oder im Falle einer Deepkit Framework Anwendung die Klasse `RpcKernelSecurity` mit einem Provider überschrieben.": "Or in the case of a Deepkit Framework application the class `RpcKernelSecurity` is overwritten with a provider.",
        "Authentication / Session": "Authentication / Session",
        "Das Objekt `Session` ist standardmäßig eine anonyme Session, was bedeutet, dass der Client sich nicht authentifiziert hat. Sobald er sich authentifizieren will, wird die Methode `authenticate` aufgerufen.  Das Token, das die `authenticate` Methode erhält, kommt von dem Client und kann einen beliebigen Wert haben.": "The `session` object is by default an anonymous session, which means that the client has not authenticated itself. As soon as it wants to authenticate, the `authenticate` method is called.  The token that the `authenticate` method receives comes from the client and can have any value.",
        "Sobald der Client einen Token setzt, wird die Authentifizierung ausgeführt, sobald die erste RPC Funktion oder manuell `client.connect()` aufgerufen wird.": "Once the client sets a token, authentication is performed as soon as the first RPC function or manually `client.connect()` is called.",
        "Hier erhält `RpcKernelSecurity.authenticate` das Token `123456789` und kann entsprechend eine andere Session zurückgeben. Diese zurückgegebene Session wird dann an alle anderen Methoden wie der `hasControllerAccess` übergeben.": "Here `RpcKernelSecurity.authenticate` receives the token `123456789` and can return another session accordingly. This returned session is then passed to all other methods like the `hasControllerAccess`.",
        "Controller Access": "Controller Access",
        "Mit der Methode `hasControllerAccess` kann bestimmt werden, ob ein Client eine bestimmte RPC Funktion ausführen darf. Diese Methode wird bei jedem RPC Funktionsaufruf ausgeführt. Gibt diese `false` zurück, ist der Zugriff verweigert und es wird ein Fehler auf dem Client geworfen.": "The `hasControllerAccess` method can be used to determine whether a client is allowed to execute a specific RPC function. This method is executed on every RPC function call. If it returns `false`, access is denied and an error is thrown on the client.",
        "In `RpcControllerAccess` sind mehrere wertvolle Informationen über die RPC Funktion enthalten:": "In `RpcControllerAccess` there are several valuable information about the RPC function:",
        "Gruppen und zusätzliche Daten sind über den Decorator `@rpc.action()` änderbar:": "Groups and additional data can be changed via the decorator `@rpc.action()`:",
        "Transform Error": "Transform Error",
        "Da geworfene Fehler automatisch mit all seinen Informationen wie die Fehlermeldung und auch den Stacktrace dem Client weitergeleitet werden, könnte dies unerwünscht sensitive Informationen veröffentlichen. Um dies zu ändern, kann in der Methode `transformError` der geworfene Fehler abgeändert werden.": "Since thrown errors are automatically forwarded to the client with all its information like the error message and also the stacktrace, this could unwantedly publish sensitive information. To change this, in the method `transformError` the thrown error can be modified.",
        "Beachte, dass sobald der Error in einen generischen `Error` umgewandelt wird, der komplette Stacktrace und die Identität des Errors verloren gehen. Entsprechend kann in dem Client keine `instanceof` checks mehr auf den Error genutzt werden.": "Note that once the error is converted to a generic `error`, the complete stack trace and the identity of the error are lost. Accordingly, no `instanceof` checks can be used on the error in the client.",
        "Wird Deepkit RPC zwischen zwei Microservices verwendet, und ist somit der Client und Server unter vollständiger Kontrolle des Entwicklers, so ist ein Transformieren des Errors nur selten nötig. Läuft der Client hingegen in einem Browser bei einem Unbekannten, so sollte in `transformError` genaustens darauf geachtet werden, welche Informationen man preisgeben möchte. Im Zweifel sollte jeder Error mit einem generischen `Error` umgewandelt werden, um so sicherzustellen, dass keine internen Details nach außen gelangen. Das Loggen des Errors würde sich an dieser Stelle dann anbieten.": "If Deepkit RPC is used between two microservices, and thus the client and server are under complete control of the developer, then transforming the error is rarely necessary. If, on the other hand, the client is running in a browser with an unknown, then care should be taken in `transformError` as to what information is to be revealed. If in doubt, each error should be transformed with a generic `Error` to ensure that no internal details are leaked. Logging the error would then be a good idea at this point.",
        "Sofern die Deepkit RPC Library direkt benutzt wird, wird die `RpcKernelSecurity` Klasse selbst instantiiert. Benötigt diese Klasse eine Datenbank oder einen Logger, so muss dieser selbst übergeben werden.": "If the Deepkit RPC library is used directly, the `RpcKernelSecurity` class itself is instantiated. If this class needs a database or a logger, this must be passed itself.",
        "Wenn das Deepkit Framework genutzt wird, wird die Klasse von dem Dependency Injection Container instantiiert und hat so automatisch Zugriff auf alle anderen Provider der Anwendung.": "When the Deepkit framework is used, the class is instantiated by the Dependency Injection container and thus automatically has access to all other providers in the application.",
        "Siehe hierzu auch <<dependency-injection>>.": "See also <<dependency-injection>>.",
        "Streaming RxJS": "Streaming RxJS",
        "Transport Protocol": "Transport Protocol",
        "Deepkit RPC unterstützt mehrere Transportprotokolle. WebSockets ist dabei das Protokoll, das die beste Kompatibilität hat (da Browser es unterstützen) und gleichzeitig alle Features wie Streaming unterstützt. TCP ist in der Regel schneller und eignet sich hervorragend für die Kommunikation zwischen Servern (Microservices) oder Nicht-Browser Clients.": "Deepkit RPC supports several transport protocols. WebSockets is the protocol that has the best compatibility (since browsers support it) while supporting all features like streaming. TCP is usually faster and is great for communication between servers (microservices) or non-browser clients.",
        "Deepkit's RPC HTTP Protokoll ist dabei eine Variante, die besonders einfach im Browser zu debuggen ist, da jeder Funktionsaufruf ein HTTP-Request ist, hat jedoch seine Limitierungen wie kein Support für RxJS Streaming.": "Deepkit's RPC HTTP protocol is a variant that is particularly easy to debug in the browser, as each function call is an HTTP request, but has its limitations such as no support for RxJS streaming.",
        "TODO: Not implemented yet.": "TODO: Not implemented yet.",
        "WebSockets": "WebSockets",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.",
        "TCP": "TCP",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Connection": "Connection",
        "Read Replica": "Read Replica",
        "Primitives": "Primitive",
        "Primary Key": "Primary Key",
        "Auto Increment": "Auto Increment",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Optional / Nullable",
        "Embedded Types": "Embedded Types",
        "Default Values": "Default Values",
        "Default Expressions": "Default Expressions",
        "Complex Types": "Complex Types",
        "Exclude": "Exclude",
        "Database Specific Column Types": "Database Specific Column Types",
        "Session / Unit Of Work": "Session / Unit Of Work",
        "Identity Map": "Identity Map",
        "Change Detection": "Change Detection",
        "Request/Response": "Request/Response",
        "Query": "Query",
        "Find": "Find",
        "Filter": "Filter",
        "Equal": "Equal",
        "Greater / Smaller": "Greater / Smaller",
        "RegExp": "RegExp",
        "Grouping AND/OR": "Grouping AND/OR",
        "In": "In",
        "Order": "Order",
        "Pagination": "Pagination",
        "Aggregation": "Aggregation",
        "Join": "Join",
        "Returning": "Returning",
        "Patch": "Patch",
        "Delete": "Delete",
        "Lift": "Lift",
        "Repository": "Repository",
        "Relations": "Relations",
        "One To Many": "One To Many",
        "Many To Many": "Many To Many",
        "One To One": "One To One",
        "Constraints": "Constraints",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Inheritance": "Inheritance",
        "Table Per Class": "Table Per Class",
        "Single Table Inheritance": "Single Table Inheritance",
        "Index": "Index",
        "Case Sensitivity": "Case Sensitivity",
        "Character Sets": "Character Sets",
        "Collations": "Collations",
        "Batching": "Batching",
        "Caching": "Caching",
        "Multitenancy": "Multitenancy",
        "Query Events": "Query Events",
        "Unit Of Work Events": "Unit Of Work Events",
        "Transactions": "Transactions",
        "Isolations": "Isolations",
        "Locking": "Locking",
        "Optimistic Locking": "Optimistic Locking",
        "Pessimistic Locking": "Pessimistic Locking",
        "Custom Types": "Custom Types",
        "Logging": "Logging",
        "Migration": "Migration",
        "Seeding": "Seeding",
        "Raw Database Access": "Raw Database Access",
        "SQL": "SQL",
        "App Configuration": "App Configuration",
        "Composite Primary Key": "Composite Primary Key",
        "Plugins": "Plugins",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Server": "Server",
        "Client": "Client",
        "Key/Value": "Key/Value",
        "Publish / Subscribe": "Publish / Subscribe",
        "Template": "Template",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "A server-side TSX (JSX) based template engine that can be used to generate HTML in a type-safe manner.",
        "Components": "Components",
        "Function Components": "Function Components",
        "Class Components": "Class Components",
        "Dynamic HTML": "Dynamic HTML",
        "Optimization": "Optimization",
        "Framework": "Framework",
        "Modules": "Modules",
        "Configuration": "Configuration",
        "Application Server": "Application Server",
        "Public Directory": "Public Directory",
        "File Structure": "File Structure",
        "Logger": "Logger",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Workflow",
        "Testing": "Testing",
        "Debugger": "Debugger",
        "Module": "Modules",
        "Profiler": "Profiler",
        "Deployment": "Deployment",
        "Compiling": "Compiling",
        "Packaging": "Packaging",
        "Docker": "Docker",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript is JavaScript that scales. A language designed to implement complex use cases. It allows JavaScript to be written with types that are checked and removed at compile time. This resulting type safety allows for easier writing and maintenance of complex applications. This, among other things, is what has made TypeScript so popular: It allows finding bugs in code, especially on a large scale, much faster and easier than would be possible with pure JavaScript - and it works with JavaScript, not against it.",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "Deepkit is TypeScript that scales. A framework written in TypeScript for TypeScript, designed to develop very complex software in TypeScript. It brings many design patterns known from the Enterprise to TypeScript and introduces completely new features that are only possible with TypeScript's new type system to increase development speed especially in teams. Small applications can also benefit from this new approach, as Deepkit comes with many libraries for very common use cases that can be used individually or in combination. The framework itself is designed to be as agile as possible and as complex as necessary, not only to get initial results quickly, but also to maintain development speed in the long term.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript is now the largest developer community in the world and provides the developer with a correspondingly large selection of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies, API and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer in order for these libraries to work properly with each other at all. The provision of core functions, which are needed by virtually every project, in nicely abstracted libraries brought together in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are just a few very well-known and successful examples.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "These frameworks offer to the developer often far common and decades proven concepts, which are converted into libraries or components, in order to be able to be used so comfortably among themselves harmonizing demand-fairly. The offered functionalities and Design patterns are thereby not cubed, but based on sometimes over decades old concepts, which worked satisfactorily by the fight in the competition with alternative ideas.",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript has seen massive progress over the years, so that more and more design patterns from the enterprise environment can now be applied. Design patterns that can be found in more and more libraries, frameworks, and tools. However, JavaScript and also TypeScript have the problem that in order to efficiently apply many proven enterprise patterns, decisive functions are missing in the language itself. This does not mean that these design patterns cannot be applied in general, but that they are less efficient than in other current languages.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript completely removes its type information at compile time, once TypeScript is converted to JavaScript, so no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (converted/serialized), data is validated, meta-information is added to objects, or interface information is required. In these and many other use cases, type information can be very useful at runtime because it provides libraries with the information needed to efficiently provide functionality. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript's type system, forcing the developer to write types in a new way that has nothing to do with TypeScript's syntax. The result is that TypeScript's powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit has developed a type compiler that leaves type information in place, allowing dynamic types to be computed at runtime and existing type information to be read at runtime. With this paradigm shift, completely new ways of working are possible, providing the required information for the aforementioned use cases, radically simplifying the development of complex software, and giving the code more expressiveness. It is thus possible for the first time to use the full power and expressiveness of TypeScript at runtime as well.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "Based on this paradigm shift, Deepkit has developed a whole set of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP Router, RPC Framework, Logger, Template System, Event System and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. Finally, one of the key features of TypeScript is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale application architecture with appropriate enterprise patterns.",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit consists of two large areas: One is the Deepkit Libraries and the Deepkit Framework. The Deepkit Libraries are a whole family of standalone TypeScript libraries (NPM packages) that are good at one topic and are optimized, well tested, and designed to complement each other optimally. A project can use individual Deepkit libraries, or the entire Deepkit framework, which brings together all the capabilities of the libraries and complements them with additional tools such as the debugger. All together, it allows the developer to create complex, fast, and production-ready applications.",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit supports a wide range of use cases. From simple command-line tools (CLI programs) to web applications and micro-services to desktop or mobile applications. The code is designed to run in any known JavaScript engine (browser as well as NodeJS) and integrates beautifully with other frameworks such as Angular, React, and Vue.",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "The claim behind Deepkit Framework is to apply clean code, SOLID principles, and enterprise design patterns to not only offer correspondingly high code quality, but to allow the user to apply them as well. Deepkit also tries to promote these same principles in its documentation and examples, but does not force the developer to follow them themselves.",
        "High-Performance": "High-Performance",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "One of the most difficult problems in software development is to maintain a high development speed even after months or years, especially when the code and the team grow. There are many frameworks that promise to get you started quickly and allow you to cobble together more complex applications on your own in a very short time. However, these usually have the common problem that the development speed decreases drastically the older the project or the larger the team becomes. It is not uncommon that even after a few months and only a handful of developers, the development speed collapses to such an extent that it drops to 1% of the original speed.",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "To counteract this phenomenon, it is necessary to apply established design patterns and use the right framework and libraries in advance. Enterprise design patterns have established themselves for the reason that they scale excellently even with larger applications and large teams. Correctly applied, they develop their capabilities especially when a project is to be developed over a longer period of time (several months to years).",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "Design patterns have their advantages in theory, but in practice almost every pattern also has its disadvantages. These disadvantages vary depending on the language and framework, since the language and framework themselves determine how ergonomically a pattern can be applied. Just because a certain pattern can be used in a language, it does not mean that it automatically makes development better and faster.",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "Some languages are better suited than others for applying certain patterns. With JavaScript or even TypeScript itself, various design patterns are often usable in the core, but there are limitations here that massively affect the user experience and thus speed. For example, Typescript decorators with all their idiosyncrasies may become necessary if a dependency injection framework specifies and is based on them.",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit's runtime type system ensures that these design patterns can be applied in the most ergonomic way and with as little boilerplate as possible, unlocking their power to maintain high development speed not only initially, but also over the long term.",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "One of the biggest advantages of TypeScript is that complex code can be written better in many use cases. This includes frontend, backend, CLI tools, mobile and desktop apps, and much more. When a project spans these use cases and relies almost exclusively on TypeScript, it is called Isomorphic TypeScript. Using TypeScript in as much code as possible can massively increase development speed. So the following advantages are then suddenly available:",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "Code can be shared between departments (frontend, backend, microservice, etc).",
        "Models, Typen und Interfaces": "Models, types and interfaces",
        "Business logic": "Business logic",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "A unified audit system of a single package manager.",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "Reuse of known third-party libraries in all departments.",
        "Wissensteilung innerhalb der Teams.": "Knowledge sharing within teams.",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "Recruitment is simplified to one group (and the biggest one: JavaScript developers).",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit framework and its runtime type system are designed to exploit these and more advantages of Isomorphic TypeScript to the utmost, so that its maximum powers are revealed.",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "Old approaches such as the dual stack (frontend and backend in different languages) can no longer keep up by far, since the context switch between the languages alone already costs an enormous amount of energy and time. All the other advantages that have already been explained even make it an unfair comparison. An isomorphic tech stack like TypeScript, properly applied, is many times faster in development time on a fundamental level than any combination of a dual stack for backend/frontend like Java/JavaScript, PHP/JavaScript, or even JavaScript/JavaScript. Since faster development speed also means less time needed for the same features, it also means that Isomorphic TypeScript saves cash. Besides all the advantages already presented, this is the killer argument to use Isomorphic TypeScript in all the next especially commercial projects.",
        "Welcome to the Deepkit documentation. In this documentation you will find more information about how to use each library and the Deepkit Framework in great detail with example code.": "Welcome to the Deepkit documentation. In this documentation you will find more information about how to use each library and the Deepkit Framework in great detail with example code.",
        "API": "API",
        "Use the API documentation to get very detailed information about the API of each module.": "Use the API documentation to get very detailed information about the API of each module.",
        "link:https://deepkit.io/assets/api-docs/modules.html[API Documentation, role=big]": "link:https://deepkit.io/assets/api-docs/modules.html[API Documentation, role=big]",
        "Support": "Support",
        "If you need help, please join the Discord community server:": "If you need help, please join the Discord community server:",
        "link:https://deepkit.io/community[Community, role=big]": "link:https://deepkit.io/community[Community, role=big]",
        "Deepkit bietet ein ORM, das es ermöglicht, auf Datenbanken auf moderne Art und Weise zuzugreifen.": "Deepkit provides an ORM that allows to access databases in a modern way.",
        "Entities werden dabei einfach über TypeScript Typen definiert und dann direkt die Datenbank angesprochen.": "Entities are simply defined using TypeScript types and then the database is addressed directly.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/orm` selbst und ein Datenbank-Adapter installiert werden.": "If this is done successfully, `@deepkit/orm` itself and a database adapter can be installed.",
        "Sobald die Library installiert ist, kann ein Datenbank-Adapter installiert werden die API davon direkt benutzt werden.": "Once the library is installed, a database adapter can be installed and the API of it can be used directly.",
        "Falls Klassen als Entities verwendet werden sollen, muss <code>experimentalDecorators</code> in der tsconfig.json aktiviert werden:": "If classes are to be used as entities, <code>experimentalDecorators</code> must be enabled in tsconfig.json:",
        "Sobald die Library installiert ist, kann ein Datenbank-Adapter installiert und die API davon direkt benutzt werden.": "Once the library is installed, a database adapter can be installed and the API of it can be used directly.",
        "Entities werden dabei einfach über TypeScript Typen definiert:": "Entities are simply defined using TypeScript types:",
        "Dabei können beliebige TypeScript Typen und Validierung-Dekoratoren von Deepkit benutzt werden, um sein Entity vollumfänglich zu definieren.": "In doing so, any of Deepkit's TypeScript types and validation decorators can be used to fully define its entity.",
        "Das Entity-Typensystem ist dabei so ausgelegt, dass diese Typen beziehungsweise Klassen ebenfalls in anderen Bereichen wie HTTP-Routen, RPC-Aktionen, oder Frontend benutzt werden können. Das verhindert, dass man zum Beispiel einen User mehrmals in der gesamten Applikation verteilt definiert hat.": "The entity type system is designed so that these types or classes can also be used in other areas such as HTTP routes, RPC actions or frontend. This prevents, for example, that a user is defined several times in the entire application.",
        "Da Deepkit ORM auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since Deepkit ORM is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Dabei können beliebige TypeScript Typen und Validierung-Dekoratoren von Deepkit benutzt werden, um die Entity vollumfänglich zu definieren.": "In doing so, any TypeScript types and validation decorators from Deepkit can be used to fully define the entity.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.": "Controllers are managed or instantiated by the Dependency Injection container and can therefore use other providers. See the xref:dependency-injection.adoc[Dependency Injection] chapter for more details.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have @deepkit/type already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "Thus, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the feature xref:serialization.adoc#serialization-loosely-conversion.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel xref:validation.adoc[Validation] für mehr Informationen.": "If the number is positive, this works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong entries. See the chapter xref:validation.adoc[Validation] for more information.",
        "Da Deepkit ORM auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since Deepkit ORM is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Falls Klassen als Entities verwendet werden sollen, muss `experimentalDecorators` in der tsconfig.json aktiviert werden:": "If classes are to be used as entities, `experimentalDecorators` must be enabled in tsconfig.json:",
        "Es wird primär mit dem `Database` Objekt gearbeitet. Einmal instantiiert, kann es innerhalb der ganzen Anwendung genutzt werde, um Daten abzufragen oder zu manipulieren. Die Verbindung zur Datenbank wird dabei lazy initialisiert.": "Primarily the `Database` object is used. Once instantiated, it can be used throughout the application to query or manipulate data. The connection to the database is initialized lazy.",
        "Dem `Database` Objekt wird ein Adapter übergeben, welcher aus den Datenbank-Adaptern Libraries kommt.": "The `Database` object is passed an adapter, which comes from the database adapters libraries.",
        "Eine Entity ist entweder eine Klasse oder Object Literal (interface) und hat immer einen Primary Key.": "An entity is either a class or object literal (interface) and always has a primary key.",
        "Die Entity wird mittels Typen-Dekoratoren aus `@deepkit/type` mit alle notwendigen Informationen dekoriert. Zum Beispiel wird ein Primary Key definiert sowie diverse Felder und ihre Validierungen-Einschränkungen. Dieser Felder spiegeln die Datenbank-Struktur ab, in der Regel eine Tabelle oder eine Collection.": "The entity is decorated with all necessary information using type decorators from `@deepkit/type`. For example, a primary key is defined as well as various fields and their validation constraints. These fields reflect the database structure, usually a table or a collection.",
        "Durch spezielle Typen-Dekoratoren wie `Mapped<'name'>` kann ein Feldnamen auch auf einen anderen Namen in der Datenbank abgebildet werden.": "Special type decorators such as `Mapped<'name'>` can also be used to map a field name to another name in the database.",
        "Klasse": "Class",
        "Interface": "Interface",
        "Primitive Datentypen wie String, Number (bigint), und Boolean werden gängige Datenbank-Typen abgebildet. Es wird dabei lediglich der TypeScript Type genutzt.": "Primitive data types like String, Number (bigint), and Boolean are mapped to common database types. Only the TypeScript type is used.",
        "Jede Entity braucht genau einen Primary Key. Mehrere Primary Keys werden nicht unterstützt.": "Each entity needs exactly one primary key. Multiple primary keys are not supported.",
        "Der Basis-Typ eines Primary Keys kann dabei beliebig sein. Oft wird eine Nummer oder UUID verwendet.": "The base type of a primary key can be arbitrary. Often a number or UUID is used.",
        "Für MongoDB wird gerne die MongoId bzw ObjectID verwendet.": "For MongoDB the MongoId or ObjectID is often used.",
        "Bei Nummern bietet sich `AutoIncrement` an.": "For numbers, `AutoIncrement` is a good choice.",
        "Felder, die beim Einfügen automatisch inkrementiert werden sollen, werden mit dem `AutoIncrement` Dekorator annotiert. Alle Adapter unterstützen auto-increment Werte. Der MongoDB Adapter verwendet eine zusätzliche Collection, um den Zähler zu verfolgen.": "Fields that should be automatically incremented during insertion are annotated with the `AutoIncrement` decorator. All adapters support auto-increment values. The MongoDB adapter uses an additional collection to keep track of the counter.",
        "Ein Auto-Increment Feld ist ein automatischer Zähler und kann nur an einem Primary Key angewendet werden. Die Datenbank stellt automatisch sicher, dass eine ID nur einmal verwendet wird.": "An Auto-Increment field is an automatic counter and can only be applied to a Primary Key. The database automatically ensures that an ID is used only once.",
        "Felder, die vom Typ UUID (v4) sein sollten, werden mit dem Dekorator UUID annotiert. Der Laufzeittyp ist `string` und in der Datenbank selbst meist binär. Verwenden Sie die Funktion `uuid()`, um eine neue UUID v4 zu erzeugen.": "Fields that should be of type UUID (v4) are annotated with the decorator UUID. The runtime type is `string` and mostly binary in the database itself. Use the `uuid()` function to create a new UUID v4.",
        "Felder, die in MongoDB vom Typ ObjectID sein sollten, werden mit dem Dekorator `MongoId` annotiert. Der Laufzeittyp ist `string` und in der Datenbank selbst `ObjectId` (binär).": "Fields that should be of type ObjectID in MongoDB are annotated with the decorator `MongoId`. The runtime type is `string` and in the database itself `ObjectId` (binary).",
        "MongoID-Felder erhalten beim Einfügen automatisch einen neuen Wert. Es ist nicht zwingend nötig, den Feldnamen `_id` zu verwenden. Er kann einen beliebigen Namen haben.": "MongoID fields automatically get a new value when inserted. It is not mandatory to use the field name `_id`. It can have any name.",
        "Optionale Felder werden mit `title?: string` oder `title: string | null` als TypeScript-Typ deklariert. Man sollte nur eine Variante davon verwenden, normalerweise die optionale `?` Syntax, die mit `undefined` funktioniert.": "Optional fields are declared as TypeScript type with `title?: string` or `title: string | null`. You should use only one variant of this, usually the optional `?` syntax which works with `undefined`.",
        "Beide Varianten führen dazu, dass der Datenbank-Typ für alle SQL-Adapter `NULLABLE` ist. Der einzige Unterschied zwischen diesen Dekoratoren ist also, dass sie unterschiedliche Werte zur Laufzeit darstellen.": "Both variants result in the database type being `NULLABLE` for all SQL adapters. So the only difference between these decorators is that they represent different values at runtime.",
        "Im folgenden Beispiel ist das geänderte Feld optional und kann daher zur Laufzeit undefiniert sein, obwohl es in der Datenbank immer als NULL dargestellt wird.": "In the following example, the changed field is optional and can therefore be undefined at runtime, although it is always represented as NULL in the database.",
        "Dieses Beispiel zeigt, wie der nullable Typ funktioniert. Sowohl in der Datenbank als auch in der Javascript-Laufzeit wird NULL verwendet. Dies ist ausführlicher als `modified?: Date` und wird nicht häufig verwendet.": "This example shows how the nullable type works. NULL is used both in the database and in the javascript runtime. This is more verbose than `modified?: Date` and is not commonly used.",
        "Database Type Mapping": "Database Type Mapping",
        "Mit `DatabaseField` ist es möglich, ein Feld auf einen beliebigen Datenbank-Typen zu mappen. Der Typ muss eine gültige SQL-Anweisung sein, die unverändert an das Migrationssystem übergeben wird.": "With `DatabaseField` it is possible to map a field to any database type. The type must be a valid SQL statement that is passed unchanged to the migration system.",
        "Um ein Feld für eine bestimmte Datenbank zu mappen, kann entweder `SQLite`, `MySQL`, oder `Postgres` benutzt werden.": "To map a field for a specific database, either `SQLite`, `MySQL`, or `Postgres` can be used.",
        "Default-Werte werden": "Default values are",
        "Eine Session ist so etwas wie eine Arbeitseinheit. Sie verfolgt alles, was Sie tun, und hält die Änderungen automatisch fest, sobald `commit()` aufgerufen wird. Es ist der bevorzugte Weg, um Änderungen in der Datenbank auszuführen, da es Anweisungen in einer Weise bündelt, die es sehr schnell macht. Eine Session ist sehr leichtgewichtig und kann zum Beispiel leicht in einem Request-Response-Lebenszyklus erstellt werden.": "A session is something like a unit of work. It keeps track of everything you do and automatically records the changes whenever `commit()` is called. It is the preferred way to execute changes in the database because it bundles statements in a way that makes it very fast. A session is very lightweight and can easily be created in a request-response lifecycle, for example.",
        "Fügen Sie der Session mit `session.add(T)` neue Instanz hinzu oder entfernen Sie bereits vorhandene Instanzen mit `session.remove(T)`. Sobald Sie mit dem Session-Objekt fertig sind, dereferenzieren Sie es einfach überall, damit der Garbage-Collector es entfernen kann.": "Add new instance to the session with `session.add(T)` or remove existing instances with `session.remove(T)`. Once you are done with the Session object, simply dereference it everywhere so that the garbage collector can remove it.",
        "Änderungen werden bei Entity-Instanzen, die über das Session-Objekt geholt werden, automatisch erkannt.": "Changes are automatically detected for entity instances fetched via the Session object.",
        "Sessions bieten eine Identity-Map, die sicherstellt, dass es immer nur ein Javascript-Objekt pro Datenbank-Eintrag gibt. Wenn Sie zum Beispiel `session.query(User).find()` zweimal innerhalb derselben Sitzung ausführen, erhalten Sie zwei verschiedene Arrays, aber mit denselben Entitätsinstanzen darin.": "Sessions provide an identity map that ensures there is only ever one javascript object per database entry. For example, if you run `session.query(User).find()` twice within the same session, you get two different arrays, but with the same entity instances in them.",
        "Wenn Sie mit `session.add(entity1)` eine neue Entität hinzufügen und diese erneut abrufen, erhalten Sie genau dieselbe Entitätsinstanz `entity1`.": "If you add a new entity with `session.add(entity1)` and retrieve it again, you will get exactly the same entity instance `entity1`.",
        "Wichtig: Sobald Sie anfangen, Sessions zu verwenden, sollten Sie deren Methode `Session.query` anstelle von `Database.query` verwenden. Nur bei Session-Queries ist die Identitätszuordnungsfunktion aktiviert.": "Important: Once you start using sessions, you should use their `Session.query` method instead of `Database.query`. Only session queries have the identity mapping feature enabled.",
        "Ein Query ist ein Objekt, das beschreibt, wie Daten aus der Datenbank abgerufen oder geändert werden sollen. Es hat mehrere Methoden um das Query zu beschreiben und Abbruchmethoden die diese ausführen. Der Datenbankadapter kann die Query-API auf viele Arten erweitern, um Datenbank spezifische Features zu unterstützen.": "A query is an object that describes how to retrieve or modify data from the database. It has several methods to describe the query and termination methods that execute them. The database adapter can extend the query API in many ways to support database specific features.",
        "Sie können ein Query erstellen, indem Sie `Database.query(T)` oder `Session.query(T)` verwenden. Wir empfehlen Sessions da es die Leistung verbessert.": "You can create a query using `Database.query(T)` or `Session.query(T)`. We recommend Sessions as it improves performance.",
        "Ein Filter kann angewendet werden, um die Ergebnismenge einzuschränken.": "A filter can be applied to limit the result set.",
        "Select": "Select",
        "Um die Felder einzugrenzen, die von der Datenbank empfangen werden sollen, kann `select('field1')` verwendet werden.": "To narrow down the fields to be received from the database, `select('field1')` can be used.",
        "Wichtig dabei ist, dass sobald ein Eingrenzungen der Felder über `select` stattfindet, die Ergebnisse keine Instanzen der Entity mehr sind, sondern lediglich Object-Literals.": "It is important to note that as soon as the fields are narrowed down using `select`, the results are no longer instances of the entity, but only object literals.",
        "Mit `orderBy(field, order)` kann die Reihenfolge der Einträge geändert werden.": "With `orderBy(field, order)` the order of the entries can be changed.",
        "Es kann mehrere Male `orderBy` ausgeführt werden, um die Reihenfolge immer weiter zu verfeinern.": "Several times `orderBy` can be executed to refine the order more and more.",
        "Mit den Methoden `itemsPerPage()` und `page()` können die Ergebnisse paginiert werden. Seite beginnt bei 1.": "The `itemsPerPage()` and `page()` methods can be used to paginate the results. Page starts at 1.",
        "Mit den alternativen Methoden `limit` und `skip` können Sie manuell paginieren.": "With the alternative methods `limit` and `skip` you can paginate manually.",
        "Standardmäßig werden Referenzen aus der Entity weder in Abfragen einbezogen noch geladen. Um ein Join in die Abfrage aufzunehmen, ohne den Verweis zu laden, verwenden Sie `join()` (left join) oder `innerJoin()`. Um einen Join in die Abfrage aufzunehmen und die Referenz zu laden, verwenden Sie `joinWith()` oder `innerJoinWith()`.": "By default, references from the entity are neither included in queries nor loaded. To include a join in the query without loading the reference, use `join()` (left join) or `innerJoin()`. To include a join in the query and load the reference, use `joinWith()` or `innerJoinWith()`.",
        "Alle folgenden Beispiele gehen von diesen Modellschemata aus:": "All of the following examples assume these model schemes:",
        "Um Join-Abfragen zu ändern, verwenden Sie dieselben Methoden, jedoch mit dem `use`-Präfix: `useJoin`, `useInnerJoin`, `useJoinWith` oder `useInnerJoinWith`. Um die Änderung der Join-Abfrage zu beenden, verwenden Sie `end()`, um so die übergeordnete Abfrage zurückzubekommen.": "To modify join queries, use the same methods, but with the `use` prefix: `useJoin`, `useInnerJoin`, `useJoinWith` or `useInnerJoinWith`. To end the join query modification, use `end()` to get back the parent query.",
        "Mit Aggregationsmethoden können Sie Datensätze zählen und Felder aggregieren.": "Aggregation methods allow you to count records and aggregate fields.",
        "Die folgenden Beispiele gehen von diesem Modellschema aus:": "The following examples are based on this model scheme:",
        "`groupBy` ermöglicht es, das Ergebnis nach dem angegebenen Feld zu gruppieren.": "`groupBy` allows to group the result by the specified field.",
        "Es gibt mehrere Aggregationsmethoden: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Jede erfordert einen Feldnamen als erstes Argument und ein optionales zweites Argument, um den Alias zu ändern.": "There are several aggregation methods: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Each requires a field name as the first argument and an optional second argument to change the alias.",
        "Mit `returning` können bei Änderungen via `patch` und `delete` zusätzliche Felder angefordert werden.": "With `returning` additional fields can be requested in case of changes via `patch` and `delete`.",
        "Vorsicht: Nicht in allen Datenbank-Adaptern sind die Felder atomar zurückgegeben. Verwenden Sie Transaktionen, um Datenkonsistenz sicherzustellen.": "Caution: Not all database adapters return fields atomically. Use transactions to ensure data consistency.",
        "Gibt ein Array an Einträgen zurück, die zu dem angegebenen Filter passen.": "Returns an array of entries matching the specified filter.",
        "FindOne": "FindOne",
        "Gibt ein Eintrag zurück, der zu dem angegebenen Filter passen.": "Returns an entry that matches the specified filter.",
        "Wird kein Eintrag gefunden, wird ein `ItemNotFound` Fehler geworfen.": "If no item is found, an `ItemNotFound` error is thrown.",
        "FindOneOrUndefined": "FindOneOrUndefined",
        "Wird kein Eintrag gefunden, wird undefined zurückgegeben.": "If no entry is found, undefined is returned.",
        "FindField": "FindField",
        "Gibt eine Liste eines Feldes zurück, der zu dem angegebenen Filter passen.": "Returns a list of a field that match the specified filter.",
        "FindOneField": "FindOneField",
        "Patch ist eine Änderungsabfrage, die die in der Abfrage beschriebenen Datensätze patcht. Die Methoden": "Patch is a change query that patches the records described in the query. The methods",
        "`patchOne` und `patchMany` beenden die Abfrage und führen den Patch aus.": "`patchOne` and `patchMany` finish the query and execute the patch.",
        "`patchMany` ändert alle Einträge in der Datenbank, die zu dem angegebenen Filter passen. Ist kein Filter gesetzt, wird die gesamte Tabelle geändert. Nutzen Sie `patchOne`, um immer nur einen Eintrag zu verändern.": "`patchMany` changes all entries in the database that match the specified filter. If no filter is set, the whole table will be changed. Use `patchOne` to change only one entry at a time.",
        "`deleteMany` löscht alle Einträge in der Datenbank, die zu dem angegebenen Filter passen.": "`deleteMany` deletes all entries in the database that match the specified filter.",
        "Ist kein Filter gesetzt, wird die gesamte Tabelle gelöscht. Nutzen Sie `deleteOne`, um immer nur einene Eintrag zu löschen.": "If no filter is set, the entire table will be deleted. Use `deleteOne` to delete only one entry at a time.",
        "Has": "Has",
        "Gibt zurück, ob mindestens ein Eintrag in der Datenbank existiert.": "Returns whether at least one entry exists in the database.",
        "Count": "Count",
        "Gibt die Anzahl der Einträge zurück.": "Returns the number of entries.",
        "Das Lifting einer Abfrage bedeutet, dass ihr neue Funktionen hinzugefügt werden. Dies wird in der Regel entweder von Plugins oder komplexen Architekturen verwendet, um größere Abfrageklassen in mehrere praktische, wiederverwendbare Klassen aufzuteilen.": "Lifting a query means adding new functionality to it. This is usually used either by plugins or complex architectures to split larger query classes into several convenient, reusable classes.",
        "Beziehungen ermöglichen es Ihnen, zwei Entitäten auf eine bestimmte Art und Weise zu verbinden. Dies geschieht in Datenbanken in der Regel über das Konzept der Fremdschlüssel. Deepkit ORM unterstützt Relationen für alle offiziellen Datenbankadapter.": "Relationships allow you to connect two entities in a certain way. This is usually done in databases using the concept of foreign keys. Deepkit ORM supports relations for all official database adapters.",
        "Eine Relation wird mit dem `Reference`-Dekorator annotiert. Normalerweise hat eine Relation auch eine umgekehrte Relation, die mit dem Typ `BackReference` annotiert wird, aber nur benötigt wird, wenn die umgekehrte Relation in einer Datenbankabfrage verwendet werden soll. Rückreferenzen sind nur virtuell.": "A relation is annotated with the `Reference` decorator. Normally a relation also has a reverse relation, which is annotated with the `BackReference` type, but is only needed if the reverse relation is to be used in a database query. Back references are only virtual.",
        "Die Entität, die einen Verweis speichert, wird in der Regel als die \"besitzende Seite\" oder diejenige, die den Verweis \"besitzt\", bezeichnet. Der folgende Code zeigt zwei Entitäten mit einer One-To-Many-Beziehung zwischen `User` und `Post`. Das bedeutet, dass ein `User` mehrere `Post` haben kann. Die Entität `Post` besitzt die Beziehung `Post->User`. In der Datenbank selbst gibt es nun ein Feld `Post.\"author\"`, das den Primärschlüssel von `User` enthält.": "The entity that stores a reference is usually referred to as the `owning page` or the one that `owns` the reference. The following code shows two entities with a one-to-many relationship between `User` and `Post`. This means that a `User` can have multiple `Post`. The `post` entity has the `post->user` relationship. In the database itself there is now a field `Post. \"author\"` that contains the primary key of `User`.",
        "Referenzen werden in Abfragen standardmäßig nicht ausgewählt. Siehe dazu <<database-join>>.": "References are not selected in queries by default. See <<database-join>> for details.",
        "Many To One": "Many To One",
        "Ein Verweis hat in der Regel einen umgekehrten Verweis, der Many-to-One genannt wird. Es handelt sich nur um eine virtuelle Referenz, da sie nicht in der Datenbank selbst reflektiert wird. Eine Rückreferenz wird mit `BackReference` annotiert und wird hauptsächlich für Reflection und Query Joins verwendet. Wenn Sie eine `BackReference` von `User` zu `Post` hinzufügen, können Sie `Post` direkt aus `User`-Abfragen verbinden.": "A reference usually has a reverse reference called many-to-one. It is only a virtual reference, since it is not reflected in the database itself. A back reference is annotated `BackReference` and is mainly used for reflection and query joins. If you add a `BackReference` from `User` to `Post`, you can join `Post` directly from `User` queries.",
        "Eine Many-to-many-Beziehung ermöglicht es Ihnen, viele Datensätze mit vielen anderen zu verbinden. Sie kann zum Beispiel für Benutzer in Gruppen verwendet werden. Ein Benutzer kann in keiner, einer oder vielen Gruppen sein. Folglich kann eine Gruppe 0, einen oder viele Benutzer enthalten.": "A many-to-many relationship allows you to associate many records with many others. For example, it can be used for users in groups. A user can be in none, one or many groups. Consequently, a group can contain 0, one or many users.",
        "Many-to-many-Beziehungen werden normalerweise über eine Pivot-Entität implementiert. Die Pivot-Entität enthält die eigentlichen eigenen Referenzen auf zwei andere Entitäten, und diese beiden Entitäten haben Rückreferenzen auf die Pivot-Entität.": "Many-to-many relationships are usually implemented using a pivot entity. The pivot entity contains the actual own references to two other entities, and these two entities have back references to the pivot entity.",
        "Mit diesen Entities können Sie nun Benutzer und Gruppen erstellen und sie mit der Pivot-Entität verbinden. Durch die Verwendung eines Rückverweises in User können wir die Gruppen direkt mit einer User-Abfrage abrufen.": "With these entities, you can now create users and groups and connect them to the pivot entity. By using a back reference in User, we can retrieve the groups directly with a User query.",
        "Um die Verknüpfung eines Benutzers mit einer Gruppe aufzuheben, wird der Datensatz der UserGroup gelöscht:": "To unlink a user from a group, the UserGroup record is deleted:",
        "Ereignisse sind eine Möglichkeit, sich in Deepkit ORM einzuklinken und ermöglichen es Ihnen, leistungsfähige Plugins zu schreiben. Es gibt zwei Kategorien von Ereignissen: Abfrage-Ereignisse und Unit-of-Work-Ereignisse. Plugin-Autoren verwenden in der Regel beide, um beide Möglichkeiten der Datenmanipulation zu unterstützen.": "Events are a way to hook into Deepkit ORM and allow you to write powerful plugins. There are two categories of events: Query events and Unit-of-Work events. Plugin authors typically use both to support both ways of manipulating data.",
        "Events werden über `Database.listen` un einem Event-Token registriert. Es kann auch kurzlebige Event-Listener auf Sessions registriert werden.": "Events are registered via `Database.listen` with an event token. It is also possible to register short-lived event listeners on sessions.",
        "Abfrageereignisse werden ausgelöst, wenn eine Abfrage über `Database.query()` oder `Session.query()` ausgeführt wird.": "Query events are triggered when a query is executed via `Database.query()` or `Session.query()`.",
        "Jedes Event hat seine eigenen zusätzlichen Eigenschaften wie den Typ der Entität, die Abfrage selbst und die Datenbanksitzung. Sie können die Abfrage überschreiben, indem Sie eine neue Abfrage auf `Event.query` setzen.": "Each event has its own additional properties such as the type of entity, the query itself and the database session. You can override the query by setting a new query to `Event.query`.",
        "`Query` hat dabei mehrere Event-Tokens:": "Query\" has several event tokens:",
        "Unit-of-Work-Ereignisse werden ausgelöst, wenn eine neue Session änderungen absetzt.": "Unit-of-work events are triggered when a new session submits changes.",
        "Eine Transaktion ist eine sequentielle Gruppe von Anweisungen, Abfragen oder Operationen wie Select, Insert, Update oder Delete, die als eine einzige Arbeitseinheit ausgeführt werden, die bestätigt oder rückgängig gemacht werden kann.": "A transaction is a sequential group of statements, queries, or operations such as select, insert, update, or delete that are executed as a single unit of work that can be committed or rolled back.",
        "Deepkit unterstützt Transaktionen für alle offiziell unterstützten Datenbanken. Standardmäßig werden für jede Abfrage und Datenbanksitzung keine Transaktionen verwendet. Um Transaktionen zu aktivieren, gibt es zwei Hauptmethoden: Sessions und Callback.": "Deepkit supports transactions for all officially supported databases. By default, no transactions are used for any query and database session. To enable transactions, there are two main methods: sessions and callback.",
        "Session Transactions": "Session Transactions",
        "Sie können für jede erstellte Session eine neue Transaktion starten und zuweisen. Dies ist die bevorzugte Art der Interaktion mit der Datenbank, da Sie das Session-Objekt einfach weitergeben können und alle Abfragen, die von dieser Session instanziiert werden, automatisch seiner Transaktion zugewiesen werden.": "You can start and assign a new transaction for each session you create. This is the preferred way of interacting with the database, as you can easily pass on the Session object and all queries instantiated by this session will be automatically assigned to its transaction.",
        "Ein typisches Muster ist, alle Operationen in einen try-catch-Block zu verpacken und `commit()` in der allerletzten Zeile auszuführen (das nur ausgeführt wird, wenn alle vorherigen Befehle erfolgreich waren) und `rollback()` im catch-Block, um alle Änderungen zurückzunehmen sobald ein Fehler auftritt.": "A typical pattern is to wrap all operations in a try-catch block and execute `commit()` on the very last line (which is only executed if all previous commands succeeded) and `rollback()` in the catch block to roll back all changes as soon as an error occurs.",
        "Obwohl es eine alternative API gibt (siehe unten), funktionieren alle Transaktionen nur mit Datenbanksitzungsobjekten. Um offene Änderungen aus der Unit-of-Work in einer Datenbanksitzung an die Datenbank zu übertragen, wird normalerweise `commit()` aufgerufen. In einer transaktionalen Sitzung überträgt `commit()` nicht nur alle ausstehenden Änderungen in die Datenbank, sondern schließt auch die Transaktion ab (\"commits\") und schließt damit die Transaktion. Alternativ können Sie `session.flush()` aufrufen, um alle anstehenden Änderungen ohne `Commit` und damit ohne Abschluss der Transaktion zu übertragen. Um eine Transaktion zu committen, ohne die Unit-of-Work zu leeren, verwenden Sie `session.commitTransaction()`.": "Although there is an alternative API (see below), all transactions work only with database session objects. To commit outstanding changes from the unit-of-work to the database in a database session, `commit()` is normally called. In a transactional session, `commit()` not only commits all pending changes to the database, but also completes (\"commits\") the transaction, thereby closing the transaction. Alternatively, you can call `session.flush()` to commit all pending changes without `commit` and thus without closing the transaction. To commit a transaction without flushing the unit-of-work, use `session.commitTransaction()`.",
        "Sobald `commit()` oder `rollback()` in einer Session ausgeführt wird, wird die Transaktion freigegeben. Sie müssen dann `useTransaction()` erneut aufrufen, wenn Sie in einer neuen Transaktion weiterarbeiten wollen.": "Once `commit()` or `rollback()` is executed in a session, the transaction is released. You must then call `useTransaction()` again if you want to continue in a new transaction.",
        "Bitte beachten Sie, dass sobald die erste Datenbankoperation in einer transaktionalen Session ausgeführt wird, wird die zugewiesene Datenbankverbindung dem aktuellen Sitzungsobjekt fest und exklusiv zugewiesen (sticky). Somit werden alle nachfolgenden Operationen auf derselben Verbindung (und somit in den meisten Datenbanken auf demselben Datenbankserver) ausgeführt. Erst wenn entweder die transaktionale Session beendet wird (commit oder rollback), wird die Datenbankverbindung wieder freigegeben. Es ist daher zu empfehlen, eine Transaktion nur so kurz wie nötig zu halten.": "Please note that as soon as the first database operation is executed in a transactional session, the assigned database connection is permanently and exclusively assigned to the current session object (sticky). Thus, all subsequent operations will be performed on the same connection (and thus, in most databases, on the same database server). Only when either the transactional session is terminated (commit or rollback), the database connection is released again. It is therefore recommended to keep a transaction only as short as necessary.",
        "Wenn eine Session bereits mit einer Transaktion verbunden ist, gibt ein Aufruf von `session.useTransaction()` immer das gleiche Objekt zurück. Verwenden Sie `session.isTransaction()`, um zu prüfen, ob der Sitzung eine Transaktion zugeordnet ist.": "If a session is already associated with a transaction, a call to `session.useTransaction()` always returns the same object. Use `session.isTransaction()` to check if a transaction is associated with the session.",
        "Verschachtelte Transaktionen werden nicht unterstützt.": "Nested transactions are not supported.",
        "Transaktion Callback": "Transaction Callback",
        "Eine Alternative zu transaktionalen Sessions ist `database.transaction(callback)`.": "An alternative to transactional sessions is `database.transaction(callback)`.",
        "Die Methode `database.transaction(callback)` führt einen asynchronen Callback innerhalb einer neuen transaktionalen Session aus. Wenn der Callback erfolgreich ist (das heisst kein Fehler geworfen wird), wird die Session automatisch committed (und damit ihre Transaktion committed und alle Änderungen geleert). Wenn der Callback fehlschlägt, führt die Sitzung automatisch `rollback()` aus, und der Fehler wird weitergeleitet.": "The `database.transaction(callback)` method performs an asynchronous callback within a new transactional session. If the callback succeeds (that is, no error is thrown), the session is automatically committed (and thus its transaction committed and all changes flushed). If the callback fails, the session automatically executes `rollback()` and the error is propagated.",
        "Viele Datenbanken unterstützen verschiedene Arten von Transaktionen. Um das Transaktionsverhalten zu ändern, können Sie verschiedene Methoden für das zurückgegebene Transaktionsobjekt von `useTransaction()` aufrufen. Die Schnittstelle dieses Transaktionsobjekts hängt von dem verwendeten Datenbankadapter ab. Zum Beispiel hat das von einer MySQL-Datenbank zurückgegebene Transaktionsobjekt andere Optionen als das von einer MongoDB-Datenbank zurückgegebene. Verwenden Sie die Code-Vervollständigung oder sehen Sie sich die Schnittstelle des Datenbankadapters an, um eine Liste der möglichen Optionen zu erhalten.": "Many databases support different types of transactions. To change the transaction behavior, you can call different methods for the returned transaction object from `useTransaction()`. The interface of this transaction object depends on the database adapter used. For example, the transaction object returned from a MySQL database has different options than the one returned from a MongoDB database. Use code completion or view the database adapter's interface to get a list of possible options.",
        "Während Transaktionen für MySQL, PostgreSQL und SQLite standardmäßig funktionieren, müssen Sie MongoDB zunächst als \"Replikatsatz\" einrichten.": "While transactions for MySQL, PostgreSQL, and SQLite work by default, you must first set up MongoDB as a \"replica set\".",
        "Um eine Standard-MongoDB-Instanz in ein Replikatset zu konvertieren, lesen Sie bitte die offizielle Dokumentation link:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].": "To convert a standard MongoDB instance to a replica set, please refer to the official documentation link:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].",
        "Composite Primary-Key bedeutet, eine Entität hat mehrere Primärschlüssel, die automatisch zu einem \"zusammengesetzten Primärschlüssel\" zusammengefasst werden. Diese Art der Modellierung der Datenbank hat Vor- und Nachteile. Wir sind der Meinung, dass zusammengesetzte Primärschlüssel enorme praktische Nachteile haben, die ihre Vorteile nicht rechtfertigen, sodass sie als schlechte Praxis betrachtet werden sollten und daher vermieden werden sollten. Deepkit ORM unterstützt keine zusammengesetzten Primärschlüssel. In diesem Kapitel erklären wir warum und zeigen (bessere) Alternativen auf.": "Composite Primary-Key means, an entity has several primary keys, which are automatically combined to a \"composite primary key\". This way of modeling the database has advantages and disadvantages. We believe that composite primary keys have huge practical disadvantages that do not justify their advantages, so they should be considered bad practice and therefore avoided. Deepkit ORM does not support composite primary keys. In this chapter we explain why and show (better) alternatives.",
        "Nachteile": "Disadvantages",
        "Joins sind nicht trivial. Obwohl sie in RDBMS hochgradig optimiert sind, stellen sie in Anwendungen eine ständige Komplexität dar, die leicht aus dem Ruder laufen und zu Leistungsproblemen führen kann. Leistung nicht nur in Bezug auf die Ausführungszeit der Abfragen, sondern auch in Bezug auf die Entwicklungszeit.": "Joins are not trivial. Although they are highly optimized in RDBMS, they represent a constant complexity in applications that can easily get out of hand and lead to performance problems. Performance not only in terms of query execution time, but also in terms of development time.",
        "Joins": "Joins",
        "Jeder einzelne Join wird komplizierter, je mehr Felder beteiligt sind. Während viele Datenbanken Optimierungen implementiert haben, um Joins mit mehreren Feldern nicht per se langsamer zu machen, erfordert es vom Entwickler, diese Joins ständig im Detail zu durchdenken, da z. B. das Vergessen von Schlüsseln zu subtilen Fehlern führen kann (da der Join auch ohne Angabe aller Schlüssel funktioniert) und der Entwickler daher die vollständige zusammengesetzte Primärschlüsselstruktur kennen muss.": "Each individual join becomes more complicated as more fields are involved. While many databases have implemented optimizations to make joins with multiple fields not slower per se, it requires the developer to constantly think through these joins in detail, since, for example, forgetting keys can lead to subtle errors (since the join will work even without specifying all keys) and the developer therefore needs to know the full composite primary key structure.",
        "Indizes": "Indexes",
        "Indizes mit mehreren Feldern (die zusammengesetzte Primärschlüssel sind) leiden unter dem Problem der Feldreihenfolge in Abfragen. Während Datenbanksysteme bestimmte Abfragen optimieren können, ist es bei komplexen Strukturen schwierig, effiziente Operationen zu schreiben, die alle definierten Indizes korrekt nutzen. Bei einem Index mit mehreren Feldern (wie einem zusammengesetzten Primärschlüssel) ist es normalerweise erforderlich, die Felder in der richtigen Reihenfolge zu definieren, damit die Datenbank den Index tatsächlich verwenden kann. Wenn die Reihenfolge nicht korrekt angegeben ist (z. B. in einer WHERE-Klausel), kann dies leicht dazu führen, dass die Datenbank den Index überhaupt nicht verwendet und stattdessen eine vollständige Tabellendurchsuchung durchführt. Zu wissen, welche Datenbank-Abfrage auf welche Weise optimiert, ist ein fortgeschrittenes Wissen, über das neue Entwickler in der Regel nicht verfügen, das aber erforderlich ist, sobald Sie mit zusammengesetzten Primärschlüsseln arbeiten, damit Sie das Beste aus Ihrer Datenbank herausholen und keine Ressourcen verschwenden.": "Indexes with multiple fields (which are composite primary keys) suffer from the problem of field ordering in queries. While database systems can optimize certain queries, complex structures make it difficult to write efficient operations that correctly use all defined indexes. For an index with multiple fields (such as a composite primary key), it is usually necessary to define the fields in the correct order for the database to actually use the index. If the order is not specified correctly (for example, in a WHERE clause), this can easily result in the database not using the index at all and instead performing a full table scan. Knowing which database query optimizes in which way is advanced knowledge that new developers don't usually have, but is necessary once you start working with composite primary keys so that you get the most out of your database and don't waste resources.",
        "Migrationen": "Migrations",
        "Sobald Sie entscheiden, dass eine bestimmte Entität ein zusätzliches Feld zur eindeutigen Identifizierung (und damit zum Composite Primary Key wird) benötigt, führt dies zur Anpassung aller Entitäten in Ihrer Datenbank, die Beziehungen zu dieser Entität haben.": "Once you decide that a particular entity needs an additional field to uniquely identify it (and thus become the Composite Primary Key), this will result in the adjustment of all entities in your database that have relationships to that entity.",
        "Nehmen wir an, Sie haben z. B. eine Entität `User` mit zusammengesetztem Primärschlüssel und beschließen, in verschiedenen Tabellen einen Fremdschlüssel zu diesem `User` zu verwenden, z. B. in einer Pivot-Tabelle `audit_log`, `groups` und `posts`. Sobald Sie den Primärschlüssel von `User` ändern, müssen alle diese Tabellen in einer Migration ebenfalls angepasst werden.": "For example, suppose you have an entity `user` with composite primary key and decide to use a foreign key to this `user` in different tables, e.g. in a pivot table `audit_log`, `groups` and `posts`. Once you change the primary key of `user`, all these tables need to be adjusted in a migration as well.",
        "Dies macht Migrationsdateien nicht nur viel komplexer, sondern kann auch zu größeren Ausfallzeiten bei der Ausführung von Migrationsdateien führen, da Schemaänderungen in der Regel entweder eine vollständige Datenbanksperre oder zumindest eine Tabellensperre erfordern. Je mehr Tabellen von einer großen Änderung wie einer Indexänderung betroffen sind, desto länger dauert die Migration. Und je größer eine Tabelle ist, desto länger dauert die Migration.": "Not only does this make migration files much more complex, but it can also lead to greater downtime when running migration files, since schema changes usually require either a full database lock or at least a table lock. The more tables affected by a large change like an index change, the longer the migration will take. And the larger a table is, the longer the migration takes.",
        "Denken Sie an die Tabelle `audit_log`. Solche Tabellen haben in der Regel viele Datensätze (etwa Millionen), und Sie müssen sie bei einer Schemaänderung nur deshalb anfassen, weil Sie beschlossen haben, einen zusammengesetzten Primärschlüssel zu verwenden und dem Primärschlüssel von `User` ein zusätzliches Feld hinzuzufügen. Je nach Größe all dieser Tabellen werden Migrationsänderungen dadurch entweder unnötig teurer oder in einigen Fällen sogar so teuer, dass eine Änderung des Primärschlüssels von `User` finanziell nicht mehr vertretbar ist. Dies führt in der Regel zu Umgehungslösungen (z. B. Hinzufügen eines eindeutigen Indexes zur Benutzertabelle), die zu technischen Schulden führen und früher oder später auf der Liste der Altlasten landen.": "Think about the `audit_log` table. Such tables usually have many records (millions or so), and you have to touch them during a schema change only because you decided to use a composite primary key and add an additional field to the primary key of `User`. Depending on the size of all these tables, this either makes migration changes unnecessarily more expensive or, in some cases, so expensive that changing the primary key of `User` is no longer financially justifiable. This usually leads to workarounds (e.g. adding a unique index to the user table) that result in technical debt and sooner or later end up on the legacy list.",
        "Bei großen Projekten kann dies zu enormen Ausfallzeiten führen (von Minuten bis Stunden) und manchmal sogar zur Einführung eines völlig neuen Migrationsabstraktionssystems, das im Wesentlichen Tabellen kopiert, Datensätze in Geistertabellen einfügt und nach der Migration Tabellen hin und her verschiebt. Diese zusätzliche Komplexität wird wiederum jeder Entität aufgezwungen, die eine Beziehung zu einer anderen Entität mit einem zusammengesetzten Primärschlüssel hat, und wird umso größer, je größer Ihre Datenbankstruktur wird. Das Problem wird immer schlimmer, ohne dass es eine Möglichkeit gibt, es zu lösen (außer durch die vollständige Entfernung des zusammengesetzten Primärschlüssels).": "For large projects, this can result in enormous downtime (from minutes to hours) and sometimes even the introduction of an entirely new migration abstraction system that essentially copies tables, inserts records into ghost tables, and moves tables back and forth after migration. This added complexity is in turn imposed on any entity that has a relationship to another entity with a composite primary key, and becomes greater the larger your database structure becomes. The problem gets worse with no way to solve it (except by removing the composite primary key entirely).",
        "Auffindbarkeit": "Findability",
        "Wenn Sie Datenbankadministrator oder Data Engineer/Scientist sind, arbeiten Sie in der Regel direkt an der Datenbank und erkunden die Daten, wenn Sie sie brauchen. Bei zusammengesetzten Primärschlüsseln muss jeder Benutzer, der SQL direkt schreibt, von allen beteiligten Tabellen den richtigen Primärschlüssel kennen (und die Spaltenreihenfolge, um korrekte Indexoptimierungen zu erhalten). Dieser zusätzliche Overhead erschwert nicht nur die Untersuchung von Daten, die Erstellung von Berichten usw., sondern kann auch zu Fehlern in älterem SQL führen, wenn ein zusammengesetzter Primärschlüssel plötzlich geändert wird. Das alte SQL ist wahrscheinlich immer noch gültig und läuft einwandfrei, liefert aber plötzlich falsche Ergebnisse, da das neue Feld im zusammengesetzten Primärschlüssel in der Verknüpfung fehlt. Es ist hierbei viel einfacher, lediglich einen Primärschlüssel zu haben. Dies erleichtert die Auffindbarkeit von Daten und stellt sicher, dass alte SQL-Abfragen auch dann noch korrekt funktionieren, wenn Sie sich entscheiden, die Art und Weise zu ändern, wie zum Beispiel ein Benutzerobjekt eindeutig identifiziert wird.": "If you are a database administrator or data engineer/scientist, you usually work directly on the database and explore the data as you need it. With composite primary keys, any user writing SQL directly must know the correct primary key of all tables involved (and the column order to get correct index optimizations). This added overhead not only complicates data exploration, report generation, etc., but can also lead to errors in older SQL if a composite primary key is suddenly changed. The old SQL is probably still valid and running fine, but suddenly returns incorrect results because the new field in the composite primary key is missing from the join. It is much easier here to have only one primary key. This makes it easier to find data and ensures that old SQL queries will still work correctly if you decide to change the way a user object is uniquely identified, for example.",
        "Überarbeitung": "Revision",
        "Sobald ein zusammengesetzter Primärschlüssel in einer Entität verwendet wird, kann ein Refactoring des Schlüssels zu einem erheblichen zusätzlichen Refactoring führen. Da eine Entität mit einem zusammengesetzten Primärschlüssel in der Regel kein einzelnes eindeutiges Feld hat, müssen alle Filter und Verknüpfungen alle Werte des zusammengesetzten Schlüssels enthalten. Das bedeutet in der Regel, dass der Code auf die Kenntnis des zusammengesetzten Primärschlüssels angewiesen ist, sodass alle Felder abgerufen werden müssen (z. B. für URLs wie /user/:key1/:key2). Sobald dieser Schlüssel geändert wird, müssen alle Stellen, an denen dieses Wissen explizit verwendet wird, wie URLs, benutzerdefinierte SQL-Abfragen und andere Stellen, umgeschrieben werden.": "Once a composite primary key is used in an entity, refactoring the key can result in significant additional refactoring. Because an entity with a composite primary key typically does not have a single unique field, all filters and links must contain all values of the composite key. This usually means that the code relies on knowing the composite primary key, so all fields must be retrieved (e.g., for URLs such as /user/:key1/:key2). Once this key is changed, all places where this knowledge is explicitly used, such as URLs, custom SQL queries, and other places, must be rewritten.",
        "Während ORMs in der Regel Joins automatisch erstellen, ohne die Werte manuell zu spezifizieren, können sie nicht automatisch das Refactoring für alle anderen Anwendungsfälle wie URL-Strukturen oder benutzerdefinierte SQL-Abfragen abdecken, und vor allem nicht für Stellen, an denen das ORM gar nicht verwendet wird, wie in Berichtssystemen und allen externen Systemen.": "While ORMs typically create joins automatically without manually specifying the values, they cannot automatically cover refactoring for all other use cases such as URL structures or custom SQL queries, and especially not for places where the ORM is not used at all, such as in reporting systems and all external systems.",
        "ORM-Komplexität": "ORM complexity",
        "Durch die Unterstützung von zusammengesetzten Primärschlüsseln steigt die Komplexität des Codes eines leistungsstarken ORM wie Deepkit ORM enorm an. Nicht nur, dass der Code und die Wartung komplexer und damit teurer werden, es werden auch mehr Edge-Cases von Benutzern auftreten, die behoben und gewartet werden müssen. Die Komplexität der Abfrageschicht, der Änderungserkennung, des Migrationssystems, der internen Verfolgung von Beziehungen usw. nimmt erheblich zu. Die Gesamtkosten, die mit dem Aufbau und der Unterstützung eines ORM mit zusammengesetzten Primärschlüsseln verbunden sind, sind alles in allem zu hoch und nicht zu rechtfertigen, weshalb Deepkit dies nicht unterstützt.": "With the support of composite primary keys, the complexity of the code of a powerful ORM like Deepkit ORM increases tremendously. Not only will the code and maintenance become more complex and therefore more expensive, but there will be more edge cases from users that need to be fixed and maintained. The complexity of the query layer, change detection, migration system, internal relationship tracking, etc. increases significantly. The overall cost associated with building and supporting an ORM with composite primary keys is too high, all things considered, and cannot be justified, which is why Deepkit does not support it.",
        "Vorteile": "Advantages",
        "Abgesehen davon haben zusammengesetzte Primärschlüssel auch Vorteile, wenn auch nur sehr oberflächliche. Durch die Verwendung einer möglichst geringen Anzahl von Indizes für jede Tabelle wird das Schreiben (Einfügen/Aktualisieren) von Daten effizienter, da weniger Indizes gepflegt werden müssen. Außerdem wird die Struktur des Modells etwas sauberer (da es normalerweise eine Spalte weniger hat). Der Unterschied zwischen einem sequentiell geordneten, automatisch inkrementierenden Primärschlüssel und einem nicht inkrementierenden Primärschlüssel ist heutzutage jedoch völlig vernachlässigbar, da Festplattenplatz billig ist und der Vorgang in der Regel nur ein \"Append-Only\"-Vorgang ist, der sehr schnell ist.": "That being said, composite primary keys also have advantages, albeit very superficial ones. Using as few indexes as possible for each table makes writing (inserting/updating) data more efficient, since fewer indexes need to be maintained. It also makes the structure of the model a bit cleaner (since it usually has one less column). However, the difference between a sequentially ordered, automatically incrementing primary key and a non-incrementing primary key is completely negligible these days, since disk space is cheap and the operation is usually an \"append-only\" operation, which is very fast.",
        "Es mag sicherlich ein paar Randfälle geben (und für ein paar sehr spezifische Datenbanksysteme), in denen es zunächst besser ist, mit zusammengesetzten Primärschlüsseln zu arbeiten. Aber selbst in diesen Systemen könnte es insgesamt (unter Berücksichtigung aller Kosten) sinnvoller sein, sie nicht zu verwenden und zu einer anderen Strategie zu wechseln.": "There may certainly be a few edge cases (and for a few very specific database systems) where it is initially better to work with composite primary keys. But even in these systems, it might make more sense overall (considering all the costs) not to use them and to switch to another strategy.",
        "Alternative": "Alternative",
        "Eine Alternative zu zusammengesetzten Primärschlüsseln ist die Verwendung eines einzigen automatisch inkrementierenden numerischen Primärschlüssels, in der Regel \"id\" genannt, und die Verlagerung des zusammengesetzten Primärschlüssels in einen eindeutigen Index mit mehreren Feldern. Je nach verwendetem Primärschlüssel (abhängig von der erwarteten Zeilenzahl) verwendet die \"id\" entweder 4 oder 8 Bytes pro Datensatz.": "An alternative to composite primary keys is to use a single automatically incrementing numeric primary key, usually called \"id\", and move the composite primary key to a unique index with multiple fields. Depending on the primary key used (depending on the expected number of rows), the \"id\" uses either 4 or 8 bytes per record.",
        "Durch den Einsatz dieser Strategie ist man nicht mehr gezwungen, über die oben beschriebenen Probleme nachzudenken und eine Lösung zu finden, was die Kosten für immer größer werdende Projekte enorm senkt.": "By using this strategy, you are no longer forced to think about the problems described above and find a solution, which greatly reduces the cost of ever-growing projects.",
        "Die Strategie bedeutet konkret, dass jede Entität ein \"id\"-Feld hat, normalerweise ganz am Anfang, und dieses Feld wird dann verwendet, um standardmäßig eindeutige Zeilen und in Joins zu identifizieren.": "The strategy specifically means that each entity has an \"id\" field, usually at the very beginning, and this field is then used to identify unique rows by default and in joins.",
        "Als Alternative zu einem zusammengesetzten Primärschlüssel würden Sie stattdessen einen eindeutigen Mehrfeldindex verwenden.": "As an alternative to a composite primary key, you would use a unique multi-field index instead.",
        "Deepkit ORM unterstützt automatisch inkrementelle Primärschlüssel, auch für MongoDB. Dies ist die bevorzugte Methode zur Identifizierung von Datensätzen in Ihrer Datenbank. Für MongoDB können Sie jedoch die ObjectId (`_id: MongoId & PrimaryKey = ''`) als einfachen Primärschlüssel verwenden. Eine Alternative zum numerischen, automatisch inkrementierenden Primärschlüssel ist eine UUID, die ebenso gut funktioniert (jedoch etwas andere Leistungsmerkmale aufweist, da die Indexierung teurer ist).": "Deepkit ORM automatically supports incremental primary keys, including for MongoDB. This is the preferred method for identifying records in your database. However, for MongoDB you can use the ObjectId (`_id: MongoId & PrimaryKey = ''`) as a simple primary key. An alternative to the numeric, auto-incrementing primary key is a UUID, which works just as well (but has slightly different performance characteristics, since indexing is more expensive).",
        "Zusammenfassung": "Summary",
        "Zusammengesetzte Primärschlüssel bedeuten im Wesentlichen, dass nach ihrer Einführung alle künftigen Änderungen und die praktische Verwendung mit wesentlich höheren Kosten verbunden sind. Während es zu Beginn wie eine saubere Architektur aussieht (weil man eine Spalte weniger hat), führt es zu erheblichen praktischen Kosten, sobald das Projekt tatsächlich entwickelt wird, und die Kosten steigen weiter, je größer das Projekt wird.": "Composite primary keys essentially mean that once they are in place, any future changes and practical use will come at a much higher cost. While it looks like a clean architecture at the beginning (because you have one less column), it leads to significant practical costs once the project is actually developed, and the costs continue to increase as the project gets larger.",
        "Betrachtet man die Asymmetrien zwischen Vor- und Nachteilen, so wird deutlich, dass zusammengesetzte Primärschlüssel in den meisten Fällen nicht zu rechtfertigen sind. Die Kosten sind viel größer als der Nutzen. Nicht nur für Sie als Benutzer, sondern auch für uns als Autor und Betreuer des ORM-Codes. Aus diesem Grund unterstützt Deepkit ORM keine zusammengesetzten Primärschlüssel.": "Looking at the asymmetries between advantages and disadvantages, it is clear that composite primary keys cannot be justified in most cases. The costs are much greater than the benefits. Not only for you as a user, but also for us as the author and maintainer of the ORM code. For this reason, Deepkit ORM does not support composite primary keys.",
        "Das Soft-Delete Plugin ermöglicht es, Datenbankeinträge versteckt zu halten, ohne sie tatsächlich zu löschen. Wenn ein Datensatz gelöscht wird, wird er nur als gelöscht markiert und nicht wirklich gelöscht. Alle Abfragen filtern automatisch nach dieser gelöschten Eigenschaft, sodass es sich für den Benutzer so anfühlt, als ob er tatsächlich gelöscht wäre.": "The Soft-Delete plugin allows to keep database records hidden without actually deleting them. When a record is deleted, it is only marked as deleted and not actually deleted. All queries automatically filter for this deleted property, so it feels to the user as if it is actually deleted.",
        "Um das Plugin zu verwenden, müssen Sie die SoftDelete-Klasse instanziieren und sie für jede Entität aktivieren.": "To use the plugin, you must instantiate the SoftDelete class and activate it for each entity.",
        "Löschen": "Delete",
        "Um Datensätze sanft zu löschen, verwenden Sie die üblichen Methoden: `deleteOne` oder `deleteMany` in einer Abfrage, oder Sie verwenden die Session, um sie zu löschen. Das Soft-Delete Plugin erledigt den Rest automatisch im Hintergrund.": "To soft-delete records, use the usual methods: `deleteOne` or `deleteMany` in a query, or use the session to delete them. The soft-delete plugin will do the rest automatically in the background.",
        "Wiederherstellen": "Restore",
        "Gelöschte Datensätze können mithilfe einer aufgehobenen Abfrage über `SoftDeleteQuery` wiederhergestellt werden. Es hat `restoreOne` und `restoreMany`.": "Deleted records can be restored using a cancelled query via `SoftDeleteQuery`. It has `restoreOne` and `restoreMany`.",
        "Die Session unterstützt auch die Wiederherstellung von Elementen.": "The session also supports element recovery.",
        "Hard Delete": "Hard Delete",
        "Um Datensätze hart zu löschen, verwenden Sie eine gehobene Abfrage über SoftDeleteQuery. Dies stellt im Wesentlichen das alte Verhalten ohne das Plugin für eine einzelne Abfrage wieder her.": "To hard delete records, use a lifted query via SoftDeleteQuery. This essentially restores the old behavior without the single query plugin.",
        "Query deleted.": "Query deleted.",
        "Bei einem \"lifted\" Query über `SoftDeleteQuery` können Sie auch gelöschte Datensätze einbeziehen.": "With a \"lifted\" query via `SoftDeleteQuery` you can also include deleted records.",
        "Deleted by": "Deleted by",
        "`deletedBy` kann über Abfrage und Sessions festgelegt werden.": "`deletedBy` can be set via query and sessions.",
        "Alle Arten von Providern werden in der Sektion xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] aufgelistet und erklärt.": "All types of providers are listed and explained in the xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] section.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel xref:runtime-types.adoc[Runtime Types].": "It should be mentioned here that Deepkit's DI container only works with Deepkit's runtime types. This means that any code that contains classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter xref:runtime-types.adoc[Runtime Types].",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion xref:dependency-injection.adoc#di-providers[Dependency Injection Providers], um zu erfahren, welche Werte übergeben werden können.": "The `injector` object in this case is the dependency injection container. The function `InjectorContext.forProviders` takes an array of providers. See the xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] section to learn what values can be passed.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln xref:validation.adoc[Validation] und xref:serialization.adoc[Serialization] genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Also, all serialization and validation types from the previous chapters xref:validation.adoc[Validation] and xref:serialization.adoc[Serialization] can be used to specify in great detail what type and content restrictions an option must have.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel xref:cli.adoc[CLI], xref:http.adoc[HTTP], oder": "Applications using the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See respectively the chapter xref:cli.adoc[CLI], xref:http.adoc[HTTP], or",
        "xref:rpc.adoc[RPC].": "xref:rpc.adoc[RPC].",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since Deepkit's event system is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Deepkit Framework basiert auf Runtime Types in Deepkit Type. Stelle sicher, dass `@deepkit/type` korrekt installiert ist. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Deepkit Framework is based on runtime types in Deepkit Type. Make sure that `@deepkit/type` is installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Stellen Sie sicher, dass alle Peer-Abhängigkeiten installiert sind. Standardmäßig werden sie von NPM 7+ automatisch installiert.": "Make sure that all peer dependencies are installed. By default, NPM 7+ installs them automatically.",
        "Um Ihre Anwendung zu kompilieren, benötigen wir den TypeScript-Compiler und empfehlen `ts-node`, um die App einfach auszuführen.": "To compile your application, we need the TypeScript compiler and recommend `ts-node` to easily run the app.",
        "Eine Alternative zur Verwendung von `ts-node` besteht darin, den Quellcode mit dem TypeScript-Compiler zu kompilieren und den JavaScript-Quellcode direkt auszuführen. Dies hat den Vorteil, dass sich die Ausführungsgeschwindigkeit für kurze Befehle drastisch erhöht. Allerdings wird dadurch auch zusätzlicher Workflow-Overhead erzeugt, indem der Compiler entweder manuell ausgeführt oder ein Watcher eingerichtet wird. Aus diesem Grund wird in dieser Dokumentation in allen Beispielen `ts-node` verwendet.": "An alternative to using `ts-node` is to compile the source code with the TypeScript compiler and execute the JavaScript source code directly. This has the advantage of dramatically increasing execution speed for short commands. However, it also creates additional workflow overhead by either manually running the compiler or setting up a watcher. For this reason, `ts-node` is used in all examples in this documentation.",
        "Erste Applikation": "First application",
        "Da das Deepkit Framework keine Konfigurationsdateien oder eine spezielle Ordnerstruktur verwendet, können Sie Ihr Projekt so strukturieren, wie Sie es wünschen. Die einzigen beiden Dateien, die Sie für den Start benötigen, sind die TypeScript-Datei app.ts und die TypeScript-Konfiguration tsconfig.json.": "Since the Deepkit framework does not use configuration files or a special folder structure, you can structure your project however you want. The only two files you need to get started are the TypeScript app.ts file and the TypeScript configuration tsconfig.json.",
        "Unser Ziel ist es, die folgenden Dateien in unserem Projektordner zu haben:": "Our goal is to have the following files in our project folder:",
        "In diesem Code sehen Sie, dass wir einen Testbefehl über die Klasse `TestCommand` definiert und eine neue Anwendung erstellt haben, die wir direkt mit `run()` ausführen. Durch das Ausführen dieses Skripts starten wir die App.": "In this code, you can see that we have defined a test command using the `TestCommand` class and created a new application that we run directly using `run()`. By running this script, we start the app.",
        "Mit dem Shebang in der ersten Zeile (`#!...`) können wir unser Skript mit dem folgenden Befehl ausführbar machen.": "With the shebang in the first line (`#!...`) we can make our script executable with the following command.",
        "Und dann ausführen:": "And then execute:",
        "Um nun unseren Testbefehl auszuführen, führen wir folgenden Befehl aus.": "Now, to execute our test command, we run the following command.",
        "In Deepkit Framework geschieht nun alles über diese `app.ts`. Sie können die Datei beliebig umbennen oder weitere anlegen. Eigene CLI commands, HTTP/RPC server, Migration commands, usw werden alle über diesen Einstiegspunkt gestartet.": "In Deepkit Framework everything is now done via this `app.ts`. You can rename the file as you like or create more. Custom CLI commands, HTTP/RPC server, migration commands, etc are all started from this entry point.",
        "Um den HTTP/RPC-Server zu starten, führen Sie folgendes aus:": "To start the HTTP/RPC server, do the following:",
        "Um Anfragen bedienen zu können, lesen Sie bitte das Kapitel xref:http.adoc[HTTP] oder xref:rpc.adoc[RPC]. Im Kapitel xref:cli.adoc[CLI] kann mehr über CLI commands erfahren werden.": "To serve requests please read chapter xref:http.adoc[HTTP] or xref:rpc.adoc[RPC]. In chapter xref:cli.adoc[CLI] you can learn more about CLI commands.",
        "App": "App",
        "Über das `App`-Objekt startet wie Applikation.": "Via the `App` object starts like application.",
        "Die `run()`-Methode list dabei die Argumente aus und führt den entsprechenden CLI-Controller aus. Da `FrameworkModule` eigene CLI-Controller bereitstellt, die zum Beispiel für das Starten des HTTP-Servers verantwortlich sind, können diese darüber aufgerufen werden.": "The `run()` method lists the arguments and executes the corresponding CLI controller. Since `FrameworkModule` provides its own CLI controllers, which are responsible for starting the HTTP server, for example, these can be called via it.",
        "Über das `App`-Objekt kann auch der Dependency Injection Container angesprochen werden, ohne dass ein CLI-Controller ausgeführt wird.": "The `App` object can also be used to access the Dependency Injection container without running a CLI controller.",
        "Deepkit Framework ist hochgradig modular und ermöglicht es Ihnen, Ihre Anwendung in mehrere praktische Module aufzuteilen. Jedes Modul hat seine eigene Dependency Injektion Sub-Container, Konfiguration, Befehle und vieles mehr. Im Kapitel \"Erste Applikation\" haben Sie bereits ein Modul erstellt - das Root-Modul. `new App` benötigt fast die gleichen Argumente wie ein Modul, denn es erstellt das Root-Modul im Hintergrund für Sie automatisch.": "Deepkit framework is highly modular and allows you to split your application into several handy modules. Each module has its own dependency injection sub-container, configuration, commands and much more. In the chapter \"First application\" you have already created one module - the root module. `new App` takes almost the same arguments as a module, because it creates the root module for you automatically in the background.",
        "Sie können dieses Kapitel überspringen, wenn Sie nicht vorhaben, Ihre Anwendung in Untermodule aufzuteilen, oder wenn Sie nicht vorhaben, ein Modul als Paket für andere zur Verfügung zu stellen.": "You can skip this chapter if you do not plan to split your application into submodules, or if you do not plan to make a module available as a package to others.",
        "Ein Modul ist eine einfache Klasse:": "A module is a simple class:",
        "Es hat zu diesem Zeitpunkt im Grunde keine Funktionalität, da seine Moduldefinition ein leeres Objekt ist und es keine Methoden hat, aber dies demonstriert die Beziehung zwischen Modulen und Ihrer Anwendung (Ihrem Stammmodul). Dieses Modul MyModule kann dann in Ihrer Anwendung oder in anderen Modulen importiert werden.": "It basically has no functionality at this point because its module definition is an empty object and it has no methods, but this demonstrates the relationship between modules and your application (your root module). This MyModule module can then be imported into your application or into other modules.",
        "Sie können nun diesem Modul Features hinzufügen, wie Sie es mit `App` tun würden. Die Argumente sind die gleichen, nur dass Importe in einer Moduldefinition nicht verfügbar sind. Fügen Sie HTTP/RPC/CLI-Controller, Dienste, eine Konfiguration, Event-Listener sowie verschiedene Modul-Hooks hinzu, um Module dynamischer zu gestalten.": "You can now add features to this module as you would with `App`. The arguments are the same, except that imports are not available in a module definition. Add HTTP/RPC/CLI controllers, services, a configuration, event listeners, and various module hooks to make modules more dynamic.",
        "Controllers": "Controllers",
        "Module können Controller definieren, die von anderen Modulen verarbeitet werden. Wenn Sie zum Beispiel einen Controller mit Dekoratoren aus dem `@deepkit/http`-Paket hinzufügen, wird sein Modul `HttpModule` dies aufgreifen und die gefundenen Routen in seinem Router registrieren. Ein einzelner Controller kann mehrere solcher Dekoratoren enthalten. Es liegt an dem Modulautor, der Ihnen diese Dekoratoren gibt, wie er die Controller verarbeitet.": "Modules can define controllers that are processed by other modules. For example, if you add a controller with decorators from the `@deepkit/http` package, its `HttpModule` module will pick this up and register the found routes in its router. A single controller may contain several such decorators. It is up to the module author who gives you these decorators how he processes the controllers.",
        "In Deepkit gibt es drei Pakete, die solche Controller verarbeitet: HTTP, RPC, und CLI. Siehe jeweils deren Kapitel, um mehr zu erfahren. Nachfolgend ist ein Beispiel eines HTTP-Controllers:": "In Deepkit there are three packages that handles such controllers: HTTP, RPC, and CLI. See their respective chapters to learn more. Below is an example of an HTTP controller:",
        "Provider": "Provider",
        "Wenn Sie einen Provider im `providers`-Bereich Ihrer Anwendung definieren, ist dieser in Ihrer gesamten Anwendung zugänglich. Bei Modulen hingegen werden diese Provider automatisch in den Subcontainer für die Injektion von Abhängigkeiten dieses Moduls gekapselt. Sie müssen jeden Provider manuell exportieren, um ihn für ein anderes Modul bzw. ihrer Anwendung verfügbar zu machen.": "When you define a provider in the `providers` section of your application, it is accessible throughout your application. For modules, however, these providers are automatically encapsulated in that module's dependency injection subcontainer. You must manually export each provider to make it available to another module or your application.",
        "Um mehr darüber zu erfahren, wie Provider funktionieren, lesen Sie bitte das Kapitel xref:dependency-injection.adoc[Dependency Injection].": "To learn more about how providers work, please refer to the xref:dependency-injection.adoc[Dependency Injection] chapter.",
        "Wenn ein Benutzer dieses Modul importiert, hat er keinen Zugriff auf `HelloWorldService`, da dieser im Subdependency-Injection-Container von `MyModule` gekapselt ist.": "When a user imports this module, he has no access to `HelloWorldService` because it is encapsulated in the subdependency injection container of `MyModule`.",
        "Exports": "Exports",
        "Um Provider im Modul des Importeurs verfügbar zu machen, können Sie den Token des Providers in `exports` aufnehmen. Dadurch wird der Provider im Wesentlichen eine Ebene nach oben in den Dependency-Injection-Container des übergeordneten Moduls - des Importeurs - verschoben.": "To make providers available in the importer's module, you can include the provider's token in `exports`. This essentially moves the provider up one level into the dependency injection container of the parent module - the importer.",
        "Wenn Sie andere Provider wie `FactoryProvider`, `UseClassProvider` usw. haben, sollten Sie trotzdem nur den Klassentyp in den Exporten verwenden.": "If you have other providers like `FactoryProvider`, `UseClassProvider` etc., you should still use only the class type in the exports.",
        "We can now import that module and use its exported service in our application code.": "We can now import that module and use its exported service in our application code.",
        "Lesen Sie das Kapitel xref:dependency-injection.adoc[Dependency Injection] um mehr darüber zu erfahren.": "Read the xref:dependency-injection.adoc[Dependency Injection] chapter to learn more.",
        "Im Deepkit Framework können Module und Ihre Anwendung über Konfigurationsoptionen verfügen. Eine Konfiguration kann z.B. aus Datenbank-URLs, Passwörtern, IPs usw. bestehen. Services, HTTP/RPC/CLI Controller sowie Template Funktionen können diese Konfigurationsoptionen über Dependency Injection auslesen.": "In Deepkit framework, modules and your application can have configuration options. For example, a configuration can consist of database URLs, passwords, IPs, and so on. Services, HTTP/RPC/CLI controllers, and template functions can read these configuration options via dependency injection.",
        "Eine Konfiguration kann durch die Definition einer Klasse mit Eigenschaften definiert werden. Dies ist ein typsicherer Weg, um eine Konfiguration für Ihre gesamte Anwendung zu definieren, und ihre Werte werden automatisch serialisiert und validiert.": "A configuration can be defined by defining a class with properties. This is a type-safe way to define a configuration for your entire application, and its values are automatically serialized and validated.",
        "Beispiel": "Example",
        "Konfigurationsklasse": "Configuration class",
        "Die Werte für die Konfigurationsoptionen können entweder im Konstruktor des Moduls, mit der Methode `.configure()` oder über Konfigurationslader (z.B. Umgebungsvariablenlader) bereitgestellt werden.": "The values for the configuration options can be provided either in the constructor of the module, with the `.configure()` method or via configuration loaders (e.g. environment variable loaders).",
        "Um die Konfigurationsoptionen eines importierten Moduls dynamisch zu ändern, können Sie den `process` Hook verwenden. Dies ist ein guter Ort, um entweder Konfigurationsoptionen umzuleiten oder ein importiertes Modul abhängig von der aktuellen Modulkonfiguration oder anderen Modulinstanzinformationen einzurichten.": "To dynamically change the configuration options of an imported module, you can use the `process` hook. This is a good place to either redirect configuration options or set up an imported module depending on the current module configuration or other module instance information.",
        "Auf der Anwendungsebene funktioniert es etwas anders:": "At the application level, it works a little differently:",
        "Wenn das Root-Anwendungsmodul aus einem regulären Modul erstellt wird, funktioniert es ähnlich wie reguläre Module.": "When the root application module is created from a regular module, it works similarly to regular modules.",
        "Konfigurationsoptionen Auslesen": "Configuration options Readout",
        "Um eine Konfigurationsoption in einem Dienst zu verwenden, können Sie die normale Dependency Injection verwenden. Es ist möglich, entweder das gesamte Konfigurationsobjekt, einen einzelnen Wert oder einen Teil der Konfiguration zu injizieren.": "To use a configuration option in a service, you can use normal dependency injection. It is possible to inject either the entire configuration object, a single value, or a portion of the configuration.",
        "Partial": "Partial",
        "Um nur einen Teilbereich der Konfigurationswerte zu injizieren, verwenden Sie den Typ `Pick`.": "To inject only a subset of the configuration values, use the `pick` type.",
        "Single value": "Single value",
        "Um nur einen einzigen Wert zu injizieren, verwenden Sie den Indexzugriffsoperator.": "To inject only a single value, use the index access operator.",
        "All": "All",
        "To inject all config values, use the class as dependency.": "To inject all config values, use the class as dependency.",
        "Die Konfigurationswerte Ihrer Anwendung und aller Module können im Debugger angezeigt werden. Aktivieren Sie die Debug-Option im `FrameworkModul` und öffnen Sie `http://localhost:8080/_debug/configuration`.": "The configuration values of your application and all modules can be displayed in the debugger. Activate the debug option in the `FrameworkModule` and open `http://localhost:8080/_debug/configuration`.",
        "Sie können auch `ts-node app.ts app:config` verwenden, um alle verfügbaren Konfigurationsoptionen, den aktiven Wert, ihren Standardwert, die Beschreibung und den Datentyp anzuzeigen.": "You can also use `ts-node app.ts app:config` to display all available configuration options, the active value, their default value, description and data type.",
        "Konfigurationswerte setzen": "Set configuration values",
        "Standardmäßig werden keine Werte überschrieben, es werden also Standardwerte verwendet. Es gibt mehrere Möglichkeiten, Konfigurationswerte zu setzen.": "By default, no values are overwritten, so default values are used. There are several ways to set configuration values.",
        "Umgebungsvariablen für jede Option": "Environment variables for each option",
        "Umgebungsvariable über JSON": "Environment variable via JSON",
        "dotenv-Dateien": "dotenv files",
        "Sie können mehrere Methoden zum Laden der Konfiguration gleichzeitig verwenden. Die Reihenfolge, in der sie aufgerufen werden, ist dabei wichtig.": "You can use several methods to load the configuration at the same time. The order in which they are called is important.",
        "Environment variables": "Environment variables",
        "Um die Einstellung jeder Konfigurationsoption über eine eigene Umgebungsvariable zu ermöglichen, verwenden Sie `loadConfigFromEnv`. Das Standardpräfix ist `APP_`, aber Sie können es ändern. Es lädt auch automatisch `.env`-Dateien. Standardmäßig wird eine Benennungsstrategie mit Großbuchstaben verwendet, aber auch das können Sie ändern.": "To allow setting each configuration option via its own environment variable, use `loadConfigFromEnv`. The default prefix is `APP_`, but you can change it. It also automatically loads `.env` files. By default it uses an uppercase naming strategy, but you can change that too.",
        "Für Konfigurationsoptionen wie oben `pageTitle`, können Sie `APP_PAGE_TITLE=\"Anderer Titel\"` verwenden, um den Wert zu verändern.": "For configuration options like `pageTitle` above, you can use `APP_PAGE_TITLE=\"Other Title\"` to change the value.",
        "JSON environment variable": "JSON environment variable",
        "Um mehrere Konfigurationsoptionen über eine einzige Umgebungsvariable zu ändern, verwenden Sie `loadConfigFromEnvVariable`. Das erste Argument ist der Name der Umgebungsvariablen.": "To change multiple configuration options via a single environment variable, use `loadConfigFromEnvVariable`. The first argument is the name of the environment variable.",
        "DotEnv Dateien": "DotEnv files",
        "Um mehrere Konfigurationsoptionen über eine dotenv-Datei zu ändern, verwenden Sie `loadConfigFromEnv`. Das erste Argument ist entweder ein Pfad zu einer dotenv (relativ zu `cwd`) oder mehrere Pfade. Wenn es ein Array ist, wird jeder Pfad ausprobiert, bis eine vorhandene Datei gefunden wird.": "To change multiple configuration options via a dotenv file, use `loadConfigFromEnv`. The first argument is either a path to a dotenv (relative to `cwd`) or multiple paths. If it is an array, each path is tried until an existing file is found.",
        "Module Configuration": "Module Configuration",
        "Jedes importierte Modul kann einen Modulnamen haben. Dieser Name wird für die oben verwendeten Konfigurationspfade verwendet.": "Each imported module can have a module name. This name is used for the configuration paths used above.",
        "Für die Konfiguration von Umgebungsvariablen lautet der Pfad für die `FrameworkModule`-Option port beispielsweise `FRAMEWORK_PORT`. Alle Namen werden standardmäßig in Großbuchstaben geschrieben. Wenn ein Präfix von `APP_` verwendet wird, kann der Port über folgendes geändert werden:": "For example, for configuring environment variables, the path for the `FrameworkModule` option port is `FRAMEWORK_PORT`. All names are written in uppercase by default. If a prefix of `APP_` is used, the port can be changed via the following:",
        "In Dotenv-Dateien wäre es auch `APP_FRAMEWORK_PORT=9999`.": "In dotenv files it would also be `APP_FRAMEWORK_PORT=9999`.",
        "In JSON-Umgebungsvariablen über `loadConfigFromEnvVariable('APP_CONFIG')` hingegen ist es die Struktur der eigentlichen Konfigurationsklasse. `framework` wird zu einem Objekt.": "In JSON environment variables via `loadConfigFromEnvVariable('APP_CONFIG')` on the other hand, it is the structure of the actual configuration class. `framework` becomes an object.",
        "Dies funktioniert für alle Module gleich. Für die Konfigurationsoption Ihrer Anwendung (`new App`) ist kein Modulpräfix erforderlich.": "This works the same for all modules. No module prefix is required for your application configuration option (`new App`).",
        "Das FrameworkModule bietet eine Möglichkeit, statische Dateien wie Bilder, PDFs, Binärdateien usw. über HTTP bereitzustellen. Mit der Konfigurationsoption `publicDir` können Sie angeben, welcher Ordner als Standard-Einstiegspunkt für Anfragen verwendet werden soll, die nicht zu einer HTTP-Controller-Route führen. Standardmäßig ist dieses Verhalten deaktiviert (leerer Wert).": "The FrameworkModule provides a way to serve static files such as images, PDFs, binaries, etc. over HTTP. The `publicDir` configuration option lets you specify which folder to use as the default entry point for requests that do not lead to an HTTP controller route. By default, this behavior is disabled (empty value).",
        "Um die Bereitstellung öffentlicher Dateien zu aktivieren, setzen Sie `publicDir` auf einen Ordner Ihrer Wahl. Normalerweise würden Sie einen Namen wie `publicDir` wählen, um die Dinge offensichtlich zu machen.": "To enable the provision of public files, set `publicDir` to a folder of your choice. Normally you would choose a name like `publicDir` to make things obvious.",
        "Um die Option `publicDir` zu ändern, können Sie das erste Argument von `FrameworkModule` ändern.": "To change the `publicDir` option, you can change the first argument of `FrameworkModule`.",
        "Alle Dateien innerhalb dieses konfigurierten Ordners sind nun über HTTP zugänglich. Wenn Sie  beispielsweise `http://localhost:8080/logo.jpg` öffnen, sehen Sie das Bild `logo.jpg` im Verzeichnis `publicDir`.": "All files within this configured folder are now accessible via HTTP. For example, when you open `http://localhost:8080/logo.jpg`, you see the `logo.jpg` image in the `publicDir` directory.",
        "Deepkit verfügt über eine eigene leistungsstarke Datenbankabstraktionsbibliothek namens Deepkit ORM. Es handelt sich um eine ORM-Bibliothek (Object-Relational Mapping), die die Arbeit mit SQL-Datenbanken und MongoDB erleichtert.": "Deepkit has its own powerful database abstraction library called Deepkit ORM. It is an Object-Relational Mapping (ORM) library that facilitates work with SQL databases and MongoDB.",
        "Obwohl Sie jede beliebige Datenbankbibliothek verwenden können, empfehlen wir Deepkit ORM, da es die schnellste TypeScript-Datenbankabstraktionsbibliothek ist, die perfekt in das Deepkit-Framework integriert ist und viele Funktionen hat, die Ihren Workflow und Ihre Effizienz verbessern.": "Although you can use any database library, we recommend Deepkit ORM as it is the fastest TypeScript database abstraction library that is perfectly integrated with the Deepkit framework and has many features that will improve your workflow and efficiency.",
        "Um alle Informationen über Deepkit ORM zu erhalten, lesen Sie das Kapitel xref:database.adoc[Database].": "To get all the information about Deepkit ORM, see the xref:database.adoc[Database] chapter.",
        "Database Klassen": "Database classes",
        "Die einfachste Art, das `Database`-Objekt von Deepkit ORM innerhalb der Applikation zu verwenden, ist das Registrieren einer Klasse, die davon ableitet.": "The simplest way to use the `Database` object of Deepkit ORM within the application is to register a class that derives from it.",
        "Erstellen Sie eine neue Klasse und geben Sie in ihrem Konstruktor den Adapter mit seinen Parametern an und fügen Sie dem zweiten Parameter alle Entitäten/Modelle hinzu, die mit dieser Datenbank verbunden sein sollen.": "Create a new class and in its constructor specify the adapter with its parameters and add to the second parameter all entities/models that should be connected to this database.",
        "Sie können nun diese Datenbankklasse als Provider registrieren. Wir aktivieren auch `migrateOnStartup`, das alle Tabellen in Ihrer Datenbank automatisch beim Bootstrap erstellt. Dies ist ideal für Rapid Prototyping, wird aber für ein ernsthaftes Projekt oder eine Produktionseinrichtung nicht empfohlen. Hier sollten dann normale Datenbank Migrationen verwendet werden.": "You can now register this database class as a provider. We also enable `migrateOnStartup` which will automatically create all tables in your database at bootstrap. This is ideal for rapid prototyping, but is not recommended for a serious project or production setup. Normal database migrations should then be used here.",
        "Außerdem aktivieren wir `debug`, was uns erlaubt, den Debugger zu öffnen, wenn der Server der Anwendung gestartet wird, und Ihre Datenbankmodelle direkt in seinem integrierten ORM-Browser zu verwalten.": "We also enable `debug`, which allows us to open the debugger when the application's server is started and manage your database models directly in its built-in ORM browser.",
        "Sie können nun überall auf `SQLiteDatabase` zugreifen, indem Sie Dependency Injection verwenden:": "You can now access `SQLiteDatabase` anywhere using Dependency Injection:",
        "Mehr Datenbanken": "More databases",
        "Sie können so viele Datenbankklassen hinzufügen, wie Sie möchten, und sie so benennen, wie Sie möchten. Achten Sie darauf, den Namen jeder Datenbank zu ändern, damit sie bei der Verwendung des ORM-Browsers nicht mit anderen in Konflikt gerät.": "You can add as many database classes as you like and name them as you like. Be sure to change the name of each database so that it doesn't conflict with others when you use the ORM browser.",
        "Daten Verwalten": "Manage data",
        "Sie haben jetzt alles eingerichtet, um Ihre Datenbankdaten mit dem Deepkit ORM Browser zu verwalten. Um den ORM-Browser zu öffnen und den Inhalt zu verwalten, schreiben Sie alle Schritte von oben in die Datei `app.ts` und starten den Server.": "You now have everything set up to manage your database data with the Deepkit ORM Browser. To open the ORM Browser and manage the content, write all the steps from above in the `app.ts` file and start the server.",
        "You can now open http://localhost:8080/_debug/database/default.": "You can now open http://localhost:8080/_debug/database/default.",
        "Sie können das ER-Diagramm sehen. Im Moment ist nur eine Entität verfügbar. Wenn Sie weitere mit Beziehungen hinzufügen, sehen Sie alle Informationen auf einen Blick.": "You can see the ER diagram. At the moment only one entity is available. If you add more with relationships, you will see all the information at a glance.",
        "Wenn Sie in der linken Seitenleiste auf `User` klicken, können Sie dessen Inhalt verwalten. Klicken Sie auf das `+`-Symbol, und ändern Sie den Titel des neuen Datensatzes. Nachdem Sie die erforderlichen Werte (wie den Benutzernamen) geändert haben, klicken Sie auf \"Bestätigen\". Dadurch werden alle Änderungen an die Datenbank übertragen und bleiben dauerhaft bestehen. Die Autoinkrement-ID wird automatisch zugewiesen.": "If you click on `User` in the left sidebar, you can manage its content. Click the `+` icon and change the title of the new record. After you have changed the required values (such as the user name), click `Confirm`. This will commit all changes to the database and make them permanent. The auto increment ID will be assigned automatically.",
        "Mehr Lernen": "Learn more",
        "Um mehr über die Funktionsweise von `SQLiteDatabase` zu erfahren, lesen Sie bitte das Kapitel xref:database.adoc[Database] und seine Unterkapitel, wie z.B. die Abfrage von Daten, die Manipulation von Daten über Sessions, die Definition von Relationen und vieles mehr.": "To learn more about how `SQLiteDatabase` works, please read the chapter xref:database.adoc[Database] and its subchapters, such as querying data, manipulating data via sessions, defining relations and much more.",
        "Bitte beachten Sie, dass sich die Kapitel dort auf die eigenständige Bibliothek `@deepkit/orm` beziehen und keine Dokumentation über den Teil des Deepkit Frameworks enthalten, den Sie oben in diesem Kapitel gelesen haben. In der Standalone-Bibliothek instanziieren Sie Ihre Datenbankklasse manuell, z. B. über `new SQLiteDatabase()`. In Ihrer Deepkit-Framework-Anwendung wird dies jedoch automatisch mithilfe des Dependency Injection Containers durchgeführt.": "Please note that the chapters there refer to the standalone library `@deepkit/orm` and do not include documentation about the part of the Deepkit framework you read above in this chapter. In the standalone library, you instantiate your database class manually, for example via `new SQLiteDatabase()`. However, in your Deepkit framework application, this is done automatically using the Dependency Injection container.",
        "Deepkit Logger ist eine eigenständige Bibliothek mit einer primären Klasse Logger, die Sie zur Protokollierung von Informationen verwenden können. Diese Klasse wird automatisch im Dependency Injection Container Ihrer Deepkit Framework-Anwendung bereitgestellt.": "Deepkit Logger is a standalone library with a primary Logger class that you can use to log information. This class is automatically deployed in the Dependency Injection container of your Deepkit Framework application.",
        "Die Klasse `Logger` verfügt über mehrere Methoden, die sich jeweils wie `console.log` verhalten.": "The `Logger` class has several methods, each of which behaves like `console.log`.",
        "Standardmäßig hat ein Logger den Level \"info\", d.h. er verarbeitet nur Info-Meldungen und mehr (d.h. log, warning, error, aber nicht debug). Um den Log-Level zu ändern, rufen Sie zum Beispiel `logger.level = 5` auf.": "By default, a logger has `info` level, i.e. it processes only info messages and more (i.e. log, warning, error, but not debug). To change the log level, call for example `logger.level = 5`.",
        "Benutzen in der Anwendung": "Use in the application",
        "Um den Logger in Ihrer Deepkit-Framework-Anwendung zu verwenden, können Sie einfach `Logger` in Ihre Services oder Controller injizieren.": "To use the logger in your Deepkit framework application, you can simply inject `Logger` into your services or controllers.",
        "Farben": "Colors",
        "Der Logger unterstützt farbige Protokollmeldungen. Sie können Farben bereitstellen, indem Sie XML-Tags verwenden, die den Text umgeben, der in Farbe erscheinen soll.": "The logger supports colored log messages. You can provide colors by using XML tags that surround the text you want to appear in color.",
        "Bei Transportern, die keine Farben unterstützen, werden die Farbinformationen automatisch entfernt. Im Standardtransporter (`ConsoleTransport`) wird die Farbe angezeigt. Die folgenden Farben sind verfügbar: `black`, `red`, `green`, `blue`, `cyan`, `magenta`, `white` und `grey`/`gray`.": "For transporters that do not support colors, the color information is automatically removed. In the default transporter (`ConsoleTransport`) the color is displayed. The following colors are available: `black`, `red`, `green`, `blue`, `cyan`, `magenta`, `white` and `grey`/`gray`.",
        "Transporter": "Transporter",
        "Sie können einen einzelnen oder mehrere Transporter konfigurieren. In einer Deepkit Framework-Anwendung wird der Transporter `ConsoleTransport` automatisch konfiguriert. Um zusätzliche Transporter zu konfigurieren, können Sie xref:dependency-injection.adoc#di-setup-calls[Setup Calls] verwenden:": "You can configure a single transporter or multiple transporters. In a Deepkit Framework application, the `ConsoleTransport` transporter is configured automatically. To configure additional transporters, you can use xref:dependency-injection.adoc#di-setup-calls[Setup Calls]:",
        "Um alle Transporter durch eine neue Gruppe von Transportern zu ersetzen, verwenden Sie `setTransport`:": "To replace all transporters with a new set of transporters, use `setTransport`:",
        "Formatter": "Formatter",
        "Mit Formatierern können Sie das Nachrichtenformat ändern, z. B. den Zeitstempel hinzufügen. Wenn eine Anwendung über `server:start` gestartet wird, wird automatisch ein `DefaultFormatter` hinzugefügt (der Zeitstempel, Bereich und Protokollstufe hinzufügt), wenn kein anderer Formatter vorhanden ist.": "With formatters you can change the message format, e.g. add the timestamp. When an application is started via `server:start`, a `DefaultFormatter` is automatically added (which adds timestamp, range and log level) if no other formatter is available.",
        "Scoped Logger": "Scoped logger",
        "Scoped Logger fügen jedem Protokolleintrag einen beliebigen Bereichsnamen hinzu, der hilfreich sein kann, um festzustellen, aus welchem Teilbereich Ihrer Anwendung der Protokolleintrag stammt.": "Scoped loggers add an arbitrary area name to each log entry, which can be helpful in determining which subarea of your application the log entry originated from.",
        "JSON Transporter": "JSON Transporter",
        "Um die Ausgabe in JSON-Protokolle zu ändern, können Sie den mitgelieferten `JSONTransport` verwenden.": "To change the output to JSON protocols, you can use the supplied `JSONTransport`.",
        "Context Data": "Context Data",
        "Um einem Protokolleintrag kontextbezogene Daten hinzuzufügen, fügen Sie ein einfaches Objektliteral als letztes Argument hinzu. Nur Protokollaufrufe mit mindestens zwei Argumenten können kontextbezogene Daten enthalten.": "To add contextual data to a log entry, add a simple object literal as the last argument. Only log calls with at least two arguments can contain contextual data.",
        "Deepkit Framework kommt mit diversen Event-Tokens, auf die Event-Listener registriert werden können.": "Deepkit framework comes with various event tokens on which event listeners can be registered.",
        "Siehe das Kapitel xref:events.adoc[Events], um mehr darüber zu erfahren, wie Events funktionieren.": "See the xref:events.adoc[Events] chapter to learn more about how events work.",
        "Dispatch Events": "Dispatch Events",
        "Events werden über die Klasse `EventDispatcher` gesendet. In einer Deepkit Framework Applikation kann dieser über Dependency Injection bereitgestellt werden.": "Events are sent via the `EventDispatcher` class. In a Deepkit Framework application, this can be provided via dependency injection.",
        "Event Listener": "Event Listener",
        "Es gibt zwei Arten auf Events zu reagieren. Entweder über Controller Klassen oder reguläre Funktionen.": "There are two ways to react to events. Either via controller classes or regular functions.",
        "Beide werden in der App oder in Modulen unter `listeners` registriert.": "Both are registered in the app or in modules under `listeners`.",
        "_Controller Listener_": "_Controller Listener_",
        "_Functional Listener_": "_Functional Listener_",
        "Framework Events": "Framework Events",
        "Deepkit Framework selbst hat mehrere Ereignisse aus dem Anwendungsserver, auf die Sie hören können.": "Deepkit Framework itself has several events from the application server that you can listen for.",
        "In diesem Kapitel erfahren Sie, wie Sie Ihre Anwendung in JavaScript kompilieren, für Ihre Produktionsumgebung konfigurieren und über Docker bereitstellen können.": "In this chapter, you will learn how to compile your application in JavaScript, configure it for your production environment, and deploy it using Docker.",
        "TypeScript kompilieren": "Compile TypeScript",
        "Nehmen wir an, Sie haben eine Anwendung wie diese in einer Datei `app.ts`:": "Suppose you have an application like this in an `app.ts` file:",
        "Wenn Sie `ts-node app.ts server:start` verwenden, sehen Sie, dass alles korrekt funktioniert. In einer Produktionsumgebung würden Sie den Server in der Regel nicht mit `ts-node` starten. Sie würden ihn in JavaScript kompilieren und dann den Node verwenden. Dazu müssen Sie eine korrekte `tsconfig.json` mit den richtigen Konfigurationsoptionen haben. In der Sektion \"Erste Applikation\" ist Ihre `tsconfig.json` so konfiguriert, dass sie JavaScript im Ordner `./dist` ausgibt. Wir gehen davon aus, dass Sie das auch so konfiguriert haben.": "If you use `ts-node app.ts server:start`, you will see that everything works correctly. In a production environment, you would not typically start the server with `ts-node`. You would compile it into JavaScript and then use the node. To do this, you must have a correct `tsconfig.json` with the correct configuration options. In the \"First Application\" section, your `tsconfig.json` is configured to output JavaScript to the `./dist` folder. We assume that you have configured it that way as well.",
        "Wenn alle Compiler-Einstellungen korrekt sind und Ihr `outDir` auf einen Ordner wie z.B. `dist` zeigt, dann werden, sobald Sie den Befehl `tsc` in Ihrem Projekt ausführen, alle Ihre verlinkten Dateien in den Dateien in der `tsconfig.json` zu JavaScript kompiliert. Es reicht, wenn Sie Ihre Einstiegsdateien in dieser Liste angeben. Alle importierten Dateien werden ebenfalls automatisch kompiliert und müssen nicht explizit in die `tsconfig.json` eingefügt werden. `tsc` ist Teil von Typescript, wenn Sie `npm install typescript` installieren.": "If all compiler settings are correct and your `outDir` points to a folder like `dist`, then as soon as you run the `tsc` command in your project, all your linked files in the files in the `tsconfig.json` will be compiled to JavaScript. It is enough to specify your entry files in this list. All imported files are also compiled automatically and do not need to be explicitly added to `tsconfig.json`. `tsc` is part of Typescript when you install `npm install typescript`.",
        "Der TypeScript-Compiler gibt nichts aus, wenn er erfolgreich war. Sie können die Ausgabe von `dist` jetzt überprüfen.": "The TypeScript compiler does not output anything if it was successful. You can now check the output of `dist`.",
        "Sie sehen, dass es nur eine Datei gibt. Sie können sie über `node dist/app.js` ausführen und erhalten die gleiche Funktionalität wie mit `ts-node app.ts`.": "You can see that there is only one file. You can run it from `node dist/app.js` and get the same functionality as with `ts-node app.ts`.",
        "Für ein Deployment ist es wichtig, dass die TypeScript-Dateien korrekt kompiliert werden und alles direkt über Node funktioniert. Sie könnten nun einfach Ihren `dist`-Ordner einschließlich Ihrer `node_modules` verschieben und `node dist/app.js server:start` ausführen und Ihre App ist erfolgreich deployed. Sie würden jedoch andere Lösungen wie Docker verwenden, um Ihre Anwendung korrekt zu verpacken.": "For a deployment, it is important that the TypeScript files are compiled correctly and everything works directly through Node. You could now simply move your `dist` folder including your `node_modules` and run `node dist/app.js server:start` and your app is successfully deployed. However, you would use other solutions like Docker to package your app correctly.",
        "In einer Produktionsumgebung würden Sie den Server nicht an `localhost` binden, sondern höchstwahrscheinlich an alle Geräte über `0.0.0.0`. Wenn Sie nicht hinter einem Reverse-Proxy stehen, würden Sie auch den Port auf 80 einstellen. Um diese beiden Einstellungen zu konfigurieren, müssen Sie das `FrameworkModule` anpassen. Die beiden Optionen, die uns interessieren, sind `host` und `port`. Damit sie von außen über Umgebungsvariablen oder über .dotenv-Dateien konfiguriert werden können, müssen wir dies zunächst zulassen. Glücklicherweise hat unser obiger Code dies bereits mit der Methode `loadConfigFromEnv()` getan.": "In a production environment, you would not bind the server to `localhost`, but most likely to all devices via `0.0.0.0`. If you are not behind a reverse proxy, you would also set the port to 80. To configure these two settings, you need to customize the `FrameworkModule`. The two options we are interested in are `host` and `port`. In order for them to be configured externally via environment variables or via .dotenv files, we must first allow this. Fortunately, our code above has already done this with the `loadConfigFromEnv()` method.",
        "Bitte lesen Sie das Kapitel xref:framework.adoc#confiruration[Konfiguration], um mehr darüber zu erfahren, wie Sie die Konfigurationsoptionen der Anwendung einstellen können.": "Please refer to the xref:framework.adoc#confiruration[configuration] chapter to learn more about how to set the application configuration options.",
        "Um zu sehen, welche Konfigurationsoptionen verfügbar sind und welchen Wert sie haben, können Sie den Befehl `ts-node app.ts app:config` verwenden. Sie können sie auch im Framework-Debugger sehen.": "To see what configuration options are available and what value they have, you can use the `ts-node app.ts app:config` command. You can also see them in the Framework Debugger.",
        "SSL": "SSL",
        "Es wird empfohlen (und manchmal auch vorgeschrieben), Ihre Anwendung über HTTPS mit SSL laufen zu lassen. Es gibt mehrere Optionen zur Konfiguration von SSL. Um SSL zu aktivieren, verwenden Sie": "It is recommended (and sometimes required) to run your application over HTTPS with SSL. There are several options for configuring SSL. To enable SSL, use",
        "`framework.ssl` und konfigurieren Sie dessen Parameter mit den folgenden Optionen.": "`framework.ssl` and configure its parameters with the following options.",
        "Local SSL": "Local SSL",
        "In der lokalen Entwicklungsumgebung können Sie selbstsignierte HTTPs mit der Option `framework.selfSigned` aktivieren.": "In the local development environment, you can enable self-signed HTTPs with the `framework.selfSigned` option.",
        "Wenn Sie diesen Server jetzt starten, ist Ihr HTTP-Server als HTTPS unter `https://localhost:8080/` verfügbar. In Chrome erhalten Sie beim Öffnen dieser URL jetzt die Fehlermeldung \"NET::ERR_CERT_INVALID\", da selbstsignierte Zertifikate als Sicherheitsrisiko gelten: `chrome://flags/#allow-insecure-localhost`.": "If you start this server now, your HTTP server is available as HTTPS at `https://localhost:8080/`. In Chrome, you now get the error message \"NET::ERR_CERT_INVALID\" when you open this URL because self-signed certificates are considered a security risk: `chrome://flags/#allow-insecure-localhost`.",
        "Die Services und Controller im Deepkit Framework sind so konzipiert, dass sie SOLID und sauberen Code unterstützen, der gut konzipiert, gekapselt und getrennt ist. Diese Eigenschaften machen den Code einfach zu testen.": "The services and controllers in the Deepkit framework are designed to support SOLID and clean code that is well designed, encapsulated, and separated. These features make the code easy to test.",
        "Diese Dokumentation zeigt Ihnen, wie Sie ein Test-Framework namens link:https://jestjs.io[Jest] mit `ts-jest` einrichten können. Führen Sie dazu den folgenden Befehl aus, um `jest` und `ts-jest` zu installieren.": "This documentation shows you how to set up a testing framework called link:https://jestjs.io[Jest] with `ts-jest`. To do this, run the following command to install `jest` and `ts-jest`.",
        "Jest benötigt ein paar Konfigurationsoptionen, um zu wissen, wo die Testanzüge zu finden sind und wie der TS-Code zu kompilieren ist. Fügen Sie die folgende Konfiguration zu Ihrer `package.json` hinzu:": "Jest needs a few configuration options to know where to find the test suits and how to compile the TS code. Add the following configuration to your `package.json`:",
        "Ihre Testdateien sollten den Namen `*.spec.ts` tragen. Erstellen Sie eine Datei `test.spec.ts` mit folgendem Inhalt.": "Your test files should be named `*.spec.ts`. Create a `test.spec.ts` file with the following content.",
        "Mit dem Befehl jest können Sie nun alle Ihre Testanzüge auf einmal ausführen.": "You can now use the jest command to run all your test suits at once.",
        "Bitte lesen Sie die link:https://jestjs.io[Jest-Dokumentation], um mehr darüber zu erfahren, wie das Jest CLI-Tool funktioniert und wie Sie anspruchsvollere Tests und ganze Test-Suites schreiben können.": "Please read the link:https://jestjs.io[Jest documentation] to learn more about how the Jest CLI tool works and how you can write more sophisticated tests and entire test suites.",
        "Unit Test": "Unit test",
        "Wann immer möglich sollten Sie Ihre Services mit einem Unit-Test teste. Je einfacher, besser getrennt und besser definiert Ihre Service-Abhängigkeiten sind, desto einfacher ist es, sie zu testen. In diesem Fall können Sie einfache Tests wie den folgenden schreiben:": "Whenever possible, you should unit test your services. The simpler, better separated, and better defined your service dependencies are, the easier it is to test them. In this case, you can write simple tests like the following:",
        "Integration tests": "Integration tests",
        "Es ist nicht immer möglich, Unit-Tests zu schreiben, und es ist auch nicht immer der effizienteste Weg, um geschäftskritischen Code und Verhalten abzudecken. Besonders wenn Ihre Architektur sehr komplex ist, ist es von Vorteil, wenn Sie einfach End-to-End-Integrationstests durchführen können.": "It's not always possible to write unit tests, nor is it always the most efficient way to cover business-critical code and behavior. Especially if your architecture is very complex, it is beneficial to be able to easily perform end-to-end integration tests.",
        "Wie Sie bereits im Kapitel Dependency Injection gelernt haben, ist der Dependency Injection Container das Herzstück von Deepkit. Hier werden alle Dienste aufgebaut und betrieben. Ihre Anwendung definiert Dienste (Provider), Controller, Listener und Importe. Bei Integrationstests wollen Sie nicht unbedingt alle Dienste in einem Testfall zur Verfügung haben, aber Sie wollen in der Regel eine abgespeckte Version der Anwendung zur Verfügung haben, um die kritischen Bereiche zu testen.": "As you have already learned in the Dependency Injection chapter, the Dependency Injection Container is the heart of Deepkit. This is where all services are built and run. Your application defines services (providers), controllers, listeners, and imports. For integration testing, you don't necessarily want to have all services available in a test case, but you usually want to have a stripped down version of the application available to test the critical areas.",
        "Wenn Sie Ihre Anwendung in mehrere Module aufgeteilt haben, können Sie diese leichter testen. Nehmen wir zum Beispiel an, Sie haben ein `AppCoreModul` erstellt und möchten einige Services testen.": "If you have divided your application into several modules, you can test them more easily. For example, suppose you have created an `AppCoreModule` and want to test some services.",
        "Sie verwenden Ihr Modul wie folgt:": "You use your module as follows:",
        "Und testen Sie es, ohne den gesamten Anwendungsserver zu booten.": "And test it without booting the entire application server.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Siehe xref:framework.adoc#framework-modules[Framework Modules], um mehr über App Module zu erfahren.": "See xref:framework.adoc#framework-modules[Framework Modules] to learn more about App Modules.",
        "Siehe xref:dependency-injection.adoc[Dependency Injection] für mehr Informationen.": "See xref:dependency-injection.adoc[Dependency Injection] for more information.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen xref:serialization.adoc[Serialization] und xref:validation.adoc[Validation] Features.": "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation] features.",
        "Die Umwandlung geschieht automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "The conversion is done automatically using the xref:serialization.adoc#serialization-loosely-conversion feature.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in": "All validation types from `@deepkit/type` can be applied. For this see more in",
        "xref:http.adoc#http-validation[HTTP Validation] zu finden.": "xref:http.adoc#http-validation[HTTP Validation].",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in xref:http.adoc#http-validation[HTTP Validation] zu finden.": "All validation types from `@deepkit/type` can be applied. More about this can be found in xref:http.adoc#http-validation[HTTP Validation].",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel xref:serialization.adoc[Serialization] und xref:validation.adoc[Validation].": "The properties in the given model can contain all TypeScript types and validation types that `@deepkit/type` supports. See the chapter xref:serialization.adoc[Serialization] and xref:validation.adoc[Validation].",
        "Siehe xref:validation.adoc[Validation] für mehr Informationen dazu.": "See xref:validation.adoc[Validation] for more information on this.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu xref:template.adoc[Template].": "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See also xref:template.adoc[Template].",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion xref:http.adoc#http-events[HTTP Events].": "By default, all errors are returned to the client as JSON. This behavior can be customized in the event system under the event `httpWorkflow.onControllerError`. See the section xref:http.adoc#http-events[HTTP Events].",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (sieh xref:http.adoc#http-events[HTTP Events]) nicht zu `controllerError` sondern zu `accessDenied`.": "The error `HttpAccessDeniedError` is a special case. As soon as it is thrown, the HTTP workflow (see xref:http.adoc#http-events[HTTP Events]) does not jump to `controllerError` but to `accessDenied`.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion xref:http.adoc#http-route-name[HTTP Route Name] einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "The `Redirect.toRoute` method uses the name of the route. How to set a route name can be seen in the section xref:http.adoc#http-route-name[HTTP Route Name]. If this referenced route (query or path) contains parameters, they can be specified via the second argument:",
        "Siehe xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes], um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "See xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes] to learn how to place providers in the `http` scope.",
        "HTTP middlewares allow you to hook into the request/response cycle as an alternative to HTTP events. Its API allows you to use all middlewares from the Express/Connect framework.": "HTTP middlewares allow you to hook into the request/response cycle as an alternative to HTTP events. Its API allows you to use all middlewares from the Express/Connect framework.",
        "A middleware can either be a class (which is instantiated by the dependency injection container) or a simple function.": "A middleware can either be a class (which is instantiated by the dependency injection container) or a simple function.",
        "Global": "Global",
        "By using httpMiddleware.for(MyMiddleware) a middleware is registered for all routes, globally.": "By using httpMiddleware.for(MyMiddleware) a middleware is registered for all routes, globally.",
        "Per Controller": "Per controller",
        "You can limit middlewares to one or multiple controllers in two ways. Either by using the `@http.controller` or `httpMiddleware.for(T).forControllers()`. `excludeControllers` allow you to exclude controllers.": "You can limit middlewares to one or multiple controllers in two ways. Either by using the `@http.controller` or `httpMiddleware.for(T).forControllers()`. `excludeControllers` allow you to exclude controllers.",
        "Per Route Name": "Per Route Name",
        "`forRouteNames` along with its counterpart `excludeRouteNames` allow you to filter the execution of a middleware per route names.": "`forRouteNames` along with its counterpart `excludeRouteNames` allow you to filter the execution of a middleware per route names.",
        "Per Action/Route": "Per Action/Route",
        "To execute a middleware only for a certain route, you can either use `@http.GET().middleware()` or": "To execute a middleware only for a certain route, you can either use `@http.GET().middleware()` or",
        "`httpMiddleware.for(T).forRoute()` where forRoute has multiple options to filter routes.": "`httpMiddleware.for(T).forRoute()` where forRoute has multiple options to filter routes.",
        "`forRoutes()` allows as first argument several way to filter for routes.": "`forRoutes()` allows as first argument several way to filter for routes.",
        "Path Pattern": "Path Pattern",
        "`path` supports wildcard *.": "`path` supports wildcard *.",
        "HTTP Method": "HTTP Method",
        "Filter all routes by a HTTP method.": "Filter all routes by a HTTP method.",
        "Category": "Category",
        "`category` along with its counterpart `excludeCategory` allow you to filter per route category.": "`category` along with its counterpart `excludeCategory` allow you to filter per route category.",
        "`group` along with its counterpart `excludeGroup` allow you to filter per route group.": "`group` along with its counterpart `excludeGroup` allow you to filter per route group.",
        "Per Modules": "Per Modules",
        "You can limit the execution of a module for a whole module.": "You can limit the execution of a module for a whole module.",
        "Per Self Modules": "Per Self Modules",
        "To execute a middleware for all controllers/routes of a module where the middleware was registered use `forSelfModules()`.": "To execute a middleware for all controllers/routes of a module where the middleware was registered use `forSelfModules()`.",
        "Timeout": "Timeout",
        "All middleware needs to execute `next()` sooner or later. If a middleware does not execute `next()` withing a timeout, a warning is logged and the next middleware executed. To change the default of 4seconds to something else use timeout(milliseconds).": "All middleware needs to execute `next()` sooner or later. If a middleware does not execute `next()` withing a timeout, a warning is logged and the next middleware executed. To change the default of 4seconds to something else use timeout(milliseconds).",
        "Multiple Rules": "Multiple Rules",
        "To combine multiple filters, you can chain method calls.": "To combine multiple filters, you can chain method calls.",
        "Express Middleware": "Express Middleware",
        "Almost all express middlewares are supported. Those who access certain request methods of express are not yet supported.": "Almost all express middlewares are supported. Those who access certain request methods of express are not yet supported.",
        "Willkommen bei der Deepkit-Dokumentation.": "Welcome to the Deepkit documentation.",
        "In dieser Dokumentation finden Sie weitere Informationen über die Verwendung der einzelnen Bibliotheken und des Deepkit-Frameworks in allen Einzelheiten mit Beispielcode.": "In this documentation you will find more information on how to use each library and the Deepkit framework in full detail with sample code.",
        "Work in Progress": "Work in Progress",
        "Diese Dokumentation ist noch in Arbeit.": "This documentation is still in progress.",
        "Obwohl es bereits einige Platzhalter gibt, sind viele, besonders im Bereich der Datenbanken, noch nicht geschrieben worden.": "Although some placeholders already exist, many, especially in the area of databases, have not yet been written.",
        "Wir sind ständig dabei, die Dokumentation zu verbessern.": "We are constantly improving the documentation.",
        "Wenn Sie dringend etwas brauchen, gehen Sie bitte in unseren Discord-Server.": "If you need something urgently, please go to our Discord server.",
        "Verwenden Sie die API-Dokumentation, um sehr detaillierte Informationen über die API der einzelnen Module zu erhalten.": "Use the API documentation to get very detailed information about the API of each module.",
        "Wenn Sie Hilfe benötigen, treten Sie bitte dem Discord-Community-Server bei:": "If you need help, please join the Discord community server:",
        "Deepkit Framework": "Deepkit Framework",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe xref:runtime-types.adoc[Runtime Types]), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus xref:validation.adoc[Validation] definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "In Deepkit RPC, the types from the functions are extracted from the TypeScript code itself (see xref:runtime-types.adoc[Runtime Types]), so there is no need to use a code generator or define them manually. Deepkit supports automatic serialization and deserialization of parameters and results. Once additional constraints are defined from xref:validation.adoc[Validation], they are also automatically validated. This makes communication via RPC extremely type-safe and effective. The support for streaming via `rxjs` in Deepkit RPC also makes this RPC framework a suitable tool for real-time communication.",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Since Deepkit RPC is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Siehe xref:dependency-injection.adoc[Dependency Injection], um mehr zu erfahren.": "See xref:dependency-injection.adoc[Dependency Injection] to learn more.",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu xref:rpc.adoc#rpc-nominal-types[RPC Nominal Types].": "RPC functions can throw errors. These errors are forwarded to the client by default and thrown again there. If custom error classes are used, their nominal type should be enabled. See xref:rpc.adoc#rpc-nominal-types[RPC Nominal Types].",
        "Siehe hierzu auch xref:dependency-injection.adoc[Dependency Injection].": "See also xref:dependency-injection.adoc[Dependency Injection].",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.",
        "Siehe xref:validation.adoc#validation-constraint-types[Validation Constraint Types].": "See xref:validation.adoc#validation-constraint-types[Validation Constraint Types].",
        "Siehe xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection], um mehr darüber zu erfahren.": "See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] to learn more.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion xref:serialization.adoc#serialisation-custom-serialiser[Custom Serializer] erfahren werden.": "Deepkit Type supports user-defined serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the xref:serialization.adoc#serialization-custom-serialiser[Custom Serializer] section.",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in xref:validation.adoc[Validation]. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel xref:validation.adoc[Validation] auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Note that although serializers also validate data for compatibility, these validations are different from the validation in xref:validation.adoc[Validation]. Only the `cast` function also calls the full validation process from the xref:validation.adoc[Validation] chapter after successful deserialization, and throws an error if the data is not valid.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe xref:validation.adoc[Validation].": "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see xref:validation.adoc[Validation].",
        "Standardmäßig wird `@deepkit/type` mit einem JSON-Serialisierer und einer Typ-Validierung für TypeScript-Typen geliefert. Sie können diesen erweitern und die Serialisierungsfunktionalität erweitern oder entfernen oder die Art und Weise der Validierung ändern, da die Validierung auch mit dem Serializer verbunden ist.": "By default, `@deepkit/type` comes with a JSON serializer and type validation for TypeScript types. You can extend this and add or remove the serialization functionality or change the way validation is done, since validation is also linked to the serializer.",
        "New Serialisierer": "New Serializer",
        "Ein Serializer ist einfach eine Instanz der Klasse `Serializer` mit registrierten Serializer-Vorlagen. Serializer-Vorlagen sind kleine Funktionen, die JavaScript-Code für den JIT-Serializer-Prozess erstellen. Für jeden Typ (String, Number, Boolean usw.) gibt es eine eigene Serializer-Vorlage, die für die Rückgabe von Code für die Datenkonvertierung oder -validierung zuständig ist. Dieser Code muss mit der JavaScript-Engine kompatibel sein, die der Benutzer verwendet.": "A serializer is simply an instance of the `Serializer` class with registered serializer templates. Serializer templates are small functions that create JavaScript code for the JIT serializer process. For each type (String, Number, Boolean, etc.) there is a separate Serializer template that is responsible for returning code for data conversion or validation. This code must be compatible with the JavaScript engine that the user is using.",
        "Nur während der Ausführung der Compiler-Vorlagenfunktion haben Sie (oder sollten Sie) vollen Zugriff auf den vollständigen Typ. Die Idee ist, dass Sie alle Informationen, die für die Konvertierung eines Typs erforderlich sind, direkt in den JavaScript-Code einbetten sollten, was zu hochgradig optimiertem Code (auch JIT-optimierter Code genannt) führt.": "Only during the execution of the compiler template function do you (or should you) have full access to the full type. The idea is that you should embed all the information needed to convert a type directly into the JavaScript code, resulting in highly optimized code (also called JIT-optimized code).",
        "Im folgenden Beispiel wird ein leerer Serializer erstellt.": "The following example creates an empty serializer.",
        "Wie Sie sehen können, wurde nichts umgewandelt (`created` ist immer noch eine Zahl, aber wir haben sie als `Date` definiert). Um das zu ändern, fügen wir eine Serializer-Vorlage für die Deserialisierung des Typs Datum hinzu.": "As you can see, nothing has been converted (`created` is still a number, but we have defined it as `date`). To change this, we add a serializer template for deserialization of type Date.",
        "Jetzt wandelt unser Serialisierer den Wert in ein Date-Objekt um.": "Now our serializer converts the value into a Date object.",
        "Um dasselbe für die Serialisierung zu tun, registrieren wir eine weitere Serialisierungsvorlage.": "To do the same for serialization, we register another serialization template.",
        "Unser neuer Serialisierer konvertiert das Datum im Serialisierungsprozess nun korrekt vom Date-Objekt in einen String.": "Our new serializer now correctly converts the date from the Date object to a string in the serialization process.",
        "Beispiele": "Examples",
        "Um viele weitere Beispiele zu sehen, können Sie einen Blick in den Code des link:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-Serializers] werfen, der in Deepkit Type enthalten ist.": "To see many more examples, you can take a look at the code of the link:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON serializer] included in Deepkit Type.",
        "Erweitern eines Serialisierers": "Expanding a serializer",
        "Wenn Sie einen bereits vorhandenen Serialisierer erweitern möchten, können Sie dies über die Klassenvererbung tun. Dies funktioniert, weil Serialisierer so geschrieben werden sollten, dass sie ihre Vorlagen im Konstruktor registrieren.": "If you want to extend an existing serializer, you can do so using class inheritance. This works because serializers should be written to register their templates in the constructor.",
        "Die Template-Engine ermöglicht es, typsichere, schnelle und sichere HTML-Templates zu schreiben. Sie basiert auf TSX und ist sofort einsatzbereit, sobald Sie die Dateierweiterung `.tsx` verwenden und die `tsconfig.json` entsprechend anpassen.": "The template engine allows to write type-safe, fast and secure HTML templates. It is based on TSX and is ready to use as soon as you use the file extension `.tsx` and adjust the `tsconfig.json` accordingly.",
        "Wichtig dabei ist: Es ist nicht kompatibel zu React. Sobald React eingesetzt werden soll, ist `@deepkit/template` inkompatibel. Deepkit's Template engine ist nur für SSR (Server-Side-Rendering) gedacht.": "The important thing is: it is not compatible with React. As soon as React is to be used, `@deepkit/template` is incompatible. Deepkit's template engine is only meant for SSR (server-side rendering).",
        "In your tsconfig you have to adjust following settings: `jsx` and `jsxImportSource`": "In your tsconfig you have to adjust the following settings: `jsx` and `jsxImportSource`.",
        "Jetzt können Sie TSX direkt in Ihrem Controller verwenden.": "Now you can use TSX directly in your controller.",
        "Wenn Sie eine solches TSX in Ihrer Routenmethode zurückgeben, wird der HTTP-Inhaltstyp automatisch auf `text/html; charset=utf-8` gesetzt.": "If you return such a TSX in your route method, the HTTP content type is automatically set to `text/html; charset=utf-8`.",
        "Sie können Ihre Templates so strukturieren, wie Sie es von React gewohnt sind. Entweder modularisieren Sie Ihr Layout in mehrere Funktions- oder Klassenkomponenten.": "You can structure your templates the way you are used to in React. Either modularize your layout into multiple function or class components.",
        "Am einfachsten ist es, eine Funktion zu verwenden, die TSX zurückgibt.": "The easiest way is to use a function that returns TSX.",
        "Funktionskomponenten können (anders als in React) asynchron sein. Dies ist ein wichtiger Unterschied zu anderen Template-Engines, die Sie vielleicht kennen, wie React.": "Function components can be asynchronous (unlike in React). This is an important difference from other template engines you may be familiar with, like React.",
        "Alle Funktionen haben Zugriff auf den Dependency Injection Container und können ab dem dritten Parameter beliebige Dependencies referenzieren.": "All functions have access to the dependency injection container and can reference any dependencies starting with the third parameter.",
        "Eine alternative Art, eine Komponente zu schreiben, ist eine Klassenkomponente. Sie werden im Dependency Injection Container behandelt und instanziiert und haben somit Zugriff auf alle im Container registrierten Dienste. Dadurch ist es möglich, in Ihren Komponenten beispielsweise direkt auf eine Datenquelle wie eine Datenbank zuzugreifen.": "An alternative way to write a component is a class component. They are handled and instantiated in the Dependency Injection container and thus have access to all services registered in the container. This makes it possible to directly access a data source such as a database in your components, for example.",
        "Für Klassenkomponenten sind die ersten Konstruktorargumente reserviert. `props` kann beliebig definiert werden, `children` ist immer \"any\", und dann folgen optionale Abhängigkeiten, die Sie beliebig wählen können. Da Klassenkomponenten im Dependency Injection Container instanziiert werden, haben Sie Zugriff auf alle Ihre Services.": "For class components the first constructor arguments are reserved. `props` can be defined arbitrarily, `children` is always \"any\", and then optional dependencies follow, which you can choose arbitrarily. Since class components are instantiated in the Dependency Injection container, you have access to all your services.",
        "Die Template-Engine hat alle verwendeten Variablen automatisch bereinigt, sodass Sie Benutzereingaben sicher direkt in der Vorlage verwenden können. Um dynamisches HTML zu rendern, können Sie die Funktion html verwenden.": "The template engine has automatically sanitized all variables used, so you can safely use user input directly in the template. To render dynamic HTML, you can use the html function.",
        "Die Template-Engine versucht, den generierten JSX-Code so zu optimieren, dass es für NodeJS/V8 viel einfacher ist, den HTML-String zu generieren. Damit dies korrekt funktioniert, sollten Sie alle Ihre Komponenten aus der Hauptdatei app.tsx in separate Dateien verschieben. Eine Struktur könnte so aussehen:": "The template engine tries to optimize the generated JSX code so that it is much easier for NodeJS/V8 to generate the HTML string. For this to work correctly, you should move all your components from the main app.tsx file to separate files. A structure might look like this:",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in xref:serialization.adoc[Serialization] mehr Informationen.": "This often seen code is a bug that can lead to a program crash or a security vulnerability because a type cast `as number` was used that does not provide any security at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in xref:serialization.adoc[Serialization].",
        "In den dazugehörigen Kapiteln (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "In the corresponding chapters (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and don't use `any` to make these validations work well and safely automatically. This can save you a lot of manual work to keep the code clean and safe.",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information."
    },
    "german": {},
    "chinese": {
        "Einführung": "介绍",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。它可以在开发过程中（但最迟在编译过程中）比纯JavaScript更快、更容易地发现错误，并与JavaScript一起工作，而不是反对它。一个用TypeScript编写的框架，旨在用TypeScript开发非常复杂的软件。它将许多从企业中已知的设计模式带到了TypeScript，并引入了只有TypeScript的新类型系统才能实现的全新功能，以提高开发速度，尤其是在团队中。小型应用程序也可以从这种新方法中受益，因为Deepkit为非常常见的使用情况配备了许多库，可以单独或组合使用。该框架本身被设计成尽可能的敏捷，并在必要的情况下尽可能的复杂，这不仅是为了快速获得初步的结果，也是为了长期保持开发速度。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries nicht nur untereinander einwandfrei funktionieren, sondern auch, dass die vorhandene Komplexität des Projektes effizient in Code gegossen werden kann. Auch ist es sehr schwer Ansprechpartner, gerade im Enterprise-Bereich, zu finden, wenn das Projekt auf tausende third-party Libraries basiert. Teilweise sind Libraries recht schnell nicht mehr richtig gepflegt und man hat entsprechend das Nachsehen, wenn der Fall mal eintritt, dass ein Bug gefunden oder ein Feature entwickelt werden soll.": "JavaScript现在是世界上最大的开发者社区，为开发者提供了相应的许多库和工具的选择，以满足项目的需求。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念和代码质量差别很大，以至于开发人员必须引入大量的胶水代码和额外的抽象，以便这些库不仅能相互正常工作，而且还能将项目的现有复杂性有效地投射到代码中。如果项目是基于数以千计的第三方图书馆，也很难找到联系人，特别是在企业部门。在某些情况下，库不再得到适当的维护，如果发现一个错误或需要开发一个功能，你将一无所获。",
        "Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "近几十年来，制造商或社区将几乎每个项目都需要的核心功能提供给精美的抽象库，并将其汇集到一个框架中，这一点已被反复证明。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten gegossen sind, um so bequem, untereinander harmonierend, und bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念被投在库或组件中，以便它们可以方便地使用，相互协调，并根据需要使用。所提供的功能不是切块的，而是基于有时是几十年前的概念，并且在与其他想法的竞争中证明了自己。",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript在这些年里取得了巨大的进步，因此与此同时，越来越多来自企业环境的设计模式可以被应用。在越来越多的库、框架和工具中可以找到的设计模式。然而，JavaScript和TypeScript有一个问题，即为了有效地应用许多已被证实的企业模式，语言本身缺少决定性的功能。这并不意味着这些设计模式不能被普遍应用，而是说它们的效率不如当前的其他语言。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (de-/serializer), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, die sie brauchen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译时完全删除了它的类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中和运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据被转换（de/serialised）、数据被验证、元信息被添加到对象中，或者在运行时需要接口信息的地方，这个值会被反映出来。在这些和其他许多用例中，运行时的类型信息可能非常有用，因为它为库提供了它们所需要的信息。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里无法再显示出它的优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit开发了一种类型编译器，将类型信息留在原地，允许在运行时计算动态类型，并在运行时读取现有类型信息。随着这种模式的转变，全新的工作方式成为可能，为上述用例提供了所需的信息，从根本上简化了复杂软件的开发，并赋予代码更多的表现力。第一次有可能在运行时使用TypeScript的全部功能和表现力。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikations-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种模式的转变，Deepkit开发了一整套用于几乎所有程序中都能找到的用例库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发人员需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit由两个主要领域组成。首先是Deepkit库和Deepkit框架。Deepkit库是一整个独立的TypeScript库（NPM包）家族，它们擅长一个主题，并经过优化、测试，旨在以最佳方式相互补充。一个项目可以使用单独的Deepkit库，也可以使用整个Deepkit框架，后者汇集了这些库的所有功能，并以调试器等附加工具对其进行补充。总之，它使开发人员能够建立复杂、快速和可生产的应用程序。",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit支持一系列的使用案例。从简单的命令行工具（CLI程序）到网络应用和微服务再到桌面或移动应用。这些代码被设计成可以在任何已知的JavaScript引擎（浏览器以及NodeJS）中运行，并与Angular、React和Vue等其他框架完美整合。",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "Deepkit Framework背后的主张是应用干净的代码、SOLID原则和企业设计模式，不仅提供高质量的代码，而且让用户也能应用它们。另外，Deepkit试图在其文档和示例中推广这些相同的原则，但并不强迫开发者自己遵循这些原则。",
        "High-Performance": "高性能",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "软件开发中最困难的问题之一是在数月或数年后仍能保持较高的开发速度，特别是随着代码和团队的成长。有许多框架承诺快速启动，用它们可以在很短的时间内组装出更复杂的应用程序。然而，他们通常有一个共同的问题，即项目越老或团队越大，开发速度就会急剧下降。即使在几个月后，只有少数几个开发人员，开发速度也会崩溃，以至于下降到原来速度的1%，这种情况并不罕见。",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "为了抵制这种现象，有必要应用既定的设计模式，并提前使用正确的框架和库。企业设计模式已经确立了自己的地位，因为它们即使在较大的应用程序和大型团队中也能出色地扩展。正确地应用，它们会发展出自己的能力，特别是当一个项目要在较长的时间内（几个月到几年）开发时。",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "设计模式在理论上有其优点，但在实践中，几乎每一种模式也有其缺点。这些缺点根据语言和框架的不同而表现得不同，因为语言和框架本身决定了一个模式的应用是否符合人体工程学。仅仅因为某种模式可以应用于某种语言，并不意味着它可以自动地使开发变得更好、更快。",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel kann wie bereits oben ausgeführt Typescript-Dekoratoren mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "有些语言比其他语言更适合应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在其核心中使用，但有一些限制，大量损害用户体验，从而影响速度。例如，如上所述，如果一个依赖注入框架指定了这个框架并以其为基础，那么Typescript装饰器及其所有的特异性就可能成为必要。",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit的运行时类型系统确保以最符合人体工程学的方式和尽可能少的模板来应用这些设计模式，释放它们的力量，以便不仅在最初，而且在长期保持高开发速度。",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "TypeScript的最大优势之一是在许多用例中可以更好地编写复杂代码。这包括前端、后端、CLI工具、移动和桌面应用程序，以及更多。当一个项目跨越了这些用例并几乎完全依赖TypeScript时，它被称为Isomorphic TypeScript。在尽可能多的代码中使用TypeScript可以极大地提高开发速度。",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit框架及其运行时类型系统旨在最大限度地利用Isomorphic TypeScript的这些以及更多的优势，从而使其最大的力量凸显出来。",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "双栈（不同语言的前端和后端）等老方法已经远远跟不上了，因为仅语言之间的上下文切换就已经花费了巨大的精力和时间。所有其他已经解释过的优点甚至使它成为一个不公平的比较。像TypeScript这样的同构技术栈，如果应用得当，在基本层面上比任何后端/前端的双栈组合（如Java/JavaScript、PHP/JavaScript，甚至JavaScript/JavaScript）的开发时间快很多倍。由于更高的开发速度也意味着同样的功能需要更少的时间，这也意味着Isomorphic TypeScript可以节省资金。除了已经介绍的所有好处，这也是在所有下一步尤其是商业项目中使用Isomorphic TypeScript的杀手锏。",
        "pageBreak:": "pageBreak:",
        "Runtime Types": "运行时类型",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Dekoratoren zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "在TypeScript中提供运行时的类型信息变化很大。它允许采用新的工作方式，而这在以前只能以迂回的方式或根本不可能实现。声明类型和模式已经成为现代开发过程中的一个重要部分。GraphQL、验证器、ORM、ProtoBuf等编码器以及其他许多东西都依赖于在运行时有模式信息可用，以提供基本功能。这些工具和库有时需要开发人员学习全新的语言，这些语言是专门为使用情况开发的。例如，ProtoBuf和GraphQL有自己的声明语言，验证器通常基于自己的模式API，甚至是JSON模式，这也是一种独立的定义结构的方式。其中一些需要在每次更改时运行代码生成器，以便将模式信息也提供给运行时。另一个著名的模式是使用实验性的TypeScript装饰器，在运行时向类提供元信息。",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "但这一切有必要吗？TypeScript提供了一个非常强大的语言来描述甚至非常复杂的结构。事实上，TypeScript现在是游刃有余的，这大致意味着理论上任何种类的程序都可以映射到TypeScript中。当然，这有其实际的局限性，但重要的一点是，TypeScript能够完全取代任何声明格式，如GraphQL、ProtoBuf、JSON Schema和许多其他格式。在运行时与类型系统相结合，有可能涵盖所有描述的工具和它们在TypeScript本身的使用情况，而不需要任何代码生成器。但是，为什么仍然没有确切的解决方案呢？",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "从历史上看，TypeScript在最近几年经历了巨大的变化。它已经被完全重写了好几次，获得了基本的功能，并经历了一系列的迭代和突破性变化。然而，与此同时，TypeScript已经达到了产品市场的契合度，大大减缓了基本创新和突破性变化发生的速度。TypeScript已经证明了自己，并展示了像JavaScript这样的高度动态语言的高度迷人的类型系统应该是什么样子。市场感激地接受了这一推动，并迎来了用JavaScript开发的新时代。",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "此时正是在语言本身的基础上建立工具的好时机，使上述情况成为可能。Deepkit希望成为推动力，将几十年来来自Java和PHP等语言企业的成熟设计模式不仅从根本上引入TypeScript，而且以一种新的、更好的方式与JavaScript一起工作，而不是反对它。通过运行时的类型信息，这些现在第一次不仅在原则上是可能的，而且允许全新的更简单的设计模式，这在Java和PHP等语言中是不可能的。",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "在运行时读取类型信息是Deepkit建立其基础的能力，TypeScript本身已经在这里奠定了基础，通过全新的方法与经过测试的方法有力地结合，大大简化了开发人员的生活。Deepkit库的API主要集中在使用尽可能多的TypeScript类型信息，以达到尽可能的高效。运行时的类型系统意味着类型信息在运行时是可读的，动态类型是可计算的。这意味着，例如，对于类的所有属性和对于函数的所有参数和返回类型都可以被读出。",
        "Nehmen wir als Beispiel diese Funktion:": "以这个函数为例：",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "在JavaScript本身，有几个信息可以在运行时被读出。例如，函数的名称（如果没有用最小化器修改）：",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "另一方面，可以读出参数的数量：",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "只要多写一点代码，也可以读出参数的名称。然而，如果没有一个简陋的JavaScript解析器或对log.toString()的正则表达法，这是不可能做到的，所以就这样了。由于TypeScript将上述函数翻译成JavaScript，如下：",
        "sind die Informationen, dass message vom Typ string und der Return-Typ vom Type void ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "消息是字符串类型，返回类型是void类型的信息已不再可用。",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "安装Deepkit的运行时类型系统需要两个包。`@deepkit/type-compiler`中的类型编译器和`@deepkit/type`中的必要运行时间。类型编译器可以安装在`package.json`_devDependencies_中，因为它只在构建时需要。",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Dekoratoren verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "运行时类型信息默认不生成。必须在`tsconfig.json`文件中设置`\"反射\": true`，以便在该文件同一文件夹的所有文件或所有子文件夹中启用。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。这对于使用`@deepkit/type`来说并不是严格必要的，但对于其他deepkit库和`@deepkit/framework`中的某些功能来说是必要的。",
        "_Datei: tsconfig.json_": "_文件：tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in` node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript本身并不允许你通过`tsconfig.json`来配置类型编译器。有必要直接使用TypeScript编译器API或像Webpack这样带有_ts-loader_的构建系统。为了避免Deepkit用户走这条不方便的路，一旦`@deepkit/type-compiler`被安装，Deepkit类型编译器就会自动安装在`node_modules/typescript`中（这是通过NPM安装钩子完成的）。",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "这使得所有访问本地安装的TypeScript（`node_modules/typescript`中的）的构建工具都能自动启用类型编译器。这使得_tsc_、Angular、webpack、_ts-node_和其他一些工具能够自动与deepkit类型编译器一起工作。",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgenden Kommando nachgeholt werden:": "如果类型编译器不能成功地自动安装（例如，由于NPM安装钩子被禁用），这可以通过以下命令手动完成：",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "注意，如果本地的typecript版本已经更新（例如，如果软件包中的typecript版本。",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "如果要在webpack构建中使用类型编译器，可以使用`ts-loader`包（或任何其他支持transformer注册的类型脚本加载器）来完成。）",
        "_Datei: webpack.config.js_": "_文件：webpack.config.js_",
        "Typen-Dekoratoren": "Type-decorators",
        "Typen-Dekoratoren sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um meist zur Laufzeit das Verhalten festzulegen. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden.  Die Datenbank Library kann diese Information nutzen, um die korrekten SQL Queries zu erstellen.": "Type-decorators是普通的TypeScript类型，包含元信息，主要用于在运行时指定行为。例如，一个类属性可以被标记为主键、引用或索引。  数据库库可以使用这些信息来创建正确的SQL查询。",
        "Es können auch Validator-Einschränkungen wie zum Beispiel MaxLength, Maximum, oder Positive an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist.": "Validator约束，如MaxLength、Maximum或Positive，也可以被添加到任何类型。我们也可以告诉序列化器如何序列化或反序列化一个特定的值。",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Dekoratoren, die alle direkt aus @deepkit/type benutzt werden können. Sie sind designt, nicht aus einer bestimmten Library zu kommen, um so Typen nicht an eine Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppelt. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Dekoratoren genutzt werden.": "Deepkit附带了一系列的类型装饰器，所有这些都可以直接从@deepkit/type中使用。它们被设计成不来自于某个特定的库，所以类型不必与Deepkit RPC或Deepkit Database这样的库耦合。这使得类型的重用更加容易，甚至在前端也是如此，尽管数据库类型装饰器被使用，例如。",
        "Enhanced Types": "Enhanced Types",
        "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .": "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .",
        "Meta": "Meta",
        "MapName, Group, Data, Entity, InlineRuntimeType.": "MapName, Group, Data, Entity, InlineRuntimeType。",
        "Serializer": "Serializer",
        "Excluded, Embedded.": "Excluded, Embedded.",
        "Database": "Database",
        "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "为了直接处理类型信息本身，这里有两个基本变种。类型对象和反思类。下面将讨论反思类。函数`typeOf`返回类型对象，它是非常简单的对象字面。它总是包含一个`kind'，这是一个数字，通过枚举`ReflectionKind'获得其含义。`ReflectionKind`在包`@deepkit/type`中定义如下：",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "有许多可能的类型对象可以被返回。其中最简单的是`never`、`any`、`unknown`、`void、null`和`undefined`，其表示方法如下：",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "例如，数字0是`ReflectionKind`枚举的第一个条目，在这里是`never`，数字1是第二个条目，这里是`any`，以此类推。因此，原始类型如`string`、`number`、`boolean`被表示为：",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "这些相当简单的类型在类型对象处没有进一步的信息，因为它们被直接作为类型参数传递给`typeOf`。然而，如果类型是通过类型别名传递的，额外的信息可以在类型对象中找到。",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "在这种情况下，类型别名`title`的名字也会出现。如果一个类型别名是一个泛型，那么传递的类型也将在类型对象处可用。",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "如果传递的类型是一个索引访问操作的结果，那么容器和索引类型将出现：",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "接口和对象字面都作为Reflection.objectLiteral输出，并包含`types`数组中的属性和方法。",
        "Index Signatures sind ebenfalls in dem `types` array.": "索引签名也在 \"types \"数组中。",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "类类似于对象字面，除了 \"classType \"是对类本身的引用外，它们的属性和方法也在 \"types \"数组中。",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "注意，类型已经从Reflection.propertySignature变为Reflection.property，Reflection.methodSignature变为Reflection.method。由于类上的属性和方法有额外的属性，这些信息也可以被检索到。后者还包括`visibility`、`abstract`和`default`。",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "类的类型对象只包括类本身的属性和方法，不包括超类的属性和方法。这与接口/对象文字的类型对象相反，后者将所有父类的所有属性签名和方法签名解析为 \"类型\"。要解决超类的属性和方法，可以使用ReflectionClass及其`ReflectionClass.getProperties()`（见下面的章节）或`@deepkit/type`的`resolveTypeMembers()`。",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "有一大堆类型对象。例如，对于字面意思、模板字面意思、承诺、枚举、联合、数组、元组等等。要想知道哪些类型都存在，有哪些信息，建议从`@deepkit/type`中导入`type`。它是一个具有所有可能的子类型的 \"union\"，如TypeAny、TypeUnknonwn、TypeVoid、TypeString、TypeNumber、TypeObjectLiteral、TypeArray、TypeClass，以及更多。确切的结构可以在那里找到。",
        "Type Cache": "类型缓存",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "一旦没有传递通用参数，类型对象就会被缓存到类型别名、函数和类。具体来说，这意味着对`typeOf<MyClass>()`的调用将总是返回相同的对象。",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "但是只要使用Generic类型，新的对象将总是被创建，即使传递的类型总是相同。这是因为理论上有无限多的组合是可能的，所以缓存实际上是一种内存泄漏。",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "然而，只要一个类型被多次实例化为递归类型，它就会被缓存起来。然而，缓存的持续时间只限于计算类型的时刻，此后就不存在了。另外，虽然Type对象被缓存了，但返回的是一个新的引用，并不是完全相同的对象。",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht das selbe Type-Objekt.": "`MyType<string>`被缓存了，只要`Object`被计算了。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "所有非根Type对象都有一个父属性，它通常指向包围的父。",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "`Ref 1`指向实际的联合类型对象。",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "在缓存类型对象的情况下，如上所述，`parent`属性并不总是真正的父对象。所以，例如，对于一个多次使用的类，虽然`types`中的即时类型（TypePropertySignature和TypeMethodSignature）指向正确的TypeClass，但这些签名类型的`type`指向缓存条目的TypeClass的签名类型。知道这一点很重要，这样就不会无限地读取父结构，而只读取直接的父结构。父类没有无限精度是由于性能的原因。",
        "JIT cache": "JIT缓存",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "在进一步的课程中，描述了一些经常基于Type对象的函数和特性。为了以一种高性能的方式实现其中的一些内容，需要对每个类型对象进行JIT缓存（just in time）。这可以通过`getJitContainer(type)`提供。这个函数返回一个简单的对象，上面可以存储任何数据。只要不保留对该对象的引用，只要Type对象本身也不再被引用，它就会通过GC自动删除自己。",
        "Reflection-Klassen": "反射类",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "除了`typeOf<>()`函数，还有各种反射类，它们提供了Type对象的OOP替代品。反射类只适用于类、界面/对象字面和函数以及它们的直接子类型（属性、方法、参数）。所有更深层次的类型必须再次用Type对象来读取。",
        "Typeninformation empfangen": "接收类型信息",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "为了提供自己对类型进行操作的函数，提供给用户手动传递一个类型可能是有用的。例如，在一个验证函数中，提供要请求的类型作为第一个类型参数和要验证的数据作为第一个函数参数可能是有用的。",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "为了让这个函数接收类型`string`，它必须告诉类型编译器这一点。",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType`与第一个类型参数`T`的引用给类型编译器发出信号，任何对`validate`的调用应该把类型放在第二位（因为`type`被声明在第二位）。为了在运行时读出信息，使用了`resolveReceiveType`函数。",
        "Es ist nützlich, das Ergebnis der selben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typenkompiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "将结果分配给同一个变量是很有用的，这样就不会不必要地创建一个新变量。在`type`中，要么现在就存储一个类型对象，要么就抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有启用类型信息的发射（见上面的安装部分）。",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "为了详细了解Deepkit如何编码和读取JavaScript中的类型信息，本章旨在介绍。",
        "Typen-Compiler": "类型编译器",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "类型编译器（在@deepkit/type-compiler中）负责读取TypeScript文件中定义的类型并将其编译为字节码。这个字节码拥有在运行时执行类型所需的一切。",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "在本书出版时，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，可以将一个TypeScript AST转化为另一个TypeScript AST。Deepkit的类型编译器在这个过程中读取AST，产生相关的字节码，并将其插入AST中。",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript本身不允许你通过tsconfig.json来配置这个插件，又称转化器。要么直接使用TypeScript编译器API，要么使用Webpack这样的构建系统与`ts-loader`。为了避免 Deepkit 用户的这种不便，在安装 `@deepkit/type-compiler` 时，Deepkit 类型编译器会自动安装在 `node_modules/typescript` 中。这使得所有访问本地安装的TypeScript（即`node_modules/typescript`中的那个）的构建工具都能自动启用类型编译器。这使得tsc、Angular、webpack、ts-node和其他一些工具能够自动与Deepkit的类型编译器一起工作。",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "如果没有启用NPM安装脚本的自动运行，因此本地安装的类型脚本不会被修改，如果你想，这个过程必须手动运行。另外，类型编译器也可以在webpack等构建工具中手动使用。",
        "Bytecode Encoding": "字节码编码",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "字节码是虚拟机的命令序列，在JavaScript中被编码为引用数组和字符串（实际的字节码）。",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlessatz über 81 Befehle gross.": "现有的命令本身是一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`枚举。在写这篇文章的时候，命令集的大小超过了81条。",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "一连串的命令被编码为一个字符串，以节省内存。因此，一个类型`string[]`被概念化为一个字节码Program`[string, array]`，它有字节`[5, 37]`，并使用以下算法进行编码：",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "据此，5成为`&`字符，37成为`F`字符。",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__&#8486;\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "为了防止命名冲突，每个类型都有一个\"__&#8486; \"作为前缀，这些都成为\"&F\"，并在Javascript中以\"['&F']\"的形式发出。对于每个明确定义的、被导出的或被导出的类型所使用的类型，一个字节码会发射出JavaScript。类和函数也可以直接接收字节码作为属性。",
        "Virtuelle Maschine": "虚拟机",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "运行时虚拟机（在`@deepkit/type`类的处理器中）负责解码和执行编码的字节码。它总是返回一个类型对象，见上面的Reflection部分。",
        "Validation": "验证",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation是检查数据正确性的过程。如果类型是正确的，并且满足了其他定义的限制，那么正确性就得到了。Deepkit通常区分类型验证和附加约束的验证。",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "只要数据来自被认为不安全的来源，就会使用验证。不确定意味着不能对数据的类型或内容做出有保障的假设，因此数据在运行时可能具有字面上的任何价值。",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "因此来自用户输入的数据通常不被认为是安全的。来自HTTP请求（查询参数、正文）、CLI参数或读入文件的数据必须被验证。如果一个变量被声明为数字，其中也必须有一个数字，否则程序会崩溃或出现安全漏洞。",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "例如，在一个HTTP路由的控制器中，首要任务是检查每个用户的输入（查询参数，正文）。特别是在TypeScript环境中，不要使用类型转换，因为它们从根本上是不安全的。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个类型转换`作为数字`，在运行时没有提供任何安全。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "在相关章节（<<cli>>, <<http>>, <<rpc>>, <<database>>）中，我们详细解释了什么时候验证会自动进行。确保你知道在什么地方必须定义限制或类型，不要使用`any`，这样这些验证就能很好地自动安全工作。这可以为你节省大量的手工工作，以保持代码的干净和安全。",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "验证器的基本功能是检查一个值的类型。例如，一个值是否是一个字符串。这不是关于字符串包含什么，只是它的类型。在Typescript中有很多类型：字符串、数字、布尔值、大数、对象、类、接口、泛型、映射类型等等。通过Typescript强大的类型系统，可以提供大量不同的类型。",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "在JavaScript本身，原始类型可以用`typeof`操作符进行解析。对于更复杂的类型，如接口、映射类型或通用集合/映射，这就不再那么容易了，因此需要一个验证器库，如`@deepkit/type`。Deepkit是唯一允许直接验证所有TypesScript类型而不走弯路的解决方案。",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "`username`的类型是字符串。如果验证器要检查变量`username`是否是一个字符串，这可以很容易地用JavaScript本身完成。",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "因此，函数`isString`可以被看作是一个类型验证器。然而，在JavaScript本身，当需要检查数字时，就会变得更加困难。有一些特殊的功能，比如当一个无效的字符串被转换为数字时，NaN（\"不是数字\"）。",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "运算符`typeof`返回Number，尽管它的值是NaN（\"不是数字\"），字面意思是说它不想成为一个数字。从这里开始，必须进行特殊的额外检查，如`isNaN()`，而且很快就会发现使用外部库，如Deepkit，它会自动考虑到这些特殊性。",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "在Deepkit中，类型验证可以通过`validate`、`is`或`assert`函数进行。函数`is`是一个所谓的类型保护，`assert`是一个类型断言。",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "函数`validate`返回一个发现错误的数组，如果成功则返回一个空数组。这个数组中的每个条目都描述了确切的错误代码和错误信息以及路径，只要更复杂的类型，如对象或数组得到验证。",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "这三个函数的使用大致相同。类型被指定或引用为第一个类型参数，数据作为第一个函数参数被传递。",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "当处理更复杂的类型如类或接口时，数组也可以包含几个条目。",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "验证器也支持深度递归类型。路径然后用一个点隔开。",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "利用TypeScript为你提供的好处。因此，更复杂的类型，如 \"用户\"，可以在多个地方重复使用，而不必一次又一次地声明。例如，如果一个 \"用户 \"要在没有 \"id \"的情况下被验证，TypeScript的工具可以被用来快速有效地创建派生的子类型。为了保持DRY（Don't Repeat Yourself）。",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit是唯一能够在运行时以这种方式访问TypeScripts类型的主要框架。如果你想在前端和后端使用类型，可以将类型外包给一个单独的文件，从而在任何地方都可以导入。",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "TypeScript中的类型转换（与类型保护相反）在运行时不是一个构造，而只是在类型系统本身中处理。",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "代码 \"as string \"在此并不安全，它是为未知数据分配类型的一种方式。变量`data`实际上可以有任何值，例如`{username: 123}`，甚至`{}`，这将导致`username`不是一个字符串，而是完全不同的东西，因此代码`username.startingWith('@')`将导致一个错误，所以在最坏的情况下，程序会崩溃。为了保证在运行时`data`有一个类型为String的属性`username`，必须使用类型保护。",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "类型保护是给TypeScript一个提示，告诉它在运行时保证传递的数据有什么类型。掌握了这些知识，TypeScript就会随着代码的进展完善（\"缩小\"）该类型。  例如，`any`可以以安全的方式变成字符串或其他类型。",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "因此，如果有数据的类型不知道（`any`或`unknown`），类型保护有助于根据数据本身更精确地缩小范围。然而，类型保护只有在其实施时才是安全的。如果你犯了一个错误，这可能会产生严重的后果，因为基本的假设突然变成了不真实的。",
        "Type-Guard": "类型防护",
        "Ein Type-Guard auf den obige genutzten Typen User könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obig erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht korrekt ist.": "上面使用的类型用户的类型防护，其最简单的形式是这样。请注意，上面用NaN解释的特殊功能不属于这个范围，因此这个类型保护器是不正确的。",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "类型保护器总是返回一个布尔值，通常直接用于If操作。",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "为每个类型保护器编写一个单独的函数，特别是对于更复杂的类型，然后在每次类型改变时调整它是非常繁琐的，容易出错，而且没有效率。因此，Deepkit提供了函数`is`，它为任何TypeScript类型自动提供了一个类型保护器。这就自动考虑到了一些特殊的特点，比如上面提到的NaN的问题。函数`is`的作用与`validate`相同，但它不是返回一个错误数组，而是简单地返回一个布尔值。",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "经常可以发现的一种模式是，如果验证失败，直接返回一个错误，这样就不会执行后续的代码。这可以在不同的地方使用，而不改变代码的完整流程。",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "另外，还可以使用TypeScript类型断言。如果给定的数据不能正确验证为一个类型，函数`assert`会自动抛出一个错误。函数的特殊签名，区别于TypeScript的类型断言，有助于TypeScript自动细化（'缩小'）传递的变量。",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "再次，利用TypeScript为他们提供的好处。类型可以被各种TypeScript函数重用或定制。",
        "Einschränkungen": "约束",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "除了检查类型，其他任意的约束可以被添加到一个类型。这些额外的内容约束的检查是在类型本身被检查后自动完成的。这是在所有验证函数中进行的，如`validate`、`is`和`assert`。一个限制可以是，例如，一个字符串必须有一定的最小或最大长度。",
        "Diese Einschränkungen werden über die Typen-Dekorationen an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Dekoratoren können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "这些限制是通过类型装饰添加到实际的类型中。有一整套可以使用的装饰品。如果需要扩展，可以随意定义和使用自己的装饰器。",
        "Mit `&` können beliebig viele Typen-Dekoratoren an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "用`&`可以在实际的类型上添加任意数量的类型装饰器。结果，这里是`username'，然后可以在所有的验证函数中使用，但也可以在其他类型中使用。",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "函数`validate'给出了有用的错误信息，这些信息来自于限制。",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "例如，这些信息也可以奇妙地自动显示在表单上，并通过`code'翻译。使用对象和数组的现有路径，表单中的字段可以过滤出并显示适当的错误。",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "一个经常有用的用例也是用一个正则约束来定义一个电子邮件。一旦定义了类型，就可以在任何地方使用。",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "可以添加任何数量的约束。",
        "Constraint Types": "约束类型",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "使用自定义验证函数进行验证。",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "定义一个正则表达式作为验证模式，更多信息见下一节自定义验证器。通常用于电子邮件验证或更复杂的内容验证。",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "验证字母字符（a-Z）。",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "验证字母和数字字符。",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "验证ASCII字符。",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "验证代表十进制数字的字符串，如0.1，.3，1.1，1.00003，4.0等。",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "验证数字是给定数字的倍数。",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "验证数组或字符串的最小/最大长度。",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "验证一个数组项或子字符串被包括/排除",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "验证一个值是最小或最大的给定数字。与`>=`和`&lt;=`相同。",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "与最小/最大值相同，但不包括值本身。",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date).",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "通过`/^\\S+@\\S+$/`对电子邮件进行简单的regexp验证。",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "确保数字是正确范围内的整数，所以不需要做 \"string & Email\"。是自动的 \"数字\"，所以不需要做 \"数字和整数\"。",
        "See Special types: integer/floats for more information": "更多信息见特殊类型：整数/浮点",
        "Benutzerdefinierte Validator": "自定义验证器",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "如果内置的验证器不够用，可以通过`Validate`装饰器创建和使用自定义验证器函数。",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "请注意，你的自定义验证器函数是在所有内置类型验证被调用后执行。如果一个验证器失败了，当前类型的所有后续验证器都被省略。每个类型只可能有一次失败。",
        "Generic Validator": "通用验证器",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "在验证器函数中，类型对象是可用的，可以使用验证器来获得更多关于类型的信息。也有一种方法可以定义任何必须传递给验证类型的验证器选项，使验证器可配置。有了这些信息及其父级引用，就可以创建强大的通用验证器。",
        "Serialisation": "序列化",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "序列化是将数据类型转换为适合传输或存储的格式的过程，例如。反序列化是撤销这一过程。这是无损完成的，这意味着数据可以在不丢失数据类型信息或数据本身的情况下转换为序列化目标。",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet.": "在JavaScript中，序列化通常在JavaScript对象和JSON之间完成。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），反之亦然，如果服务器将数据作为JSON发送到客户端。",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "这个序列化过程对于非琐碎的数据是绝对必要的，因为JSON甚至对于像日期这样的基本类型都会丢失其信息。一个 \"新日期 \"最终被序列化为JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "中的字符串，可以看出，JSON.stringify的结果是一个JSON字符串。如果再次用JSON.parse反序列化，结果不是一个`日期'对象，而是一个字符串。",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "尽管有各种变通方法来教JSON.parse反序列化日期对象，但它们容易出错，而且性能很差。为了使这种情况和许多其他类型的类型安全的序列化和反序列化，需要一个序列化过程。",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "有四个主要功能。`serialize`, `cast`/`deserialize`和`validatedDeserialize`。在这些函数的引擎盖下，默认使用`@deepkit/type`的全局可用的JSON序列化器，但也可以使用自定义的序列化目标。",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type支持自定义的序列化目标，但已经配备了一个强大的JSON序列化目标，可以将数据序列化为JSON对象，然后可以使用JSON.stringify正确、安全地转换为JSON。通过`@deepkit/bson`，BSON也可以作为一个序列化目标。如何创建一个自定义的序列化目标（例如为数据库驱动），可以在<<序列化-自定义序列化器>>一节中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten validieren, um sicherzustellen, dass diese auch umgewandelt werden können, diese Validierung nicht dieselbe ist wie in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "注意，尽管序列化器也会验证数据以确保其可以被转换，但这种验证与<<验证>>一章中的验证是不同的。只有`cast`函数在成功反序列化后还会调用完整的验证过程，如果数据无效就会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "另外，`validatedDeserialize`也可以用来在反序列化后进行验证。另一种方法是手动调用`validate'或`validates'函数来处理来自`deserialize'函数的反序列化数据，详见<<validation>>章节。",
        "Alle Funktionen aus den Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "所有来自序列化和验证的函数在出错时都会从`@deepkit/type`中抛出一个`ValidationError`。",
        "Deserialisierung": "反序列化",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "`deserialize`函数默认使用JSON序列化器将传递的数据转换为适当的指定类型。JSON序列化器希望得到一个JSON对象，即字符串、数字、布尔值、对象或数组。",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "如果已经传递了正确的数据类型（例如，在`created'的情况下是一个Date对象），那么这将被视为是。",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "不仅是一个类，而且任何TypeScript类型都可以被指定为第一个类型参数。因此，即使是基元或非常复杂的类型也可以被传递：",
        "Weiche Typenkonvertierung": "软类型转换",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserialisierer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "软类型转换是在反序列化过程中实现。这意味着String和Number的字符串类型或Number的字符串类型可以被接受并自动转换。这很有用，例如，当数据通过一个URL被接受并传递给反序列化器时。由于URL总是一个字符串，Deepkit Type仍然会尝试解决Number和Boolean的类型。",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serialiser eingebaut:": "JSON序列化器中内置了以下软类型转换：",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "也可以禁用软转换：",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "如果数据是无效的，它将不会尝试转换，而是抛出一个错误消息。",
        "Serialisierung": "序列化",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "函数`serialize`根据默认情况用JSON序列化器将传递的数据转换为JSON对象，即：字符串、数字、布尔值、对象或数组。然后可以使用JSON.stringify将其结果安全地转换为JSON。",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Todo": "Todo",
        "Dependency Injection": "依赖注入",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten": "Dependency Injection（DI）是一种设计模式，类和函数接受其依赖性",
        "_empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\")": "_。它遵循控制反转（IoC）",
        "und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität,": "的原则，有助于更好地分离复杂的代码，以显著提高可测试性、模块化",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "为了说明IoC的原则，这里有一个例子：",
        "Die Klasse UserRepository hat dabei als Abhängigkeit einen HttpClient. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "UserRepository类有一个HttpClient作为依赖关系。这个依赖关系本身并不显眼，但UserRepository自己创建了HttpClient，这就有问题了。乍一看，这似乎很明显，但它有其缺点。如果我们想替换掉HttpClient怎么办？如果我们想在单元测试中测试UserRepository，而不允许真正的HTTP请求出去呢？我们怎么知道这个类根本就在使用HttpClient呢？",
        "Inversion of Control": "控制反转",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "在控制反转（IoC）的思想中，有以下的替代变体，它将HttpClient设置为构造函数中的显式依赖（也称为构造函数注入）。",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "现在UserRepository不再负责创建HttpClient，但UserRepository的用户负责。这就是反转控制（IoC）。控制权已被逆转或颠倒。具体来说，这段代码使用了依赖注入，因为依赖被接收（注入），不再创建或请求。依赖注入只是应用IoC的一种方式。",
        "Service Locator": "服务定位器",
        "Neben DI ist auch ein Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "除了DI之外，服务定位器（SL）是应用IoC原则的另一种方式。这通常被认为是与依赖性注入相对应的，因为它请求依赖性而不是接受它们。如果HttpClient在上述代码中被请求如下，就会说到服务定位器模式。",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "函数`locator.getHttpClient`可以有一个完全任意的名字。替代品是函数调用，如`useContext(HttpClient)`、`getHttpClient()`、`await import(\"client\")`，或容器调用，如`container.get(HttpClient)`。全局的导入是服务定位器的一个稍微不同的变体，使用模块系统本身作为定位器：",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "所有这些变体的共同点是它们明确请求依赖HttpClient。这种要求不仅可能发生在作为默认值的属性上，也可能发生在代码中间的某个地方。因为在代码的中间意味着它不是类型接口的一部分，所以HttpClient的使用是隐藏的。根据HttpClient被请求的方式的不同，有时候用另一种实现来替换它是非常困难的，或者是完全不可能的。特别是在单元测试领域，为了清晰起见，这里会出现困难，所以现在服务定位器在某些情况下被归类为反模式。",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "在依赖注入中，没有任何东西被请求，但它是由用户明确提供或由代码接收。从控制反转的例子中可以看出，依赖注入模式已经在那里得到了应用。具体来说，在这里可以看到构造函数注入，因为依赖关系是在构造函数中声明的。所以UserRepository现在必须如下使用。",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes mal neu erstellt oder jedes mal der selbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "想要使用UserRepository的代码也必须提供（注入）所有的依赖。每次是否要重新创建HttpClient，或者每次是否要使用同一个HttpClient，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被要求（从类的角度），或者在最初的例子中，完全由类本身创建。这种倒置的流程有各种优点：",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "但也可以直接认识到一个明显的缺点。我真的要自己创建或管理像HttpClient这样的所有依赖性吗？是的，有很多情况下，自己管理依赖关系是完全合法的。一个好的API的特点是，依赖性不会失控，即使如此，它们仍然是令人愉快的使用。对于许多应用程序或复杂的库，这很可能是一种情况。",
        "Dependency Injection Container": "依赖注入容器",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "另一方面，对于更复杂的应用程序，没有必要自己管理所有的依赖，因为这正是所谓的依赖注入容器的作用。这不仅自动创建了所有的对象，而且还自动 \"注入 \"了依赖关系，这样就不再需要手动调用 \"新建 \"了。有各种类型的注入，如构造函数注入、方法注入或属性注入。",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "依赖注入容器（也称为DI容器或IoC容器）在`@deepkit/injector`中随Deepkit一起提供，或者已经通过Deepkit框架中的应用模块集成。使用`@deepkit/injector`包中的低级API，上面的代码会是这样的。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "本例中的`injector`对象是依赖注入容器。容器没有使用`new UserRepository`，而是使用`get(UserRepository)`返回UserRepository的实例。为了静态地初始化容器，一个提供者的列表被传递给函数`InjectorContext.forProviders`（在这种情况下只是简单的类）。",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "由于DI是关于提供依赖关系的，容器被提供了依赖关系，因此技术术语为 \"提供者\"。有各种类型的提供者：ClassProvider、ValueProvider、ExistingProvider、FactoryProvider。",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "提供者之间的所有依赖关系都被自动解决，一旦发生`injector.get()`调用，对象和依赖关系就会被创建、缓存，并正确地作为构造函数参数传递（构造函数注入）、设置为属性（属性注入）或传递给方法调用（方法注入）。",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "为了与另一个HttpClient交换，可以为HttpClient定义另一个提供者（这里是ValueProvider）：",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "一旦UserRepository通过`injector.get(UserRepository)`被请求，它就会收到另一个HttpClient对象。",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "所有类型的提供者都在<<dependency-injection-providers>>部分列出并解释。",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "在这一点上值得一提的是，Deepkit的DI容器只适用于Deepkit的运行时类型。这意味着任何包含类、类型、接口和函数的代码都必须经过Deepkit类型编译器的编译，以便在运行时获得类型信息。参见<<runtime-types>>一章。",
        "Dependency Inversion": "依赖反转",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "控制反转下的UserRepository的例子显示，UserRepository依赖于一个较低的层次，即一个HTTP库。此外，一个具体的实现（类）而不是抽象的（接口）被声明为依赖关系。乍一看，这似乎符合面向对象的范式，但它可能会导致问题，特别是在复杂和大型的架构中。",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "两个实现（UserRepository与HTTP库）的合并现在可以通过DI容器完成。",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "由于Deepkit的DI容器能够解决抽象的依赖关系（接口），例如在这种情况下，UserRepository自动获得HttpClient的实现，因为HttpClient已经实现了接口HttpClientInterface。这可以通过HttpClient专门实现HttpClientInterface（`class HttpClient implements HttpClientInterface`），或者通过HttpClient的API仅仅与HttpClientInterface兼容来实现。",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "一旦HttpClient改变了它的API（例如，删除了`get'方法），从而不再与HttpClientInterface兼容，DI容器就会抛出一个错误（\"没有提供HttpClientInterface的依赖性\"）。",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "在这里，想要将两种实现结合起来的用户不得不找到一种解决方案。作为一个例子，可以在这里注册一个适配器类，它实现了HttpClientInterface并正确地将方法调用转发给HttpClient。",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip sein Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "这里应该注意的是，尽管在理论上，依赖反转原则有其优点，但在实践中，它也有相当的缺点。例如，这不仅会导致更多的代码（因为必须编写更多的接口），而且还会导致更多的复杂性（因为现在每个实现都有一个接口来处理每个依赖关系）。只有当应用达到一定规模，并且还需要这种灵活性时，这种代价才是值得的。像每一个设计模式和原则一样，这个模式也有它的成本使用因素，在应用之前应该考虑清楚。",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "设计模式不应该盲目地用于每一个代码，无论多么简单。然而，如果有复杂的架构、大型应用程序或扩展团队等先决条件，依赖反转和其他设计模式才会展开其真正的力量。",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "由于Deepkit中的依赖注入是基于运行时类型的，因此有必要将`@deepkit/type`已经正确安装。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果已经成功完成，`@deepkit/injector`可以自行安装，或者安装已经使用该库的Deepkit框架的引擎。",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "一旦库被安装，可以直接使用其中的API。",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "现在要使用依赖注入，有三种可能性。",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "如果`@deepkit/injector`要在没有Deepkit框架的情况下使用，推荐使用前两种变体。",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "在依赖注入的介绍中已经介绍了Injector API。它的特点是使用非常简单，通过单一的`InjectorContext`类来创建一个DI容器，特别适合于没有模块的简单应用。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "本例中的`injector`对象是依赖注入容器。在这种情况下，函数`InjectorContext.forProviders`接收一个提供者的数组。",
        "Module API": "模块API",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hiararchie und schön separierte Architektur aufzubauen.": "一个稍微复杂的API是 \"InjectorModule \"类，它允许在不同的模块中交换提供者，以便为每个模块创建多个封装的DI容器。这也允许每个模块使用配置类，这使得自动向提供者提供经过验证的配置值更加容易。模块之间可以相互导入，并导出提供者，以建立一个层次分明、分离良好的架构。",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "如果应用程序比较复杂，并且没有使用Deepkit框架，就应该使用这个API。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "这种情况下的`injector`对象是依赖注入容器。提供者可以被分割成不同的模块，然后可以用模块导入的方式将它们重新导入到不同的地方。这创建了一个自然的层次结构，映射了应用程序或架构的层次结构。",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "InjectorContext应该总是被赋予层次结构中的顶级模块，也称为根模块或应用模块。然后InjectorContext只有一个中间任务：对`injector.get()`的调用被简单地转发给根模块。然而，非根模块的提供者也可以通过传递模块作为第二个参数来获得。",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "所有非根模块都被默认封装，因此这个模块中的所有提供者只对它自己有效。如果一个提供者要对其他模块可用，这个提供者必须被导出。",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden.": "要想把所有的提供者默认导出到顶层，即根模块，可以使用选项`forRoot`。",
        "App API": "App API",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, so dass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "只要使用Deepkit框架，就可以用`@deepkit/app`的API定义模块。这是基于模块API的，所以那里的能力也是可用的。此外，还可以使用强大的钩子和定义配置加载器来映射更多的动态架构。",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "<framework-modules>一章对此有更详细的描述。",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "在依赖注入容器中，有几种方法来提供依赖。最简单的变体是简单地指定一个类。这也被称为短的ClassProvider。",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "这代表一个特殊的提供者，因为只指定了类。",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes mal neu ausgeführt werden.": "默认情况下，所有的提供者都被标记为单子，因此在任何时候都只有一个实例存在。要在每次提供的时候创建一个新的实例，可以使用`transient`选项。这将导致每次都要重新创建类，或者每次都要执行工厂。",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "除了简短的ClassProvider，还有普通的ClassProvider，它是一个对象字面，而不是一个类。",
        "Dies ist Äquivalent zu diesen beiden:": "这相当于这两个：",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "它可以用来将一个提供者与另一个类交换。",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "在这个例子中，`OtherUserRepository'类现在也在DI容器中被管理，它的所有依赖关系都被自动解决。",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "静态值可以用这个提供者提供。",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "因为不仅是类实例可以作为依赖关系提供，任何值都可以被指定为`useValue'。符号或基元（字符串、数字、布尔）也可以作为提供者标记。",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "基元提供者标记必须作为依赖关系与注入类型一起声明。",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängikeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "通过注入别名和基元提供者标记的结合，也可以从不包含运行时类型信息的包中提供依赖关系。",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "然后在用户端声明如下：",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "可以定义一个已经定义的提供者的重定向。",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfigurations-Optionen zugreifbar.": "可以用一个函数来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "除了类和基元之外，还可以提供抽象（接口）。这是用`provide`函数完成的，当要提供的值不包含任何类型信息时特别有用。",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "如果几个提供者实现了接口连接，则使用最后一个提供者。",
        "Als Argument für provide() sind alle anderen Provider möglich.": "所有其他提供者都可以作为provide()的参数。",
        "Constructor/Property Injection": "构造器/属性注入",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "在大多数情况下，使用构造器注入。所有的依赖被指定为构造函数参数，并由DI容器自动注入。",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "可选的依赖应该被标记为这样，否则如果找不到提供者，可能会引发错误。",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "构造函数注入的一个替代方法是属性注入。这通常是在依赖关系是可选的或者构造函数太满的情况下使用。一旦实例被创建（也就是构造函数被执行），这些属性就会被自动分配。",
        "Konfiguration": "配置",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "依赖注入容器也允许注入配置选项。这种配置注入可以通过构造函数注入或属性注入来接收。",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "模块API支持定义配置定义，它是一个普通的类。通过为这样的类提供属性，每个属性都作为一个配置选项。",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "配置选项`domain`和`debug`现在可以方便地以类型安全的方式在提供者中使用。",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "选项本身的值可以通过`configure()`来设置。",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem \"!\" versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "没有默认值但仍然需要的选项可以用\"！\"来标记。这迫使模块的用户提供该值，否则将导致错误。",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "同时，前几章的所有序列化和验证类型<<validation>>和<<serialisation>>可以用来非常详细地指定一个选项必须有哪些类型和内容限制。",
        "Injection": "注入",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "配置选项可以像其他依赖关系一样通过DI容器安全而容易地注入，如前所示。最简单的方法是使用索引访问操作符来引用单个选项：",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "配置选项不仅可以单独引用，还可以作为一个组来引用。为此，使用了TypeScript实用类型`Partial`：",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "为了获得所有的配置选项，也可以直接引用配置类：",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "然而，建议只引用实际使用的配置选项。这不仅简化了单元测试，也使我们更容易从代码中看到实际需要的东西。",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "默认情况下，DI容器的所有提供者是一个单子，因此只被实例化一次。这意味着在UserRepository的例子中，在整个运行时间内，始终只有一个UserRepository的实例。在任何时候都不会创建第二个实例，除非用户用 \"new \"关键字手动创建。",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "然而，在各种使用情况下，一个提供者应该只在短时间内或只在某一事件中被实例化。这样的事件可以是，例如，一个HTTP请求或一个RPC调用。这就意味着每次事件发生时都会创建一个新的实例，在这个实例不再被使用后，它会被自动删除（由垃圾收集器）。",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "一个HTTP请求是一个典型的作用域的例子。例如，诸如会话、用户对象或其他与请求有关的提供者可以被注册到这个范围。要创建一个作用域，只需选择一个任意的作用域名称，然后用提供者来指定它。",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "一旦指定了一个作用域，就不能再直接通过DI容器获得该提供者，所以下面的调用失败了：",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedesmal geschehen sobald ein HTTP-Request reinkommt:": "相反，必须创建一个作用域的DI容器。这将在每次HTTP请求进来时发生：",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "在这个范围内的DI容器上，现在也可以请求也在这个范围内注册的提供者，以及所有没有定义范围的提供者。",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "由于所有的提供者默认是单子，每次调用`get(UserSession)`将总是返回每个范围内容器的相同实例。如果你创建了多个作用域的容器，也将创建多个UserSessions。",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "与Deepkit框架一起工作的应用程序默认有一个`http`、一个`rpc`和一个`cli`作用域。请分别参阅<<cli>>、<<http>>或<<rpc>>一章。",
        "Setup Calls": "设置调用",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "设置调用允许你操纵一个提供者的结果。这很有用，例如，使用另一种依赖注入的变体，方法注入。",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "设置调用只能分别用于模块API或应用API，并在模块之上注册。",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "`setupProvider`方法返回一个UserRepository的代理对象，其方法可以被调用。应该注意的是，这些方法调用只是被放在一个队列中，此时并没有被执行。相应地，也没有返回值。",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "除了方法调用，还可以设置属性。",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "这种赋值也只放在队列中。",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "队列中的调用或赋值，一旦被创建，就在提供者的实际结果上执行。也就是说，在ClassProvider的情况下，一旦实例被创建，它们就被应用到类实例上，在FactoryProvider的情况下，它们被应用到工厂的结果上，而在ValueProvider的情况下，它们被应用到提供者上。",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "为了不仅引用静态值，也引用其他提供者，可以使用函数`injectorReference`。这将返回一个对提供者的引用，这也是DI容器在执行设置调用时的请求。",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Interfaces也可以被分配设置调用。",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "命令行接口（CLI）程序是通过终端以文本输入和文本输出形式进行交互的程序。",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Deepkit中的CLI应用程序可以完全访问DI容器，因此可以访问所有提供者和配置选项。",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Dekoratoren, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI框架允许你根据简单的类来轻松注册自己的命令。事实上，它是以`@deepkit/app`为基础的，这是一个专门用于此目的的小包，也可以独立使用，不需要Deepkit框架。在这个包中，你将找到装饰CLI控制器类所需的装饰器。",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "控制器是由依赖注入容器管理或实例化的，因此可以使用其他提供者。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit中的CLI程序是基于运行时类型的，因此必须已经正确安装@deepkit/type。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果成功完成，可以安装@deepkit/app或Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "注意，`@deepkit/app`是基于TypeScript装饰器的，该功能必须通过`experimentalDecorators`相应启用。",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "为了给你的应用程序创建一个命令，你需要创建一个CLI控制器。这是一个简单的类，它有一个方法`exeecute`，并配备了关于命令的信息。",
        "_Datei: app.ts_": "_文件：app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "在装饰器`@cli.controller`中，CLI应用程序的唯一名称被定义为第一个参数。进一步的选项，如描述，可以选择在对象中的第二个位置添加。",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "这段代码已经是一个完整的CLI应用程序，可以像这样启动：",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "你可以看到，一个 \"测试 \"命令可用。要运行这个，必须将名称作为参数传入：",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "也可以用`chmod +x app.ts`使文件可执行，这样`./app.ts`命令已经足以启动它。应该注意的是，这时需要一个所谓的",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "shebang。Shebang指的是脚本程序开始时的字符组合`#！`。在上面的例子中，已经出现了：`&#35;!/usr/bin/env ts-node-script`，并且使用了`ts-node`的脚本模式。",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "通过这种方式，可以创建和注册任何数量的命令。在`@cli.controller`中给出的唯一名称应该选择得当，并允许用`:`字符对命令进行分组（例如，`user:create`，`user:remove`，等等）。",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "为了添加参数，新参数被添加到`execute`方法中，并用`@arg`装饰器进行装饰。",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "如果你现在执行这个命令而没有指定一个名字，将会产生一个错误：",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "使用`--help`会给你更多关于所需参数的信息：",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "一旦名字被作为参数传递，TestCommand中的`execute`方法将被执行，名字将被正确传递。",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags是另一种向命令传递数值的方式。通常这些是可选的，但不一定是。用`@flag name`装饰的参数可以通过`--name value`或`--name=value`传递。",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "在帮助视图中，你现在可以在 \"OPTIONS \"中看到一个`--id`标志是必要的。如果指定正确，命令就会收到这个值。",
        "Boolean Flags": "布尔标志",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "标志的优点是，它们也可以作为无值标志使用，例如，激活某种行为。只要一个参数被标记为可选的布尔值，这个行为就会被激活。",
        "Multiple Flags": "多个标志",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "为了向同一个标志传递多个值，可以将一个标志标记为一个数组。",
        "Single Character Flags": "单字符标志",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "为了让标志也能以单字符形式传递，可以使用`@flag.char('x')`。",
        "Optional / Default": "可选/默认",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "`execute`方法的签名定义了哪些参数或标志是可选的。如果参数被标记为可选，则不需要指定。",
        "The signature of the method `execute` defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "方法`执行'的签名定义了哪些参数或标志是可选的。如果该参数在类型系统中是可选的，那么用户就不必提供它。",
        "Dasselbe für Parameter mit einem Default-Wert:": "有默认值的参数也是如此：",
        "Dies gilt auch für Flags in derselben Art und Weise.": "这也以同样的方式适用于标志。",
        "Serialization / Validation": "序列化/验证",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "所有的参数和标志都会根据它们的类型自动反序列化，进行验证，并且可以提供额外的限制。",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "所以定义为数字的参数在控制器中总是被保证为实数，尽管命令行界面是基于文本的，因此是字符串。",
        "Zusätzliche Einschränkungen können mit den Typen-Dekoratoren aus `@deepkit/type` definiert werden.": "额外的限制可以通过`@deepkit/type`的类型装饰器来定义。",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "`id`的`Postive`类型表示只需要正数。如果用户现在传递一个负数，`执行'中的代码根本不被执行，并出现一个错误信息。",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "如果数字是正数，这时又像以前一样工作。这种额外的验证是非常容易做到的，它使命令对错误的条目更加强大。",
        "Description": "描述",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "为了描述一个标志或参数，可以使用`@flag.description`或`@arg.description`。",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "在帮助视图中，这个描述出现在标志或参数的后面：",
        "Exit code": "退出代码",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "退出代码默认为0，这意味着命令被成功执行。要改变退出代码，应该在`exucute`方法中返回一个非0的数字。",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "命令的类由DI容器管理，所以可以定义依赖关系，通过DI容器解决。",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "处理HTTP查询有时是服务器最著名的任务。它将输入（HTTP请求）转换为输出（HTTP响应），并执行一项特定的任务。客户端可以通过HTTP请求以各种方式向服务器发送数据，这些数据必须被正确读取和处理。除了HTTP主体外，HTTP查询或HTTP头值也是可能的。数据如何被实际处理取决于服务器。",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "这里的首要任务不仅是正确执行用户期望的内容，而且要正确转换（反序列化）和验证来自HTTP请求的任何输入。",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "HTTP请求在服务器上通过的管道可能是多样化和复杂的。许多简单的HTTP库只是简单地传递给定路由的HTTP请求和HTTP响应，并期望开发者直接处理HTTP响应。一个中间件API允许管道根据需要进行扩展。",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte bzw Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den User damit eine Architektur selbst obendrauf zu setzen, die einem diese zwingenden Funktionalitäten abnimmt.": "这对简单的用例来说是非常合适的，但随着应用的增长，很快就会变得混乱，因为所有的输入和输出都必须手动进行序列化或反序列化并进行验证。还有必要考虑如何从应用程序本身获得对象或服务，如数据库抽象。",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection: Serialisierung bzw Deserialisierung und Validierung von jeglichen Werten passiert automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer gewählten Architektur abzudecken.": "Deepkit的HTTP库使用了TypeScript和依赖注入的力量：序列化或反序列化以及任何数值的验证都是根据定义的类型自动进行的。",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "它还允许你通过一个功能性的API来定义路由，就像上面的例子一样，或者通过控制器类来覆盖所选架构的不同需求。这两种API变体都可以访问依赖性注入容器，因此可以方便地从应用程序中获得数据库抽象和配置等对象。",
        "_Deepkit Beispiel_": "_Deepkit 示例_",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，必须用`experimentalDecorators`相应启用该功能。",
        "Funktionale API": "功能API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "功能API是基于函数的，可以通过路由器注册表注册，可以通过应用程序的DI容器获得。",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "路由器注册表也可以在事件监听器或引导中获得，这样就可以根据模块、配置和其他提供者注册各种路由。",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "一旦使用了模块，功能路由也可以由模块动态提供。",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "参见<<framework-modules>>一章，了解更多关于App Modules的信息。",
        "Controller API": "控制器API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "控制器API基于类，可以通过App API在`controllers`选项下注册。",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "一旦使用了模块，控制器也可以由模块提供。",
        "HTTP Server": "HTTP服务器",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "如果使用Deepkit Framework，已经内置了一个HTTP服务器。然而，HTTP库也可以在不使用Deepkit框架的情况下使用自己的HTTP服务器。",
        "HTTP Client": "HTTP客户端",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name that can be referenced in a redirect.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "路由器函数以及控制器类和控制器方法可以定义任意的依赖关系，由依赖注入容器来解决。",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "例如，如果一个数据库作为提供者被提供，它可以被注入：",
        "_Funktionaler API:_": "_功能型API:_",
        "_Controller API:_": "_控制器API:_",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "更多信息见<<依赖-注入>>一章。",
        "Input": "输入",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "以下所有的输入变化对功能型和控制器API的功能都是一样的。",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "这不仅大大提高了安全性，而且还简化了单元测试，",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "因为严格来说，为了测试路由，甚至不需要存在一个HTTP请求对象。",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "所有参数都被自动转换（反序列化）为定义的TypeScript类型并进行验证。这是通过`@deepkit/type`包及其<<序列化>>和<<验证>>功能完成的。",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "为了简单起见，下面展示了所有带有功能API的例子。",
        "Path Parameters": "路径参数",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "路径参数是从路由的URL中提取的值。",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "转换是使用<<serialisation-loosely-conversion>>功能自动完成的。",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "如果一个路径参数被定义为字符串以外的类型，它将被正确转换。",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "额外的验证约束也可以应用于该类型。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>一章。",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "路径参数在URL匹配时默认设置为`[^/]+`正则表达式。这方面的正则表达式可以调整如下：",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "这只有在特殊情况下才需要，因为通常情况下，与验证类型本身相结合的类型已经正确地限制了可能的值。",
        "Query Parameters": "查询参数",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "查询参数是URL中`?`字符后面的值，可以用`HttpQuery<T>`类型读取。",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "查询参数的名称与查询参数的名称相对应。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>章节。",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*警告*。参数值没有被转义/消毒。在路由中直接以字符串的形式将它们作为HTML返回，会打开一个安全漏洞（XSS）。确保从不信任外部输入，并在必要时过滤/净化/转换数据。",
        "Query Model": "查询模型",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "由于有很多查询参数，很快就会变得混乱。",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "指定模型中的属性可以包含所有TypeScript类型和`@deepkit/type'支持的验证类型，只有在例如要在同一个路由中手动评估关于body的错误信息时才使用`HttpBodyValidation`。参见<<序列化>>和<<验证>>两章。",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "对于允许HTTP主体的HTTP方法，也可以指定一个主体模型。",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "来自HTTP请求的body内容类型必须是`application/x-www-form-urlencoded`、`multipart/form-data`或`application/json`，以便Deepkit自动将其转换为JavaScript对象。",
        "Manual Validation Handling": "手动验证处理",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "为了手动处理body模型的验证，可以使用一个特殊类型`HttpBodyValidation<T>`。它允许接收无效的主体数据，并对错误信息作出非常具体的反应。",
        "Sobald valid() den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "一旦valid()返回值`false`，指定模型中的值可能处于错误的状态。这意味着验证失败。如果没有使用`HttpBodyValidation`，并且收到了一个不正确的HTTP请求，该请求将被直接中止，函数中的代码将永远不会被执行。",
        "File Upload": "文件上传",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "主体模型上的一个特殊的属性类型可以用来允许客户端上传文件。可以使用任何数量的`UploadedFile`。",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "默认情况下，路由器将所有上传的文件存储在一个临时文件夹中，一旦路由中的代码被执行，就将其删除。因此，有必要读取`path`中指定路径的文件，并将其保存到一个永久的位置（本地硬盘、云存储、数据库）。",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet werden, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "HTTP服务器中的验证是一个强制性的功能，因为它几乎总是涉及到不能信任的数据工作。数据验证的地方越多，服务器就越稳定。HTTP路由中的验证可以方便地通过类型和验证约束来使用，并通过来自`@deepkit/type`的高度优化的验证器进行检查，因此在这方面不存在性能问题。因此，强烈建议使用这些验证能力。",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "所有的输入，如路径参数、查询参数和主体参数都会自动验证为指定的TypeScript类型。如果通过`@deepkit/type`的类型指定了额外的约束，这些约束也会被检查。",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "关于这方面的更多信息，请看<<validation>>章节。",
        "Output": "输出",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "路由可以返回各种数据结构。其中一些是以特殊的方式处理的，如重定向和模板，而其他的，如简单的对象，只是作为JSON发送。",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "默认情况下，正常的JavaScript值会以JSON形式返回给客户端，标题为`application/json; charset=utf-8`。",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "如果在函数或方法中指定了明确的返回类型，那么数据将根据该类型被Deepkit JSON序列化器序列化为JSON。",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "要发送HTML，有两种可能。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "带TSX的Template-Engine变体的优点是使用的变量会自动进行HTML转义。见<<template>>一章。",
        "Custom Content": "自定义内容",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "除了HTML和JSON，还可以发送具有特定内容类型的文本或二进制数据。这是通过对象`Response`",
        "Zusätzliche Header": "Additional Header",
        "Um den Header einer Antwort zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "来改变响应的头，可以在对象`Response`、`JSONResponse`和`HTMLResponse`上调用其他方法。",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "要返回301或302重定向作为响应，可以使用`Redirect.toRoute`或`Redirect.toUrl`。",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "这里的`Redirect.toRoute`方法使用路由的名称。如何设置路由名称可以在<<http-route-name>>部分看到。如果这个被引用的路由（查询或路径）包含参数，这些参数可以通过第二个参数指定：",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "或者，用`Redirect.toUrl`重定向到一个URL。",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "默认情况下，两者都使用302重定向。",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "所有的HTTP控制器和功能路由都在`http`依赖性注入范围内管理。HTTP控制器为每个HTTP请求进行相应的实例化。这也意味着两者都可以访问为`http`范围注册的提供者。因此，另外来自`@deepkit/http`的`HttpRequest`和`HttpResponse`可以作为依赖关系使用。如果使用Deepkit Framework，`@deepkit/framework'中的`SessionHandler'也是可用的。",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "在`http'范围内放置提供者可能相当有用，例如为每个HTTP请求重新实例化服务。一旦HTTP请求被处理，`http`作用域的DI容器就会被删除，从而从垃圾收集器（GC）中清理掉所有的提供者实例。",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见<<依赖-注入-作用域>>一章，了解如何在`http`作用域中放置提供者。",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "HTTP模块基于一个工作流引擎，它提供了各种事件标记，可以用来钩住处理HTTP请求的整个过程。",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "工作流引擎是一个有限状态机，为每个HTTP请求创建一个新的状态机实例，然后从一个位置跳到另一个位置。第一个位置是 \"开始\"，最后一个是 \"回应\"。",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "每个事件标记都有自己的事件类型，并有额外的信息。",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "由于所有的HTTP事件都是基于工作流引擎的，它的行为可以通过使用指定的事件并通过`event.next()`方法跳转到那里来修改。",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "HTTP模块在这些事件标记上使用自己的事件监听器来实现HTTP请求的处理。所有这些事件监听器的优先级都是100，这意味着当你监听一个事件时，你的监听器将被默认首先执行（因为默认优先级是0）。",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "例如，假设你想捕捉一个控制器被调用的事件，那么你可以在HTTP模块的事件监听者之后添加一个高于100的优先级。如果一个特定的控制器要被调用，我们要检查用户是否有权限访问它。如果用户有权限，我们继续。但如果不是，我们就跳到下一个工作流程项目`accessDenied`。在那里，访问拒绝的程序会被自动进一步处理。",
        "Middleware": "中间件",
        "Resolver": "解析器",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "路由器支持一种解析复杂参数类型的方法。例如，给定一个路由，如`/user/:id`，这个`id`可以通过一个解析器解析到路由之外的`user`对象。这进一步解耦了HTTP抽象和路由代码，进一步简化了测试和模块化。",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "用户不一定要在这里依赖一个参数。它也可以依赖于会话或HTTP头，并且只在用户登录后提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，所以很多用例都可以通过这种方式进行映射。",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "原则上，也可以通过依赖注入容器从`http`范围提供复杂的参数类型，因为这些也可以在路由函数或方法中使用。然而，这有一个缺点，就是不能使用异步函数调用，因为DI容器自始至终都是同步的。",
        "RPC": "RPC",
        "Connection": "连接",
        "Entity": "实体",
        "Session": "会话",
        "Query": "查询",
        "Repository": "存储",
        "Relations": "关系",
        "Inheritance": "继承",
        "Index": "索引",
        "Case Sensitivity": "大小写敏感度",
        "Character Sets": "字符集",
        "Key/Value": "Key/Value",
        "Pub/Sub": "Pub/Sub",
        "Eine TSX basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "一个基于TSX的模板引擎，可以以一种类型安全的方式生成HTML。",
        "TypeScript ist Javascript das skaliert. Eine Sprache, die designt ist, komplexen Code zu schreiben. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Das führt oft dazu, dass TypeScript-Code nach dem Kompilieren wie normaler JavaScript-Code aussieht. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern während dem Entwickeln (spätestens jedoch bei dem Kompilieren) viel schneller und einfacher als würde das mit reinem JavaScript möglich sein und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许编写带有类型的JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "验证是任何应用程序的重要组成部分，使用一次太频繁比一次太少好。Deepkit提供了许多验证选项，并有一个高性能的实现，所以在绝大多数情况下，不需要担心执行时间。",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "CLI应用程序的参数和选项由方法参数通过TypeScript类型控制，并自动进行序列化和验证。",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI是Deepkit Framework应用程序的三个入口点之一。在Deepkit框架中，应用程序总是通过CLI程序启动，该程序本身是由用户用TypeScript编写的。因此，没有针对Deepkit的全局CLI工具来启动Deepkit应用程序。这是你启动HTTP/RPC服务器、执行迁移或运行你自己的命令的方式。这都是通过同一个入口点，同一个文件完成的。一旦通过从`@deepkit/framework`中导入`FrameworkModule`来使用Deepkit框架，应用程序就会得到应用服务器、迁移等的额外命令。",
        ":stem[\\documentclass[UTF8]{ctexart}]": ":stem[/documentclass[UTF8]{ctexart}]",
        "Benutzung": "使用",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "依赖注入（DI）是一种设计模式，其中类和函数_receive_ their dependencies。它遵循反转控制（IoC）的原则，有助于更好地分离复杂的代码，以提高可测试性、模块化和清晰度。尽管还有其他设计模式，如服务定位器模式，来应用IoC的原则，但DI已经确立了自己的主导模式，特别是在企业软件中。",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的JavaScript。一种旨在实现复杂用例的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这种类型的安全允许更容易编写和维护复杂的应用程序。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript现在是世界上最大的开发者社区，它为开发者提供了相应的大量选择，包括许多库和工具，以满足项目的需要。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念、API和代码质量差别很大，以至于开发人员必须引入大量的粘性代码和额外的抽象，以使这些库能够相互正常工作。近几十年来，制造商或社区将几乎每个项目都需要的核心功能放在漂亮的抽象化的库中，并将其汇集到一个框架中，这已经一次又一次地证明了自己。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念以库或组件的形式实现，这样就可以根据需要方便地相互协调使用。所提供的功能和设计模式不是立方体，而是基于有时是几十年前的概念，并在与其他想法的竞争中证明了自己。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译过程中完全删除了其类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中或运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据在运行时被转换/序列化、数据被验证、元信息被添加到对象或需要接口信息的情况下，这个值会被反映出来。在这些和其他许多用例中，类型信息在运行时可能非常有用，因为它为库提供了必要的信息以有效地提供功能。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，并迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里不能再发挥其优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种范式的转变，Deepkit为几乎所有程序中都能找到的用例开发了一整套库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发者需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Type Compiler": "类型编译器",
        "Typeninformation Empfangen": "接收类型信息",
        "Validate&lt;typeof MyValidator&gt;": "Validate&lt;typeof MyValidator&gt;",
        "Pattern&lt;typeof MyRegexp&gt;": "Pattern&lt;typeof MyRegexp&gt;",
        "Decimal&lt;number, Number&gt;": "Decimal&lt;number, Number&gt;",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "有些语言比其他语言更适合于应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在其核心中使用，但有一些限制，大量损害用户体验，从而影响速度。例如，如果一个依赖注入框架指定并基于它们，那么Typescript装饰器及其所有的特异性可能成为必要的。",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "代码可以在部门之间共享（前端、后端、微服务等）。",
        "Models, Typen und Interfaces": "模型、类型和接口",
        "Business logic": "业务逻辑",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "单一包管理器的统一审计系统。",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "在所有部门中重复使用熟悉的第三方库。",
        "Wissensteilung innerhalb der Teams.": "团队内的知识共享。",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "招聘简化为一个群体（而且是最大的群体：JavaScript开发人员）。",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "在运行时在TypeScript中提供类型信息变化很大。它允许采用新的工作方式，而这在以前只能以迂回的方式或根本不可能实现。声明类型和模式已经成为现代开发过程中的一个重要部分。GraphQL、验证器、ORM、ProtoBuf等编码器以及其他许多东西都依赖于在运行时有模式信息可用，以提供基本功能。这些工具和库有时需要开发人员学习全新的语言，这些语言是专门为使用情况开发的。例如，ProtoBuf和GraphQL有自己的声明语言，验证器通常基于自己的模式API，甚至是JSON模式，这也是一种独立的定义结构的方式。其中一些需要在每次更改时运行代码生成器，以便将模式信息也提供给运行时。另一个著名的模式是使用实验性的TypeScript装饰器，在运行时向类提供元信息。",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "`message`是字符串类型，返回类型是`void`类型的信息不再可用了。",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "运行时类型信息默认不生成。必须在`tsconfig.json`文件中设置`\"反射\": true`，以便在这个文件的同一文件夹中的所有文件或所有子文件夹中启用它。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript本身不允许你通过`tsconfig.json'来配置类型编译器，这对于使用`@deepkit/type'并不是严格必要的，但对于其他deepkit库和`@deepkit/framework'中的某些功能是必要的。有必要直接使用TypeScript编译器API或像Webpack这样的构建系统与_ts-loader_。为了给Deepkit用户省去这个不方便的路径，Deepkit类型编译器一旦安装了`@deepkit/type-compiler`，就会自动安装在`node_modules/typescript`中（这是通过NPM安装挂钩完成的）。",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "如果类型编译器不能成功地自动安装（例如，因为NPM安装钩子被禁用），这可以通过以下命令手动完成：",
        "Typen-Decorators": "类型装饰器",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "类型装饰器是正常的TypeScript类型，包含元信息，可以在运行时改变各种函数的行为。Deepkit已经提供了一些类型装饰器，涵盖了一些使用情况。例如，一个类属性可以被标记为主键、引用或索引。数据库库可以在运行时使用这些信息来创建正确的SQL查询，而不需要事先生成代码。",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Validator约束，如`MaxLength`、`Maximum`或`Positive`，也可以添加到任何类型。也可以告诉序列化器如何序列化或反序列化一个特定的值。此外，还可以创建完全自定义的类型装饰器，并在运行时读取这些装饰器，从而可以在运行时非常自定义地使用类型系统。",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit带有一整套类型装饰器，所有这些都可以直接从`@deepkit/type`中使用。它们被设计成不来自多个库，这样就不会把代码直接绑在某个特定的库上，如Deepkit RPC或Deepkit数据库。这使得类型的重用更加容易，即使是在前端，即使使用了数据库类型装饰器。",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "下面是现有类型装饰器的列表。`@deepkit/type`和`@deepkit/bson`的验证器和序列化器以及`@deepkit/orm`的Deepkit数据库以不同的方式使用这一信息。请参阅相关章节了解更多。",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Integer和floats被定义为基数`number`，并有几个子变量：",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "这里，在运行时，用户的`id`是一个数字，但在验证和序列化时被解释为一个整数。",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "这意味着在这里，例如，浮点数可能不会被用于验证，序列化器会自动将浮点数转换为整数。",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "子类型可以以同样的方式使用，如果要允许一定范围的数字，子类型是很有用的。",
        "Float": "Float",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4通常在数据库中存储为二进制，在JSON中存储为字符串。",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "将此字段标记为MongoDB的ObjectId。解决为一个字符串。",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save as bigint in JavaScript has a unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the BinaryBigInt is available.": "默认情况下，普通的bigint类型在JSON中序列化为数字（在BSON中序列化为长）。然而，这对可能保存的内容有限制，因为JavaScript中的bigint有无限的潜在大小，而JavaScript中的数字和BSON中的long是有限的。",
        "Same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (abs(x)).": "与bigint相同，但在数据库中序列化为无限大小的无符号二进制（而不是大多数数据库中的8字节），在JSON中为字符串。负值将被转换为正值（abs(x)）。",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM将BinaryBigInt存储为二进制字段。",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "在序列化中改变一个属性的名称。",
        "Group": "Group",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "属性可以被归为一组。对于序列化，你可以将一个组排除在序列化之外。",
        "Data": "Data",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "每个属性都可以添加额外的元数据，可以通过Reflection API读取。",
        "Excluded": "Excluded",
        "Each property can be excluded from the serialization process for a specific target.": "每个属性都可以从特定目标的序列化过程中排除。",
        "Embedded": "Embedded",
        "Marks the field as an embedded type.": "将字段标记为嵌入式类型。",
        "It's possible to change the prefix (which is per default the property name).": "可以改变前缀（默认是属性名称）。",
        "To annotate interfaces with entity information. Only used in the database context.": "用实体信息注释接口。",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Siehe dazu Kapitel Validation <<validation-constraint-types>>.": "See chapter Validation <<validation-constraint-types>>。",
        "Benutzerdefinierte Type-Decorators": "用户定义的类型装饰器",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "一个类型装饰器可以定义如下：",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "按照惯例，一个类型装饰器被定义为一个对象字面，有一个单一的可选属性`__meta`，它的类型是一个元组。这个元组的第一个条目是它的唯一名称，所有进一步的元组条目是任何选项。这允许一个类型装饰器配备额外的选项。",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "类型装饰器与相交运算符`&`一起使用。",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "类型装饰器可以通过`typeOf<T>()`和`metaAnnotation`的类型对象读出：",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "如果使用了类型装饰器`myAnnotation`，`annotation`中的结果是一个带有选项的数组，如果没有则是`undefined`。如果类型装饰器有额外的选项，如在`AnnotationOption`中看到的那样，传递的值将在数组中找到。",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "已经提供的类型装饰器如`MapName`、`Group`、`Data`等都有自己的注释对象：",
        "Siehe das Kapitel <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "参见<<runtime-types-reflection>>章节以了解更多信息。",
        "External Classes": "外部类",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "由于TypeScript默认不包含类型信息，所以从其他包（没有使用@deepkit/type-compiler）导入的类型/类将没有类型信息。",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "要为一个外部类注释类型，请使用`annotateClass`，并确保这个函数在你的应用程序的引导阶段执行，然后再在其他地方使用导入的类。",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "`MyExternalClass`现在可以在序列化函数和反射API中使用。",
        "To following shows how to annotate generic classes:": "下面展示了如何注释通用类：",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "`MyType<string>`只要`Object`被计算，就被缓存。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "JIT Cache": "JIT缓存",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "将结果分配给同一个变量是很有用的，这样就不会不必要地创造一个新的变量。在`type`中，要么现在就存储一个类型对象，要么就抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有启用类型信息的发射（见上面的安装部分）。",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "为了详细了解Deepkit如何编码和读取JavaScript中的类型信息，本章的目的是。它解释了类型实际上是如何被转换为字节码的，在JavaScript中发出，然后在运行时解释。",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "在写这篇文章时，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，可以将TypeScript AST（抽象语法树）转化为另一个TypeScript AST。在这个过程中，Deepkit的类型编译器会读取AST，产生相关的字节码，并将其插入AST中。",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "现有的命令本身每个都是一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`的枚举。在写这篇文章的时候，命令集的规模超过81条。",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "为了防止命名冲突，每个类型都有一个\"__Ω \"作为前缀。对于每个明确定义的、被导出的或被导出的类型所使用的类型，一个字节码会发射出JavaScript。",
        "Error Reporting": "错误报告",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "函数`is`、`assert`和`validates`返回一个布尔值作为结果。为了获得验证规则失败的确切信息，可以使用函数`validate`。如果所有东西都被成功验证，它将返回一个空数组。如果出现错误，数组包含一个或多个条目，其结构如下：",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "该函数接收作为第一类型参数的任意TypeScript类型和作为第一参数的要验证的数据。",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "复杂的类型如接口、类或泛型也可以在这里使用。",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "这些限制通过类型装饰器添加到实际类型中。有一整套可以使用的装饰器。如果需要扩展，可以随意定义和使用自定义装饰器。",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "任何数量的类型装饰器都可以用`&`添加到实际类型中。结果，这里是`username'，然后可以在所有的验证函数中使用，也可以在其他类型中使用。",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "在JavaScript中，序列化通常是在JavaScript对象和JSON之间。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），如果服务器将数据作为JSON发送给客户端，则反之亦然。使用`JSON.parse`和`JSON.stringify`往往不能满足这个要求，因为它不是无损的。",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "注意，虽然蚕食者也会验证数据的兼容性，但这些验证与<<validation>>章节的验证不同。只有`cast'函数在反序列化成功后还会调用<<validation>>章节中的完整验证过程，如果数据无效就会抛出一个错误。",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "当错误发生时，来自序列化和验证的所有函数都会从`@deepkit/type'抛出一个`ValidationError'。",
        "Cast": "Cast",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "反序列化过程中实现了软类型转换。这意味着字符串类型的字符串和数字或字符串类型的数字可以被接受并自动转换。这很有用，例如，当数据通过一个URL被接受并传递给反序列化器时。由于URL总是一个字符串，Deepkit Type仍然会尝试解决Number和Boolean的类型。",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "以下软类型转换已经内置于JSON序列化器中：",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*。Number或Bigint接受String、Number和BigInt。 如果需要转换，它将使用`parseFloat`或`BigInt(x)`。",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*:布尔型接受数字和字符串。0，'0'，'false'被解释为`false'。1，'1'，'真'被解释为`真'。",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*字符串*。字符串接受Number、String、Boolean等。所有非字符串的值都会自动用`String(x)`转换。",
        "Type-Decorators": "Type-Decorators",
        "Integer": "Integer",
        "Mapped": "Mapped",
        "Naming Strategy": "Naming Strategy",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": " UserRepository类有一个HttpClient作为依赖。这个依赖关系本身并不显眼，但UserRepository自己创建了HttpClient，这就有问题了。这一点乍一看很明显，但它有其缺点。如果我们想替换掉HttpClient怎么办？如果我们想在单元测试中测试UserRepository，而不允许真正的HTTP请求出去呢？我们怎么知道这个类甚至使用了HttpClient？",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "除了DI，服务定位器（SL）也是应用IoC原则的一种方式。这通常被认为是与依赖性注入相对应的，因为它请求依赖性而不是接受它们。如果HttpClient在上述代码中被请求如下，它将被称为服务定位模式。",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "想要使用UserRepository的代码还必须提供（注入）它的所有依赖。是每次都要创建HttpClient还是每次都要使用同一个HttpClient，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被要求（从类的角度），或者在最初的例子中，完全由类本身创建。这种反转的流程有各种好处：",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "代码更容易理解，因为所有的依赖关系都是明确可见的。",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "它促进了关注点分离原则，因为UserRepository在有疑问时不再负责自己创建非常复杂的依赖。",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "高层模块不应该从低层模块中导入任何东西。",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "实现应该基于抽象（接口）。",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "这里应该指出，尽管在理论上，依赖反转原则有其优点，但在实践中，它也有很大的缺点。这不仅导致了更多的代码（因为必须编写更多的接口），而且还导致了更多的复杂性（因为现在每个实现都有一个接口用于每个依赖关系）。只有当应用达到一定规模，并且还需要这种灵活性时，这种代价才是值得的。像任何设计模式和原则一样，这个也有它的成本使用因素，在使用之前应该考虑清楚。",
        "Injector API (Low Level)": "Injector API (Low Level)",
        "App API (Deepkit Framework)": "App API (Deepkit Framework)",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "一个稍微复杂的API是`InjectorModule`类，它允许将提供者换成不同的模块，以便在每个模块中创建多个封装的DI容器。这也允许每个模块使用配置类，这使得自动向提供者提供经过验证的配置值更加容易。模块之间可以相互导入，导出提供者，以建立一个层次结构和良好的分离架构。",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "为了默认将所有提供者导出到顶层，即根模块，可以使用选项`forRoot`。",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "一旦使用了Deepkit框架，就可以使用`@deepkit/app` API来定义模块。这是基于模块API的，所以那里的能力也是可用的。此外，还可以使用强大的钩子和定义配置加载器来映射更多的动态架构。",
        "Providers": "提供者",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "默认情况下，所有提供者都被标记为单子，因此在任何时候都只存在一个实例。要在每次提供的时候创建一个新的实例，可以使用`transient`选项。这导致每次都要重新创建类，或者每次都要执行工厂。",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "没有默认值，但仍然是必要的选项，可以用`！`来提供。这迫使模块的用户提供该值，否则将导致错误。",
        "Scopes": "Scopes",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "相反，必须创建一个有范围的DI容器。每次有HTTP请求进来时都会发生这种情况：",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces*",
        "CLI": "CLI",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI框架允许你基于简单的类轻松注册自己的命令。事实上，它是以`@deepkit/app`为基础的，这个小包只是为了这个目的，也可以在没有Deepkit框架的情况下独立使用。这个包包含了装饰CLI控制器类所需的装饰器。",
        "Argumente": "Arguments",
        "Flags": "Flags",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "可以用`@deepkit/type`的类型装饰器来定义额外的约束。",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "这对简单的用例来说是非常合适的，但随着应用程序的增长，很快就会变得混乱，因为所有输入和输出都必须手动序列化或反序列化并进行验证。还必须考虑到如何从应用程序本身获得对象和服务，如数据库抽象。",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Deepkit的HTTP库利用了TypeScript和依赖注入的力量，迫使开发者在上面放置一个架构，以映射这些强制性功能。串行化/反串行化和任何值的验证都是根据定义的类型自动发生的。此外，它允许通过功能API（如上面的例子）或通过控制器类来定义路由，以涵盖架构的不同需求。",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "为了动态地提供控制器（例如，根据配置选项），可以使用`process`钩子。",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "从所有有名字的路由中，可以通过`Router.resolveUrl()`来请求URL。",
        "Body": "Body",
        "Header": "Header",
        "Stream": "Stream",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "一旦`valid()`返回`false`，指定模型中的值可能处于不正确状态。这意味着验证失败。如果没有使用`HttpBodyValidation`，并且收到了一个不正确的HTTP请求，该请求将被直接中止，函数中的代码将永远不会被执行。",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "HTTP服务器中的验证是一个强制性的功能，因为不值得信任的数据几乎总是被处理的。数据验证的地方越多，服务器就越稳定。HTTP路由中的验证可以方便地通过类型和验证约束来使用，并通过来自`@deepkit/type`的高度优化的验证器进行检查，因此在这方面不存在性能问题。因此，强烈建议使用这些验证能力。",
        "JSON": "JSON",
        "HTML": "HTML",
        "HTTP Errors": "HTTP错误",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "通过抛出各种HTTP错误，可以立即中断HTTP请求的处理，并输出错误的相应HTTP状态。",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "默认情况下，所有的错误都以JSON格式返回给客户端。这个行为可以根据需要在事件系统中的`httpWorkflow.onControllerError'事件下进行调整。参见<<http-events>>一节。",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "错误`HttpAccessDeniedError`是一个特殊情况。一旦它被抛出，HTTP工作流（见<<http-events>>）就不会跳到`controllerError'，而是跳到`accessDenied'。",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "用户定义的HTTP错误可以用`createHttpError'来创建和抛出。",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "为了改变HTTP响应的头，可以在对象`Response`、`JSONResponse`和`HTMLResponse`上调用其他方法。",
        "Redirect": "Redirect",
        "Scope": "Scope",
        "Events": "Events",
        "Sessions": "Sessions",
        "Controller": "Controller",
        "Server": "Server",
        "Client": "Client",
        "Authentication": "认证",
        "Transport Protocol": "传输协议",
        "WebSockets": "WebSockets",
        "TCP": "TCP",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Read Replica": "Read Replica",
        "Primitives": "Primitives",
        "Primary Key": "Primary Key",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Optional / Nullable",
        "Embedded Types": "Embedded Types",
        "Default Values": "Default Values",
        "Default Expressions": "Default Expressions",
        "Complex Types": "复杂类型",
        "Exclude": "排除",
        "Database Specific Column Types": "数据库特定列类型",
        "Session / Unit Of Work": "会话/工作单位",
        "Identity Map": "身份图",
        "Change Detection": "变化检测",
        "Request/Response": "请求/响应",
        "Find": "查找",
        "Filter": "过滤",
        "Equal": "相等",
        "Greater / Smaller": "较大/较小",
        "In": "In",
        "Order": "Order",
        "Pagination": "Pagination",
        "Aggregation": "Aggregation",
        "Join": "Join",
        "Returning": "Returning",
        "Patch": "Patch",
        "Delete": "Delete",
        "Lift": "Lift",
        "One To Many": "One To Many",
        "Many To Many": "Many To Many",
        "One To One": "One To One",
        "Constraints": "Constraints",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "On Delete/Update。RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Table Per Class": "Table Per Class",
        "Single Table Inheritance": "Single Table Inheritance",
        "Collations": "Collations",
        "Batching": "Batching",
        "Caching": "Caching",
        "Query Events": "Query Events",
        "Unit Of Work Events": "Unit Of Work Events",
        "Transactions": "Transactions",
        "Isolations": "Isolations",
        "Locking": "Locking",
        "Optimistic Locking": "Optimistic Locking",
        "Pessimistic Locking": "Pessimistic Locking",
        "Custom Types": "自定义类型",
        "Logging": "记录",
        "Migration": "迁移",
        "Seeding": "播种",
        "Raw Database Access": "原始数据库访问",
        "SQL": "SQL",
        "App Configuration": "App配置",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Publish / Subscribe": "Publish / Subscribe",
        "Template": "Template",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "一个基于服务器端TSX（JJS）的模板引擎。用它可以以一种类型安全的方式生成HTML。",
        "Components": "Components",
        "Function Components": "Function Components",
        "Class Components": "Class Components",
        "Dynamic HTML": "Dynamic HTML",
        "Optimization": "Optimisation",
        "Framework": "Framework",
        "Modules": "Modules",
        "Configuration": "Configuration",
        "Application Server": "Application Server",
        "Logger": "Logger",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Workflow",
        "Testing": "Testing",
        "Debugger": "Debugger",
        "Module": "Modules",
        "Profiler": "Profiler",
        "Deployment": "Deployment",
        "Compiling": "Compiling",
        "Packaging": "Packaging",
        "Docker": "Docker",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "但是，如果在运行时有一个类型系统，这些信息就可以保留下来，这样就可以通过程序读取消息的类型和返回类型。",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit正是让这成为可能。它与TypeScript的编译挂钩，确保所有的类型信息都内置于生成的JavaScript中。像typeOf()这样的函数（不要和运算符typeof混淆，小写的是o）就允许开发者访问它。因此，可以根据这些类型信息来开发库，使开发者可以将已经写好的TypeScript类型用于一系列的应用。",
        "UUID": "UID",
        "`SignedBinaryBigInt` is the same as BinaryBigInt but is able to store negative values as well.": "`SignedBinaryBigInt`与BinaryBigInt相同，但也能存储负值。",
        "Deepkit ORM stores SignedBinaryBigInt as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "Deepkit ORM将SignedBinaryBigInt存储为二进制。二进制有一个额外的前导符号字节，表示为uint：255表示负，0表示零，1表示正",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "Deepkit的许多组件，如HTTP路由器、RPC抽象，以及数据库抽象本身，都内置了验证功能，并自动执行，因此在许多情况下，没有必要手动操作。",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "上面使用的`User'类型的类型保护，最简单的形式如下。请注意，上面解释的与NaN有关的特殊功能并不是其中的一部分，因此这个类型保护并不完全正确。",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "这个代码更容易测试，因为所有的依赖关系都是唯一的，如果有必要，可以很容易地进行修改。",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "代码更加模块化，因为依赖关系可以很容易地交换。",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "另一个变体是将HttpClient依赖关系转移到一个抽象（接口）中，从而不将HTTP库的代码导入UserRepository",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "这被称为依赖性反转原则。UserRepository不再直接依赖一个HTTP库，而是基于一个抽象（接口）。因此，它解决了这个原则中的两个基本目标：",
        "Security": "安全",
        "MySQL": "MySQL",
        "Auto Increment": "自动增量",
        "RegExp": "RegExp",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "通过注入别名和原始提供者令牌的组合，也可以从不包含运行时类型信息的包中提供依赖性。",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "一个函数可以用来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。通过这种方式，可以访问其他依赖性或配置选项。",
        "Grouping AND/OR": "分组 AND/OR",
        "Multitenancy": "多租户",
        "Composite Primary Key": "复合主键",
        "Plugins": "插件",
        "Public Directory": "公共目录",
        "File Structure": "文件结构",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zur Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "在运行时读取类型信息是Deepkit建立其基础的能力。Deepkit库的API在很大程度上是为了尽可能多地使用TypeScript的类型信息，以便尽可能地提高效率。运行时的类型系统意味着类型信息在运行时是可读的，动态类型是可计算的。这意味着，例如，类的所有属性和函数的所有参数和返回类型都可以被读出来。",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "默认情况下，普通的bigint类型在JSON中被序列化为数字（在BSON中为长）。然而，这对可能的保存有限制，因为JavaScript中的bigint有无限的潜在大小，而JavaScript中的数字和BSON中的long是有限的。为了绕过这个限制，可以使用`BinaryBigInt`和`SignedBinaryBigInt`类型。",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "`BinaryBigInt`与bigint相同，但在数据库中序列化为无限大小的无符号二进制（而不是大多数数据库的8字节），在JSON中序列化为字符串。负值将被转换为正值（`abs(x)`）。",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "SignedBinaryBigInt'与'BinaryBigInt'相同，但也能存储负值。Deepkit ORM将`SignedBinaryBigInt`存储为二进制。二进制有一个额外的前导符号字节，表示为uint：255表示负，0表示零，1表示正。",
        "Siehe <<validation-constraint-types>>.": "见<<验证-约束-类型>>。",
        "Siehe <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "参见<<runtime-types-reflection>>以了解更多相关信息。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in <<serialisation>> mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个在运行时不提供任何安全保障的 \"作为数字 \"的类型铸造。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。这方面的更多信息可以在<<序列化>>中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "请注意，尽管蚕食者也检查数据的兼容性，但这些验证与<<validation>>中的验证不同。只有 \"cast \"函数在成功反序列化后还会从<<validation>>章节中调用完整的验证过程，如果数据无效会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe <<validation>>.": "另外，`validatedDeserialize`可以用来在反序列化后进行验证。另一种方法是手动调用`validate`或`validates`函数来处理来自`deserialize`函数的反序列化数据，见<<validation>>。",
        "Scoped DI Container haben die Fähigkeit, Werte dynamisch von außen zu setzen. So ist es zum Beispiel bei einem HTTP-Scope einfach möglich, die Objekte HttpRequest und HttpResponse zu setzen.": "范围内的DI容器有能力从外部动态地设置值。例如，在一个HTTP作用域中，很容易设置HttpRequest和HttpResponse对象。",
        "Siehe <<framework-modules>>, um mehr über App Module zu erfahren.": "参见<<framework-modules>>以了解更多关于App模块的信息。",
        "Siehe <<dependency-injection>> für mehr Informationen.": "更多信息请参见<<依赖-注入>>。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in <<http-validation>> zu finden.": "可以应用`@deepkit/type`中的所有验证类型。关于这一点的更多信息可以在<<http-validation>>中找到。",
        "Siehe <<validation>> für mehr Informationen dazu.": "关于这方面的更多信息，请参见<<验证>>。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu <<template>>.": "带有TSX的模板引擎变体的优点是，使用的变量会自动进行HTML转义。见<<模板>>。",
        "Siehe <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见<<依赖-注入-作用域>>，了解如何将提供者放在`http`作用域中。",
        "Der Decorator in `@http.resolveParameter` gibt dabei an, welche Klasse mit dem `UserResolver` aufgelöst werden soll. Sobald nun die angegebene Klasse `User` als Parameter in der Funktion beziehungsweise Methode angegeben ist, wird der Resolver genutzt, um diese bereitzustellen.": "`@http.resolveParameter`中的装饰器指定了要用`UserResolver`来解决的类。只要指定的类`User`在函数或方法中被指定为参数，解析器就会被用来提供它。",
        "Ist `@http.resolveParameter` an der Klasse angegeben, erhalten all Methoden dieser Klasse diesen Resolver. Der Decorator kann auch pro Methode angewendet werden:": "如果在类中指定了`@http.resolveParameter`，这个类的所有方法都会接收这个解析器。该装饰器也可以按方法应用。",
        "Auch kann die funktionale API genutzt werden:": "也可以使用功能性API。",
        "Das Objekt `User` muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der Benutzer eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle abbildbar sind.": "对象`User'不一定要依赖一个参数。它也可以依赖于会话或HTTP头，只在用户登录时提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，因此可以映射出很多用例。",
        "RPC steht für Remote Procedure Call und erlaubt es, Funktionen (procedures) auf einem remote Server so aufzurufen als wäre es eine lokale Funktion. Im Gegensatz zu HTTP Client-Server Kommunikation geschieht die Zuordnung nicht über die HTTP-Methode und einer URL, sondern dem Funktionsnamen. Die zu sendenden Daten werden als normale Funktion-Argumente übergeben und das Resultat des Funktionsaufrufes auf dem Server an den Client zurückgesendet.": "RPC是指远程过程调用，允许在远程服务器上调用函数（过程），就像调用本地函数一样。与HTTP客户-服务器通信不同的是，分配不是通过HTTP方法和URL进行的，而是通过函数名称进行的。要发送的数据作为正常的函数参数被传递，服务器上的函数调用结果被发回给客户端。",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion schmaler ist, da weder mit Headern, Pfaden, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es einen speziellen Client benötigt.": "RPC的优点是客户-服务器的抽象比较窄，因为没有使用头文件、路径、查询字符串或类似的东西。缺点是服务器上通过RPC的功能不能被浏览器调用，需要一个特殊的客户端。",
        "Ein Schlüsselfeature von RPC ist, dass die Daten zwischen dem Client und Server automatisch serialisiert und deserialisiert werden. Aus diesem Grund sind meist typen-sichere RPC-Clients möglich. Manche RPC-Frameworks zwingen den Benutzern daher, die Typen (Parameter-Types und Return-Types) in einem bestimmten Format bereitzustellen. Dies kann in Form von einer eigenen DSL wie bei gRPC (Protocol Buffers) und GraphQL mit einem Code-Generator sein oder in Form von einem JavaScript Schema-Builder. Zusätzliche Validierung der Daten kann das RPC-Framework ebenfalls anbieten, wird aber nicht von allen unterstützt.": "RPC的一个关键特征是，客户端和服务器之间的数据被自动序列化和反序列化。由于这个原因，类型安全的RPC客户端通常是可能的。因此，一些RPC框架强迫用户以特定的格式提供类型（参数类型和返回类型）。这可以是自定义DSL的形式，如gRPC（协议缓冲区）和GraphQL的代码生成器，也可以是JavaScript模式生成器的形式。数据的额外验证也可以由RPC框架提供，但不是所有的框架都支持。",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus dem Kapitel <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "在Deepkit RPC中，类型是由TypeScript本身从函数中提取的（见<<runtime-types>>），因此不需要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。一旦定义了<<验证>>章中的额外限制，这些限制也会被自动验证。这使得通过RPC进行的通信极为类型安全和有效。Deepkit RPC中通过`rxjs`对流媒体的支持也使这个RPC框架成为实时通信的合适工具。",
        "Um das Konzept hinter RPC zu veranschaulichen folgender Code:": "为了说明RPC背后的概念，下面的代码。",
        "Eine Methode wie `hello` wird ganz normal innerhalb einer Klasse auf dem Server implementiert und kann dann von einem remote Client aufgerufen werden.": "像 \"hello \"这样的方法通常在服务器上的一个类中实现，然后可以从远程客户端调用。",
        "Da RPC fundamental auf asynchroner Kommunikation basiert, ist die Kommunikation meist über HTTP, kann aber auch über TCP oder WebSockets geschehen. Das bedeutet, dass alle Funktionsaufrufe in TypeScript selbst zu einem `Promise` umgewandelt werden. Mit einem entsprechenden `await` kann das Resultat asynchron empfangen werden.": "由于RPC从根本上是基于异步通信的，所以通信主要是通过HTTP，但也可以通过TCP或WebSockets发生。这意味着TypeScript本身的所有函数调用都被转换为一个`承诺'。有了相应的`await'，可以异步接收结果。",
        "Sobald ein Projekt im Client (meist Frontend) und Server (backend) TypeScript genutzt wird, spricht man von Isomorphic TypeScript. Ein typen-sicheres RPC Framework, das auf TypeScript's Typen basiert, ist dann besonders profitable für ein solches Projekt, da Typen zwischen Client und Server geteilt werden können.": "只要一个项目在客户端（通常是前端）和服务器（后端）使用TypeScript，它就被称为Isomorphic TypeScript。那么，基于TypeScript的类型安全的RPC框架对这样的项目来说是特别有利的，因为类型可以在客户端和服务器之间共享。",
        "Um diesen Vorteil zu nutzen, sollten Typen, die auf beiden Seiten genutzt werden, in eine eigene Datei oder Package ausgelagert werden. Das Importieren auf der jeweiligen Seite fügt diese dann wieder zusammen.": "为了利用这一点，在两边都使用的类型应该被换成一个单独的文件或包。在各自的页面上进行导入，然后再次合并它们。",
        "Das Interface `UserControllerApi` agiert hierbei als Vertrag zwischen Client und Server. Der Server muss dies korrekt implementieren und der Client kann es konsumieren.": "接口`UserControllerApi`在这里充当了客户端和服务器之间的契约。服务器必须正确地实现这一点，客户端可以消费它。",
        "Abwärtskompatiblität kann auf dieselbe Art und Weise umgesetzt werden wie bei einer normalen lokalen API auch: Entweder werden neue Parameter als optional markiert oder es wird eine neue Methode hinzugefügt.": "向后兼容可以用与普通本地API相同的方式实现：要么将新的参数标记为可选，要么添加一个新的方法。",
        "Es ist zwar auch möglich, direkt `UserController` via `import type { UserController } from './server.ts` zu importieren, so hat dies jedoch andere Nachteile wie keine Unterstützung für nominale Typen (was bedeutet, dass Klassen-Instanzen nicht mit `instanceof` geprüft werden können).": "虽然也可以通过`import type { UserController } from './server.ts'直接导入`UserController'，但这有其他缺点，比如不支持名义类型（这意味着类的实例不能用`instanceof'检查）。",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit RPC是基于运行时类型的，因此必须正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/rpc` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果这样做成功了，就可以安装`@deepkit/rpc`或Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Zu beachten ist, dass Controller-Klassen in `@deepkit/rpc` auf TypeScript-Decorators basieren und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss": "请注意，`@deepkit/rpc`中的控制器类是基于TypeScript装饰器的，这个功能必须通过`experimentalDecorators`相应启用。",
        "Das Paket `@deepkit/rpc` muss auf dem Server und Client installiert werden, sofern beide ihre eigene `package.json` haben.": "如果服务器和客户端都有自己的`package.json`，则必须安装`@deepkit/rpc`包。",
        "Um über TCP mit dem Server zu kommunizieren, muss das Paket `@deepkit/rpc-tcp` im Client und Server installiert werden.": "要通过TCP与服务器通信，必须在客户端和服务器上安装`@deepkit/rpc-tcp`包。",
        "Für eine WebSocket-Kommunikation braucht es das Paket ebenfalls auf dem Server. Der Client im Browser hingegen nutzt `WebSocket` aus dem offiziellen Standard.": "对于WebSocket通信，它还需要服务器上的包。而浏览器中的客户端则使用官方标准中的 \"WebSocket\"。",
        "Sobald der Client über WebSocket auch in einer Umgebung genutzt werden soll, wo `WebSocket` nicht verfügbar ist (zum Beispiel NodeJS), so wird das Paket `ws` in dem Client benötigt.": "一旦客户端要通过WebSocket在没有`WebSocket`的环境中使用（例如NodeJS），客户端就需要`ws`包。",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend auf einer WebSocket-Kommunikation und der low-level API von `@deepkit/rpc`. Sobald das <<framework>> benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "下面是一个基于WebSocket通信和`@deepkit/rpc`低级API的全功能实例。一旦使用<<framework>>，控制器就会通过应用模块提供，而不需要手动实例化RpcKernel。",
        "_Datei: server.ts_": "文件：server.ts_",
        "_Datei: client.ts_": "档。client.ts_",
        "Das \"Procedure\" in Remote Procedure Call wird auch gerne Action genannt. Eine solche Action wird als Methode in einer Klasse definiert und mit dem `@rpc.action` Decorator markiert. Die Klasse selbst wird dabei als Controller durch den `@rpc.controller` Decorator markiert und einen eindeutigen Namen vergeben. Dieser Name wird dann im Client referenziert, um den korrekten Controller anzusprechen. Es können beliebig viele Controller definiert und registriert werden.": "远程过程调用中的 \"过程 \"也被称为行动。这样的动作被定义为一个类中的方法，并且用`@rpc.action`装饰器来标记。该类本身被`@rpc.controller`装饰器标记为控制器，并分配了一个唯一的名字。然后在客户中引用这个名字，以解决正确的控制器。任何数量的控制器都可以被定义和注册。",
        "Nur Methoden, die auch als `@rpc.action()` markiert sind, können von einem Client angesprochen werden.": "只有那些同时被标记为\"@rpc.action() \"的方法才能被客户端处理。",
        "Typen müssen explizit angeben werden und können nicht inferred werden. Das ist wichtig, da der Serializer genau wissen muss, wie die Typen aussehen, um diese in Binärdaten (BSON) oder JSON umzuwandeln.": "类型必须是明确指定的，不能推断。这一点很重要，因为序列化器需要确切地知道类型是什么，以便将它们转换成二进制数据（BSON）或JSON。",
        "Die Controller-Klassen werden von dem Dependency Injection Container von `@deepkit/injector` verwaltet. Wenn das Deepkit Framework genutzt wird, haben diese Controller automatisch zugriff auf die Provider des Modules, die den Controller bereitstellen.": "控制器类由`@deepkit/injector`的依赖注入容器管理。如果使用Deepkit框架，这些控制器会自动访问提供控制器的模块的提供者。",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden.": "然而，只要手动实例化一个`RpcKernel'，DI容器也可以被传递到那里。",
        "Siehe <<dependency-injection>>, um mehr zu erfahren.": "参见<<依赖性注入>>以了解更多。",
        "Nominal Types": "名义类型",
        "Error Forwarding": "错误转发",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion leichtgewichtiger ist, da weder mit Headern, URLs, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es oft einen speziellen Client benötigt.": "RPC的优点是客户端-服务器的抽象更轻，因为没有使用头文件、URL、查询字符串或类似的东西。其缺点是，服务器上通过RPC的功能不能轻易被浏览器调用，往往需要一个特殊的客户端。",
        "Server Controller": "服务器控制器",
        "Client Controller": "客户端控制器",
        "Der normale Flow in RPC ist es, dass der Client Funktionen auf dem Server ausführen kann. Es ist aber in Deepkit RPC auch möglich, dass der Server Funktionen auf dem Client ausführen kann. Um das zu erlauben, kann der Client ebenfalls einen Controller registrieren.": "RPC中的正常流程是，客户可以在服务器上执行功能。然而，在Deepkit RPC中，服务器也有可能对客户端执行功能。为了允许这一点，客户也可以注册一个控制器。",
        "Controller werden in dem Deepkit Framework in dem Dependency Injection Scope `rpc` instantiiert, sodass alle Controller automatisch auf diverse Provider aus diesem Scope zugriff haben. Diese zusätzlichen Provider sind `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, und `ConnectionWriter`.": "在Deepkit框架中，控制器被实例化在依赖性注入作用域`rpc`中，因此所有的控制器都能自动访问这个作用域中的各种提供者。这些额外的提供者是`HttpRequest`（可选），`RpcInjectorContext`，`SessionState`，`RpcKernelConnection`，和`ConnectionWriter`。",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden. Der RPC Controller wird dann über diesen DI Container instantiiert.": "然而，只要手动实例化一个`RpcKernel'，DI容器也可以被传递到那里。然后，RPC控制器通过这个DI容器被实例化。",
        "Wenn Daten auf dem Client von dem Funktionsaufruf empfangen werden, wurden diese zuvor auf dem Server serialisiert und anschließend auf dem Client deserialisiert. Sind in dem Return-Typ der Funktion nun Klassen genutzt, werden diese im Client rekonstruiert, verlieren jedoch ihre nominale Identität und alle Methoden. Um diesem Verhalten entgegenzuwirken, können Klassen als nominale Typen über eine eindeutige ID registriert werden. Dies sollte für alle Klassen gemacht werden, die in einer RPC-API genutzt werden.": "当客户端收到来自函数调用的数据时，它先前在服务器上被序列化，然后在客户端被反序列化。如果现在在函数的返回类型中使用了类，它们会在客户端被重构，但会失去它们的名义身份和所有方法。为了抵制这种行为，类可以通过一个唯一的ID注册为名义类型。对于所有在RPC API中使用的类都应该这样做。",
        "Um eine Klasse zu registrieren ist das Nutzen von dem Decorator `@entity.name('id')` nötig.": "要注册一个类，必须使用装饰器`@entity.name('id')`。",
        "Sobald diese Klasse nun als Resultat einer Funktion genutzt wird, wird ihre Identität gewahrt.": "只要这个类现在被用作一个函数的结果，它的身份就被保留了。",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu <<rpc-nominal-types>>.": "RPC函数可以抛出错误。默认情况下，这些错误被转发到客户端并在那里再次抛出。如果使用了自定义错误类，它们的名义类型应该被启用。见<<rpc-nominal-types>>。",
        "Standardmäßig sind alle RPC Funktionen von jedem Client aus aufrufbar. Auch ist das Feature Peer-To-Peer Kommunikation standardmäßig aktiviert. Um hier genau einstellen zu können, welcher Client was darf, kann die Klasse `RpcKernelSecurity` überschrieben werden.": "默认情况下，所有RPC函数都可以从任何客户端调用。点对点通信功能在默认情况下也被激活。为了能够准确地设置哪个客户被允许做什么，`RpcKernelSecurity'类可以被覆盖。",
        "Um diese zu nutzen wird entweder dem `RpcKernel` eine Instanz davon übergeben:": "要使用这个，要么把它的一个实例传给`RpcKernel`。",
        "Oder im Falle einer Deepkit Framework Anwendung die Klasse `RpcKernelSecurity` mit einem Provider überschrieben.": "或者在Deepkit Framework应用程序的情况下，`RpcKernelSecurity'类被覆盖了一个提供者。",
        "Authentication / Session": "认证/会话",
        "Das Objekt `Session` ist standardmäßig eine anonyme Session, was bedeutet, dass der Client sich nicht authentifiziert hat. Sobald er sich authentifizieren will, wird die Methode `authenticate` aufgerufen.  Das Token, das die `authenticate` Methode erhält, kommt von dem Client und kann einen beliebigen Wert haben.": "对象`session`默认是一个匿名会话，这意味着客户端没有认证自己。一旦它想进行认证，就会调用`authenticate`方法。  `authenticate`方法收到的令牌来自客户端，可以有任何值。",
        "Sobald der Client einen Token setzt, wird die Authentifizierung ausgeführt, sobald die erste RPC Funktion oder manuell `client.connect()` aufgerufen wird.": "一旦客户端设置了一个令牌，只要调用第一个RPC函数或手动`client.connect()`，就会进行认证。",
        "Hier erhält `RpcKernelSecurity.authenticate` das Token `123456789` und kann entsprechend eine andere Session zurückgeben. Diese zurückgegebene Session wird dann an alle anderen Methoden wie der `hasControllerAccess` übergeben.": "这里`RpcKernelSecurity.authenticate`接收到令牌`123456789`并可以相应地返回另一个会话。这个返回的会话将被传递给所有其他的方法，如`hasControllerAccess`。",
        "Controller Access": "控制器访问",
        "Mit der Methode `hasControllerAccess` kann bestimmt werden, ob ein Client eine bestimmte RPC Funktion ausführen darf. Diese Methode wird bei jedem RPC Funktionsaufruf ausgeführt. Gibt diese `false` zurück, ist der Zugriff verweigert und es wird ein Fehler auf dem Client geworfen.": "`hasControllerAccess`方法可用于确定客户端是否被允许执行特定的RPC功能。这个方法在每次RPC函数调用时都会执行。如果它返回 \"false\"，则拒绝访问，并向客户抛出一个错误。",
        "In `RpcControllerAccess` sind mehrere wertvolle Informationen über die RPC Funktion enthalten:": "在`RpcControllerAccess`中，有几条关于RPC函数的有价值的信息。",
        "Gruppen und zusätzliche Daten sind über den Decorator `@rpc.action()` änderbar:": "组和其他数据可以通过装饰器`@rpc.action()`来改变。",
        "Transform Error": "变形误差",
        "Da geworfene Fehler automatisch mit all seinen Informationen wie die Fehlermeldung und auch den Stacktrace dem Client weitergeleitet werden, könnte dies unerwünscht sensitive Informationen veröffentlichen. Um dies zu ändern, kann in der Methode `transformError` der geworfene Fehler abgeändert werden.": "由于抛出的错误会自动转发到客户端，并附上所有信息，如错误信息和堆栈跟踪，这可能会不必要地公布敏感信息。要改变这一点，可以在`transformError`方法中修改抛出的错误。",
        "Beachte, dass sobald der Error in einen generischen `Error` umgewandelt wird, der komplette Stacktrace und die Identität des Errors verloren gehen. Entsprechend kann in dem Client keine `instanceof` checks mehr auf den Error genutzt werden.": "请注意，一旦错误被转换为一般的 \"错误\"，完整的堆栈跟踪和错误的身份就会丢失。因此，在客户端的错误上不能使用`instanceof`检查。",
        "Wird Deepkit RPC zwischen zwei Microservices verwendet, und ist somit der Client und Server unter vollständiger Kontrolle des Entwicklers, so ist ein Transformieren des Errors nur selten nötig. Läuft der Client hingegen in einem Browser bei einem Unbekannten, so sollte in `transformError` genaustens darauf geachtet werden, welche Informationen man preisgeben möchte. Im Zweifel sollte jeder Error mit einem generischen `Error` umgewandelt werden, um so sicherzustellen, dass keine internen Details nach außen gelangen. Das Loggen des Errors würde sich an dieser Stelle dann anbieten.": "如果在两个微服务之间使用Deepkit RPC，并且客户端和服务器因此处于开发者的完全控制之下，那么转变错误就很少有必要。另一方面，如果客户端在一个未知的人的浏览器中运行，那么你应该在`transformError'中非常小心地确定你想披露的信息。如果有疑问，每个错误都应该用一个通用的 \"错误 \"进行转换，以确保没有内部细节被泄露。在这一点上，记录错误将是一个好主意。",
        "Sofern die Deepkit RPC Library direkt benutzt wird, wird die `RpcKernelSecurity` Klasse selbst instantiiert. Benötigt diese Klasse eine Datenbank oder einen Logger, so muss dieser selbst übergeben werden.": "如果直接使用Deepkit RPC库，则要实例化`RpcKernelSecurity`类本身。如果这个类需要一个数据库或一个记录器，这必须被传入本身。",
        "Wenn das Deepkit Framework genutzt wird, wird die Klasse von dem Dependency Injection Container instantiiert und hat so automatisch Zugriff auf alle anderen Provider der Anwendung.": "如果使用Deepkit框架，该类由依赖注入容器实例化，从而自动访问应用程序的所有其他提供者。",
        "Siehe hierzu auch <<dependency-injection>>.": "参见<<依赖性注入>>。",
        "Streaming RxJS": "流动的RxJS",
        "Deepkit RPC unterstützt mehrere Transportprotokolle. WebSockets ist dabei das Protokoll, das die beste Kompatibilität hat (da Browser es unterstützen) und gleichzeitig alle Features wie Streaming unterstützt. TCP ist in der Regel schneller und eignet sich hervorragend für die Kommunikation zwischen Servern (Microservices) oder Nicht-Browser Clients.": "Deepkit RPC支持几种传输协议。WebSockets是兼容性最好的协议（因为浏览器支持它），同时也支持流媒体等所有功能。TCP通常更快，非常适合服务器（微服务）或非浏览器客户端之间的通信。",
        "Deepkit's RPC HTTP Protokoll ist dabei eine Variante, die besonders einfach im Browser zu debuggen ist, da jeder Funktionsaufruf ein HTTP-Request ist, hat jedoch seine Limitierungen wie kein Support für RxJS Streaming.": "Deepkit的RPC HTTP协议是一个变种，在浏览器中特别容易调试，因为每个函数调用都是一个HTTP请求，但也有其局限性，如不支持RxJS流。",
        "TODO: Not implemented yet.": "TODO: 还没有实施。",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer`和浏览器WebSocket或Node `ws`包。",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer`和`RpcNetTcpClientAdapter`。",
        "Event System": "事件系统",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "事件系统允许同一进程中的应用程序组件通过发送和监听事件来相互通信。它通过在互不相识的函数之间发送消息，帮助将代码模块化。",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "应用程序或库开启了在某个时间点执行额外功能的可能性。这些额外的函数将自己注册为所谓的事件监听者。",
        "Ein Event kann dabei vielfältig sein:": "一个事件可以是多层面的。",
        "Die Anwendung fährt hoch oder runter.": "申请书上升或下降。",
        "Ein neuer User wurde erstellt oder gelöscht.": "一个新的用户已经被创建或删除。",
        "Eine Error wurde geworfen.": "抛出了一个错误。",
        "Ein neuer HTTP-Request ist hereingekommen.": "有一个新的HTTP请求进来了。",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit框架及其库已经提供了各种事件，用户可以对其进行监听和反应。然而，可以创建任何数量的自定义事件，使应用程序可以模块化扩展。",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "下面是`@deepkit/event`的低级API的一个例子。如果使用Deepkit Framework，事件监听器的注册不是直接通过`EventDispatcher'而是通过模块完成的。",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit的事件系统是基于运行时类型的，因此有必要正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果这样做成功了，就可以安装`@deepkit/event`或者已经在引擎盖下使用该库的Deepkit框架。",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "请注意，控制器API的`@deepkit/event`是基于TypeScript装饰器的，一旦使用控制器API，就必须用`experimentalDecorators`相应地启用这一功能。",
        "Event Token": "事件标志",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "事件系统的核心是事件令牌。它们是定义唯一事件ID和事件类型的对象。一个事件可以被触发，一个事件可以通过一个事件标记被监听。从概念上讲，触发事件令牌事件的人也是这个事件令牌的所有者。事件标记决定了在事件中哪些数据是可用的，以及是否允许异步事件监听器。",
        "TODO asynchrone": "TODO异步",
        "Event Types": "事件类型",
        "Propagation": "传播",
        "TODO. event.stop()": "TODO.event.stop()",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit中的CLI程序是基于运行时类型的，因此有必要正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "请注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，就必须用`experimentalDecorators`相应地启用这一功能。",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "在Deepkit RPC中，函数的类型是从TypeScript代码本身中提取的（见<<runtime-types>>），因此不需要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。一旦从<<validation>>定义了额外的约束，这些约束也会被自动验证。这使得通过RPC进行的通信极为类型安全和有效。Deepkit RPC中通过`rxjs`对流媒体的支持也使这个RPC框架成为实时通信的合适工具。",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend WebSockets und der low-level API von `@deepkit/rpc`. Sobald das Deepkit Framework benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "下面是一个基于WebSockets和`@deepkit/rpc`的低级API的全功能例子。一旦使用Deepkit框架，控制器就会通过应用模块提供，而不需要手动实例化RpcKernel。",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel xref:dependency-injection.adoc[Dependency Injection] für weitere Details.": "控制器由依赖性注入容器管理或实例化，因此可以使用其他提供者。更多细节见xref:dependency-injection.adoc[依赖注入]一章。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit中的CLI程序是基于运行时类型的，因此有必要正确安装@deepkit/type。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "因此，定义为数字的参数在控制器中总是被保证为实数，尽管命令行界面是基于文本的，因此是字符串。这种转换是通过xref:serialization.adoc#serialisation-loosely-conversion功能自动发生的。",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel xref:validation.adoc[Validation] für mehr Informationen.": "如果数字是正数，命令的功能又和以前一样。这种额外的验证非常容易进行，使命令更加强大，可以防止错误的输入。更多信息请参见xref:validation.adoc[Validation]章节。",
        "Deepkit bietet ein ORM, das es ermöglicht, auf Datenbanken auf moderne Art und Weise zuzugreifen.": "Deepkit提供了一个ORM，允许以现代方式访问数据库。",
        "Entities werden dabei einfach über TypeScript Typen definiert:": "实体是通过TypeScript类型简单定义的。",
        "Dabei können beliebige TypeScript Typen und Validierung-Dekoratoren von Deepkit benutzt werden, um die Entity vollumfänglich zu definieren.": "可以使用Deepkit的任何TypeScript类型和验证装饰器来完全定义实体。",
        "Das Entity-Typensystem ist dabei so ausgelegt, dass diese Typen beziehungsweise Klassen ebenfalls in anderen Bereichen wie HTTP-Routen, RPC-Aktionen, oder Frontend benutzt werden können. Das verhindert, dass man zum Beispiel einen User mehrmals in der gesamten Applikation verteilt definiert hat.": "实体类型系统的设计方式是，这些类型或类也可用于其他领域，如HTTP路由、RPC动作或前端。这可以防止，例如，一个用户在整个应用程序中被多次定义。",
        "Da Deepkit ORM auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit ORM是基于Runtime Types的，所以有必要正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/orm` selbst und ein Datenbank-Adapter installiert werden.": "如果这样做成功了，就可以安装`@deepkit/orm`本身和一个数据库适配器。",
        "Falls Klassen als Entities verwendet werden sollen, muss `experimentalDecorators` in der tsconfig.json aktiviert werden:": "如果要将类作为实体使用，必须在tsconfig.json中激活`experimentalDecorators`。",
        "Sobald die Library installiert ist, kann ein Datenbank-Adapter installiert und die API davon direkt benutzt werden.": "一旦安装了这个库，就可以安装一个数据库适配器，可以直接使用它的API。",
        "Es wird primär mit dem `Database` Objekt gearbeitet. Einmal instantiiert, kann es innerhalb der ganzen Anwendung genutzt werde, um Daten abzufragen oder zu manipulieren. Die Verbindung zur Datenbank wird dabei lazy initialisiert.": "数据库 \"对象是使用的主要对象。一旦被实例化，它就可以在整个应用程序中被用来查询或操作数据。与数据库的连接被初始化为懒惰。",
        "Dem `Database` Objekt wird ein Adapter übergeben, welcher aus den Datenbank-Adaptern Libraries kommt.": "`Database`对象被传递给一个适配器，它来自数据库适配器库。",
        "Eine Entity ist entweder eine Klasse oder Object Literal (interface) und hat immer einen Primary Key.": "一个实体要么是一个类，要么是一个对象字面（接口），并且总是有一个主键。",
        "Die Entity wird mittels Typen-Dekoratoren aus `@deepkit/type` mit alle notwendigen Informationen dekoriert. Zum Beispiel wird ein Primary Key definiert sowie diverse Felder und ihre Validierungen-Einschränkungen. Dieser Felder spiegeln die Datenbank-Struktur ab, in der Regel eine Tabelle oder eine Collection.": "使用`@deepkit/type`的类型装饰器对实体进行装饰，并提供所有必要的信息。例如，定义了一个主键，以及各种字段和它们的验证限制。这些字段反映了数据库结构，通常是一个表或一个集合。",
        "Durch spezielle Typen-Dekoratoren wie `Mapped<'name'>` kann ein Feldnamen auch auf einen anderen Namen in der Datenbank abgebildet werden.": "通过特殊的类型装饰器，如 \"Mapped<'name'>\"，一个字段名也可以被映射到数据库中的另一个名字。",
        "Klasse": "级别",
        "Interface": "介面",
        "Primitive Datentypen wie String, Number (bigint), und Boolean werden gängige Datenbank-Typen abgebildet. Es wird dabei lediglich der TypeScript Type genutzt.": "原始数据类型，如String、Number（bigint）和Boolean，被映射到常见的数据库类型。只有TypeScript类型被使用。",
        "Jede Entity braucht genau einen Primary Key. Mehrere Primary Keys werden nicht unterstützt.": "每个实体正好需要一个主键。不支持多主键。",
        "Der Basis-Typ eines Primary Keys kann dabei beliebig sein. Oft wird eine Nummer oder UUID verwendet.": "主键的基本类型可以是任何类型。通常使用一个数字或UUID。",
        "Für MongoDB wird gerne die MongoId bzw ObjectID verwendet.": "对于MongoDB，通常使用MongoId或ObjectID。",
        "Bei Nummern bietet sich `AutoIncrement` an.": "对于数字来说，\"自动增量 \"是一个不错的选择。",
        "Felder, die beim Einfügen automatisch inkrementiert werden sollen, werden mit dem `AutoIncrement` Dekorator annotiert. Alle Adapter unterstützen auto-increment Werte. Der MongoDB Adapter verwendet eine zusätzliche Collection, um den Zähler zu verfolgen.": "在插入过程中要自动递增的字段用`AutoIncrement`装饰器来注释。所有适配器都支持自动增量值。MongoDB适配器使用一个额外的集合来跟踪计数器。",
        "Ein Auto-Increment Feld ist ein automatischer Zähler und kann nur an einem Primary Key angewendet werden. Die Datenbank stellt automatisch sicher, dass eine ID nur einmal verwendet wird.": "自动增量字段是一个自动计数器，只能应用于一个主键。数据库自动确保一个ID只使用一次。",
        "Felder, die vom Typ UUID (v4) sein sollten, werden mit dem Dekorator UUID annotiert. Der Laufzeittyp ist `string` und in der Datenbank selbst meist binär. Verwenden Sie die Funktion `uuid()`, um eine neue UUID v4 zu erzeugen.": "应该是UUID（v4）类型的字段用装饰器UUID来注释。运行时类型是 \"string\"，在数据库本身中多为二进制。使用函数`uuid()`来创建一个新的UUID v4。",
        "Felder, die in MongoDB vom Typ ObjectID sein sollten, werden mit dem Dekorator `MongoId` annotiert. Der Laufzeittyp ist `string` und in der Datenbank selbst `ObjectId` (binär).": "在MongoDB中应该是ObjectID类型的字段用装饰器`MongoId`来注释。运行时的类型是 \"string\"，而在数据库本身是 \"ObjectId\"（二进制）。",
        "MongoID-Felder erhalten beim Einfügen automatisch einen neuen Wert. Es ist nicht zwingend nötig, den Feldnamen `_id` zu verwenden. Er kann einen beliebigen Namen haben.": "MongoID字段在插入时自动接收一个新值。使用字段名`_id`并不是强制性的。它可以有任何名字。",
        "Optionale Felder werden mit `title?: string` oder `title: string | null` als TypeScript-Typ deklariert. Man sollte nur eine Variante davon verwenden, normalerweise die optionale `?` Syntax, die mit `undefined` funktioniert.": "可选字段被声明为TypeScript类型，有`title?: string`或`title: string | null`。你应该只使用一种变体，通常是可选的`?`语法，与`undefined`一起使用。",
        "Beide Varianten führen dazu, dass der Datenbank-Typ für alle SQL-Adapter `NULLABLE` ist. Der einzige Unterschied zwischen diesen Dekoratoren ist also, dass sie unterschiedliche Werte zur Laufzeit darstellen.": "这两种变体都会导致所有SQL适配器的数据库类型为`NULLABLE`。因此，这些装饰器之间的唯一区别是，它们在运行时代表不同的值。",
        "Im folgenden Beispiel ist das geänderte Feld optional und kann daher zur Laufzeit undefiniert sein, obwohl es in der Datenbank immer als NULL dargestellt wird.": "在下面的例子中，改变的字段是可选的，因此在运行时可以不定义，尽管它在数据库中总是表示为NULL。",
        "Dieses Beispiel zeigt, wie der nullable Typ funktioniert. Sowohl in der Datenbank als auch in der Javascript-Laufzeit wird NULL verwendet. Dies ist ausführlicher als `modified?: Date` und wird nicht häufig verwendet.": "这个例子显示了nullable类型是如何工作的。NULL在数据库和javascript运行时都被使用。这比 \"modified?: Date \"更粗略，不经常使用。",
        "Database Type Mapping": "数据库类型映射",
        "Mit `DatabaseField` ist es möglich, ein Feld auf einen beliebigen Datenbank-Typen zu mappen. Der Typ muss eine gültige SQL-Anweisung sein, die unverändert an das Migrationssystem übergeben wird.": "通过`DatabaseField`，可以将一个字段映射到任何数据库类型。该类型必须是一个有效的SQL语句，该语句将不变地传递给迁移系统。",
        "Um ein Feld für eine bestimmte Datenbank zu mappen, kann entweder `SQLite`, `MySQL`, oder `Postgres` benutzt werden.": "要为一个特定的数据库映射一个字段，可以使用`SQLite`、`MySQL`或`Postgres`。",
        "Default-Werte werden": "默认值为",
        "Eine Session ist so etwas wie eine Arbeitseinheit. Sie verfolgt alles, was Sie tun, und hält die Änderungen automatisch fest, sobald `commit()` aufgerufen wird. Es ist der bevorzugte Weg, um Änderungen in der Datenbank auszuführen, da es Anweisungen in einer Weise bündelt, die es sehr schnell macht. Eine Session ist sehr leichtgewichtig und kann zum Beispiel leicht in einem Request-Response-Lebenszyklus erstellt werden.": "一节课是类似于一个工作单位的东西。它记录了你所做的一切，并在调用`commit()`时自动记录了这些变化。它是在数据库中执行变化的首选方式，因为它以一种使其非常快的方式捆绑语句。一个会话是非常轻量级的，可以很容易地在请求-响应生命周期中创建，例如。",
        "Fügen Sie der Session mit `session.add(T)` neue Instanz hinzu oder entfernen Sie bereits vorhandene Instanzen mit `session.remove(T)`. Sobald Sie mit dem Session-Objekt fertig sind, dereferenzieren Sie es einfach überall, damit der Garbage-Collector es entfernen kann.": "用`session.add(T)`向会话添加新实例，或用`session.remove(T)`删除现有实例。一旦你完成了对会话对象的处理，只需在各处取消对它的引用，这样垃圾收集器就能将其删除。",
        "Änderungen werden bei Entity-Instanzen, die über das Session-Objekt geholt werden, automatisch erkannt.": "对于通过会话对象获取的实体实例，会自动识别变化。",
        "Sessions bieten eine Identity-Map, die sicherstellt, dass es immer nur ein Javascript-Objekt pro Datenbank-Eintrag gibt. Wenn Sie zum Beispiel `session.query(User).find()` zweimal innerhalb derselben Sitzung ausführen, erhalten Sie zwei verschiedene Arrays, aber mit denselben Entitätsinstanzen darin.": "会话提供了一个身份映射，确保每个数据库条目只有一个javascript对象。例如，如果你在同一个会话中运行两次`session.query(User).find()`，你会得到两个不同的数组，但其中有相同的实体实例。",
        "Wenn Sie mit `session.add(entity1)` eine neue Entität hinzufügen und diese erneut abrufen, erhalten Sie genau dieselbe Entitätsinstanz `entity1`.": "如果你用`session.add(entity1)`添加一个新的实体，并再次检索它，你会得到完全相同的实体实例`entity1`。",
        "Wichtig: Sobald Sie anfangen, Sessions zu verwenden, sollten Sie deren Methode `Session.query` anstelle von `Database.query` verwenden. Nur bei Session-Queries ist die Identitätszuordnungsfunktion aktiviert.": "重要提示：一旦你开始使用会话，你应该使用它们的方法`Session.query`而不是`Database.query`。只有会话查询启用了身份映射功能。",
        "Ein Query ist ein Objekt, das beschreibt, wie Daten aus der Datenbank abgerufen oder geändert werden sollen. Es hat mehrere Methoden um das Query zu beschreiben und Abbruchmethoden die diese ausführen. Der Datenbankadapter kann die Query-API auf viele Arten erweitern, um Datenbank spezifische Features zu unterstützen.": "查询是一个描述如何从数据库检索或改变数据的对象。它有几种方法来描述查询和执行查询的终止方法。数据库适配器可以以多种方式扩展查询API，以支持数据库的特定功能。",
        "Sie können ein Query erstellen, indem Sie `Database.query(T)` oder `Session.query(T)` verwenden. Wir empfehlen Sessions da es die Leistung verbessert.": "你可以通过使用`Database.query(T)`或`Session.query(T)`创建一个查询。我们推荐Sessions，因为它可以提高性能。",
        "Ein Filter kann angewendet werden, um die Ergebnismenge einzuschränken.": "可以应用一个过滤器来限制结果集。",
        "Select": "选择",
        "Um die Felder einzugrenzen, die von der Datenbank empfangen werden sollen, kann `select('field1')` verwendet werden.": "为了缩小从数据库接收的字段，可以使用`select('field1')`。",
        "Wichtig dabei ist, dass sobald ein Eingrenzungen der Felder über `select` stattfindet, die Ergebnisse keine Instanzen der Entity mehr sind, sondern lediglich Object-Literals.": "需要注意的是，一旦通过 \"选择 \"缩小了字段的范围，结果就不再是实体的实例，而只是对象字面。",
        "Mit `orderBy(field, order)` kann die Reihenfolge der Einträge geändert werden.": "通过`orderBy(field, order)`，可以改变条目的顺序。",
        "Es kann mehrere Male `orderBy` ausgeführt werden, um die Reihenfolge immer weiter zu verfeinern.": "可以多次执行`orderBy'，使订单越来越细化。",
        "Mit den Methoden `itemsPerPage()` und `page()` können die Ergebnisse paginiert werden. Seite beginnt bei 1.": "通过`itemsPerPage()`和`page()`方法，可以对结果进行分页。页面从1开始。",
        "Mit den alternativen Methoden `limit` und `skip` können Sie manuell paginieren.": "使用替代方法`limit`和`skip`，你可以手动分页。",
        "Standardmäßig werden Referenzen aus der Entity weder in Abfragen einbezogen noch geladen. Um ein Join in die Abfrage aufzunehmen, ohne den Verweis zu laden, verwenden Sie `join()` (left join) oder `innerJoin()`. Um einen Join in die Abfrage aufzunehmen und die Referenz zu laden, verwenden Sie `joinWith()` oder `innerJoinWith()`.": "默认情况下，来自实体的引用既不包括也不在查询中加载。要在查询中包含一个连接而不加载引用，请使用`join()`（左连接）或`innerJoin()`。要在查询中包含一个连接并加载引用，请使用`joinWith()`或`innerJoinWith()`。",
        "Alle folgenden Beispiele gehen von diesen Modellschemata aus:": "以下所有的例子都是基于这些模型方案。",
        "Um Join-Abfragen zu ändern, verwenden Sie dieselben Methoden, jedoch mit dem `use`-Präfix: `useJoin`, `useInnerJoin`, `useJoinWith` oder `useInnerJoinWith`. Um die Änderung der Join-Abfrage zu beenden, verwenden Sie `end()`, um so die übergeordnete Abfrage zurückzubekommen.": "要修改连接查询，使用相同的方法，但要使用`use`前缀：`useJoin`、`useInnerJoin`、`useJoinWith`或`useInnerJoinWith`。要结束对连接查询的修改，请使用`end()`来取回父查询。",
        "Mit Aggregationsmethoden können Sie Datensätze zählen und Felder aggregieren.": "聚合方法允许你计算记录和聚合字段。",
        "Die folgenden Beispiele gehen von diesem Modellschema aus:": "下面的例子是基于这个模型方案的。",
        "`groupBy` ermöglicht es, das Ergebnis nach dem angegebenen Feld zu gruppieren.": "`groupBy`允许将结果按指定字段分组。",
        "Es gibt mehrere Aggregationsmethoden: `withSum`, `withAverage`, `withCount`, `withMin`, `withMax`, `withGroupConcat`. Jede erfordert einen Feldnamen als erstes Argument und ein optionales zweites Argument, um den Alias zu ändern.": "有几种聚合方法：`withSum', `withAverage', `withCount', `withMin', `withMax', `withGroupConcat`。每个都需要一个字段名作为第一个参数，以及一个可选的第二个参数来改变别名。",
        "Mit `returning` können bei Änderungen via `patch` und `delete` zusätzliche Felder angefordert werden.": "有了`returning`，就可以通过`patch`和`delete`在发生变化时请求额外的字段。",
        "Vorsicht: Nicht in allen Datenbank-Adaptern sind die Felder atomar zurückgegeben. Verwenden Sie Transaktionen, um Datenkonsistenz sicherzustellen.": "注意：不是所有的数据库适配器都会原子化地返回字段。使用交易来确保数据的一致性。",
        "Gibt ein Array an Einträgen zurück, die zu dem angegebenen Filter passen.": "返回一个符合指定过滤器的条目数组。",
        "FindOne": "找到一个",
        "Gibt ein Eintrag zurück, der zu dem angegebenen Filter passen.": "返回一个符合指定过滤器的条目。",
        "Wird kein Eintrag gefunden, wird ein `ItemNotFound` Fehler geworfen.": "如果没有找到项目，就会抛出 \"没有找到项目 \"的错误。",
        "FindOneOrUndefined": "查找一个或未定义",
        "Wird kein Eintrag gefunden, wird undefined zurückgegeben.": "如果没有找到条目，则返回未定义。",
        "FindField": "查找字段",
        "Gibt eine Liste eines Feldes zurück, der zu dem angegebenen Filter passen.": "返回一个符合指定过滤器的字段的列表。",
        "FindOneField": "查找一个字段",
        "Patch ist eine Änderungsabfrage, die die in der Abfrage beschriebenen Datensätze patcht. Die Methoden": "补丁是一个变更查询，对查询中描述的记录进行补丁。方法",
        "`patchOne` und `patchMany` beenden die Abfrage und führen den Patch aus.": "`patchOne`和`patchMany`完成查询并执行补丁。",
        "`patchMany` ändert alle Einträge in der Datenbank, die zu dem angegebenen Filter passen. Ist kein Filter gesetzt, wird die gesamte Tabelle geändert. Nutzen Sie `patchOne`, um immer nur einen Eintrag zu verändern.": "`patchMany`改变数据库中所有符合指定过滤器的条目。如果没有设置过滤器，整个表就会被改变。使用`patchOne`一次只改变一个条目。",
        "`deleteMany` löscht alle Einträge in der Datenbank, die zu dem angegebenen Filter passen.": "`deleteMany`删除数据库中所有符合指定过滤器的条目。",
        "Ist kein Filter gesetzt, wird die gesamte Tabelle gelöscht. Nutzen Sie `deleteOne`, um immer nur einene Eintrag zu löschen.": "如果没有设置过滤器，整个表将被删除。使用`deleteOne`，一次只删除一个条目。",
        "Has": "有",
        "Gibt zurück, ob mindestens ein Eintrag in der Datenbank existiert.": "返回数据库中是否存在至少一个条目。",
        "Count": "计数",
        "Gibt die Anzahl der Einträge zurück.": "返回条目的数量。",
        "Das Lifting einer Abfrage bedeutet, dass ihr neue Funktionen hinzugefügt werden. Dies wird in der Regel entweder von Plugins oder komplexen Architekturen verwendet, um größere Abfrageklassen in mehrere praktische, wiederverwendbare Klassen aufzuteilen.": "提升一个查询意味着向它添加新的功能。这通常由插件或复杂的架构来使用，将较大的查询类分割成几个方便、可重复使用的类。",
        "Beziehungen ermöglichen es Ihnen, zwei Entitäten auf eine bestimmte Art und Weise zu verbinden. Dies geschieht in Datenbanken in der Regel über das Konzept der Fremdschlüssel. Deepkit ORM unterstützt Relationen für alle offiziellen Datenbankadapter.": "关系允许你以某种方式连接两个实体。这通常是在数据库中使用外键的概念进行的。Deepkit ORM支持所有官方数据库适配器的关系。",
        "Eine Relation wird mit dem `Reference`-Dekorator annotiert. Normalerweise hat eine Relation auch eine umgekehrte Relation, die mit dem Typ `BackReference` annotiert wird, aber nur benötigt wird, wenn die umgekehrte Relation in einer Datenbankabfrage verwendet werden soll. Rückreferenzen sind nur virtuell.": "一个关系被注释为 \"参考 \"装饰器。通常，一个关系也有一个反向关系，它被注释为 \"反向参考 \"类型，但只有在反向关系被用于数据库查询时才需要。背面的参考只是虚拟的。",
        "Die Entität, die einen Verweis speichert, wird in der Regel als die \"besitzende Seite\" oder diejenige, die den Verweis \"besitzt\", bezeichnet. Der folgende Code zeigt zwei Entitäten mit einer One-To-Many-Beziehung zwischen `User` und `Post`. Das bedeutet, dass ein `User` mehrere `Post` haben kann. Die Entität `Post` besitzt die Beziehung `Post->User`. In der Datenbank selbst gibt es nun ein Feld `Post.\"author\"`, das den Primärschlüssel von `User` enthält.": "存储引用的实体通常被称为 \"拥有页 \"或 \"拥有引用 \"的实体。下面的代码显示了两个实体，在`User`和`Post`之间有一对多的关系。这意味着，一个 \"用户 \"可以有多个 \"帖子\"。实体`post`具有`post->user`的关系。在数据库本身，现在有一个字段`Post. \"author\"`，包含`User`的主键。",
        "Referenzen werden in Abfragen standardmäßig nicht ausgewählt. Siehe dazu <<database-join>>.": "默认情况下，查询中不选择引用。参见<<数据库连接>>中的内容。",
        "Many To One": "多对一",
        "Ein Verweis hat in der Regel einen umgekehrten Verweis, der Many-to-One genannt wird. Es handelt sich nur um eine virtuelle Referenz, da sie nicht in der Datenbank selbst reflektiert wird. Eine Rückreferenz wird mit `BackReference` annotiert und wird hauptsächlich für Reflection und Query Joins verwendet. Wenn Sie eine `BackReference` von `User` zu `Post` hinzufügen, können Sie `Post` direkt aus `User`-Abfragen verbinden.": "一个引用通常有一个反向引用，称为多对一。它只是一个虚拟参考，因为它没有反映在数据库本身。背面引用被注解为 \"BackReference\"，主要用于反射和查询连接。如果你从 \"用户 \"向 \"帖子 \"添加了一个 \"返回参考\"，你可以直接从 \"用户 \"查询中加入 \"帖子\"。",
        "Eine Many-to-many-Beziehung ermöglicht es Ihnen, viele Datensätze mit vielen anderen zu verbinden. Sie kann zum Beispiel für Benutzer in Gruppen verwendet werden. Ein Benutzer kann in keiner, einer oder vielen Gruppen sein. Folglich kann eine Gruppe 0, einen oder viele Benutzer enthalten.": "多对多的关系允许你将许多记录与其他许多记录联系起来。例如，它可以用于群组中的用户。一个用户可以不在任何组，也可以在一个或多个组。因此，一个组可以包含0、1或许多用户。",
        "Many-to-many-Beziehungen werden normalerweise über eine Pivot-Entität implementiert. Die Pivot-Entität enthält die eigentlichen eigenen Referenzen auf zwei andere Entitäten, und diese beiden Entitäten haben Rückreferenzen auf die Pivot-Entität.": "多对多的关系通常通过一个枢轴实体来实现。支点实体包含对其他两个实体的实际自己的引用，而这两个实体对支点实体有反向引用。",
        "Mit diesen Entities können Sie nun Benutzer und Gruppen erstellen und sie mit der Pivot-Entität verbinden. Durch die Verwendung eines Rückverweises in User können wir die Gruppen direkt mit einer User-Abfrage abrufen.": "有了这些实体，你现在可以创建用户和组，并将它们连接到透视实体。通过使用User中的反向引用，我们可以用User查询直接检索到组。",
        "Um die Verknüpfung eines Benutzers mit einer Gruppe aufzuheben, wird der Datensatz der UserGroup gelöscht:": "要解除一个用户与一个组的联系，需要删除UserGroup的记录。",
        "Ereignisse sind eine Möglichkeit, sich in Deepkit ORM einzuklinken und ermöglichen es Ihnen, leistungsfähige Plugins zu schreiben. Es gibt zwei Kategorien von Ereignissen: Abfrage-Ereignisse und Unit-of-Work-Ereignisse. Plugin-Autoren verwenden in der Regel beide, um beide Möglichkeiten der Datenmanipulation zu unterstützen.": "事件是插入Deepkit ORM的一种方式，允许你编写强大的插件。有两类事件。查询事件和工作单位事件。插件作者通常使用这两种方式来支持这两种操作数据的方式。",
        "Events werden über `Database.listen` un einem Event-Token registriert. Es kann auch kurzlebige Event-Listener auf Sessions registriert werden.": "事件是通过`Database.listen`和一个事件标记注册的。短暂的事件监听器也可以被注册在会话上。",
        "Abfrageereignisse werden ausgelöst, wenn eine Abfrage über `Database.query()` oder `Session.query()` ausgeführt wird.": "当通过`Database.query()`或`Session.query()`执行查询时，查询事件被触发。",
        "Jedes Event hat seine eigenen zusätzlichen Eigenschaften wie den Typ der Entität, die Abfrage selbst und die Datenbanksitzung. Sie können die Abfrage überschreiben, indem Sie eine neue Abfrage auf `Event.query` setzen.": "每个事件都有自己的附加属性，如实体的类型、查询本身和数据库会话。你可以通过给`Event.query`设置一个新的查询来覆盖这个查询。",
        "`Query` hat dabei mehrere Event-Tokens:": "查询 \"有几个事件标记。",
        "Unit-of-Work-Ereignisse werden ausgelöst, wenn eine neue Session änderungen absetzt.": "当一个新的会话发送变化时，工作单元事件被触发。",
        "Eine Transaktion ist eine sequentielle Gruppe von Anweisungen, Abfragen oder Operationen wie Select, Insert, Update oder Delete, die als eine einzige Arbeitseinheit ausgeführt werden, die bestätigt oder rückgängig gemacht werden kann.": "事务是一组连续的语句、查询或操作，如选择、插入、更新或删除，作为一个工作单元执行，可以确认或撤销。",
        "Deepkit unterstützt Transaktionen für alle offiziell unterstützten Datenbanken. Standardmäßig werden für jede Abfrage und Datenbanksitzung keine Transaktionen verwendet. Um Transaktionen zu aktivieren, gibt es zwei Hauptmethoden: Sessions und Callback.": "Deepkit支持所有官方支持的数据库的交易。默认情况下，任何查询或数据库会话都不使用事务。为了实现交易，有两种主要方法：会话和回调。",
        "Session Transactions": "会议交易",
        "Sie können für jede erstellte Session eine neue Transaktion starten und zuweisen. Dies ist die bevorzugte Art der Interaktion mit der Datenbank, da Sie das Session-Objekt einfach weitergeben können und alle Abfragen, die von dieser Session instanziiert werden, automatisch seiner Transaktion zugewiesen werden.": "你可以为每个创建的会话启动和分配一个新的交易。这是与数据库交互的首选方式，因为你可以简单地传递会话对象，这个会话实例化的所有查询都会自动分配给其事务。",
        "Ein typisches Muster ist, alle Operationen in einen try-catch-Block zu verpacken und `commit()` in der allerletzten Zeile auszuführen (das nur ausgeführt wird, wenn alle vorherigen Befehle erfolgreich waren) und `rollback()` im catch-Block, um alle Änderungen zurückzunehmen sobald ein Fehler auftritt.": "一个典型的模式是将所有的操作包在一个try-catch块中，并在最后一行执行`commit()`（只有在所有先前的命令都成功的情况下才执行），并在catch块中执行`rollback()`，一旦发生错误就回滚所有的修改。",
        "Obwohl es eine alternative API gibt (siehe unten), funktionieren alle Transaktionen nur mit Datenbanksitzungsobjekten. Um offene Änderungen aus der Unit-of-Work in einer Datenbanksitzung an die Datenbank zu übertragen, wird normalerweise `commit()` aufgerufen. In einer transaktionalen Sitzung überträgt `commit()` nicht nur alle ausstehenden Änderungen in die Datenbank, sondern schließt auch die Transaktion ab (\"commits\") und schließt damit die Transaktion. Alternativ können Sie `session.flush()` aufrufen, um alle anstehenden Änderungen ohne `Commit` und damit ohne Abschluss der Transaktion zu übertragen. Um eine Transaktion zu committen, ohne die Unit-of-Work zu leeren, verwenden Sie `session.commitTransaction()`.": "虽然有一个替代的API（见下文），但所有的事务都只对数据库会话对象起作用。为了将数据库会话中的工作单元中未完成的修改提交给数据库，通常会调用`commit()`。在一个事务性会话中，`commit()`不仅向数据库提交所有未完成的修改，而且还完成了事务（\"提交\"），从而关闭事务。另外，你可以调用`session.flush()`来提交所有未完成的修改，而不用`commit`，因此也不用关闭事务。要提交一个事务而不清空工作单元，请使用`session.commitTransaction()`。",
        "Sobald `commit()` oder `rollback()` in einer Session ausgeführt wird, wird die Transaktion freigegeben. Sie müssen dann `useTransaction()` erneut aufrufen, wenn Sie in einer neuen Transaktion weiterarbeiten wollen.": "一旦`commit()`或`rollback()`在会话中被执行，事务就被释放。如果你想在一个新的交易中继续，你必须再次调用`useTransaction()`。",
        "Bitte beachten Sie, dass sobald die erste Datenbankoperation in einer transaktionalen Session ausgeführt wird, wird die zugewiesene Datenbankverbindung dem aktuellen Sitzungsobjekt fest und exklusiv zugewiesen (sticky). Somit werden alle nachfolgenden Operationen auf derselben Verbindung (und somit in den meisten Datenbanken auf demselben Datenbankserver) ausgeführt. Erst wenn entweder die transaktionale Session beendet wird (commit oder rollback), wird die Datenbankverbindung wieder freigegeben. Es ist daher zu empfehlen, eine Transaktion nur so kurz wie nötig zu halten.": "请注意，一旦在一个事务性会话中执行了第一个数据库操作，分配的数据库连接就会永久地、专门地分配给当前会话对象（粘性）。因此，所有后续操作都是在同一个连接上执行的（因此在同一个数据库服务器上的大多数数据库中）。只有当事务性会话被终止（提交或回滚）时，数据库连接才会被再次释放。因此，建议只在必要时保持交易的简短。",
        "Wenn eine Session bereits mit einer Transaktion verbunden ist, gibt ein Aufruf von `session.useTransaction()` immer das gleiche Objekt zurück. Verwenden Sie `session.isTransaction()`, um zu prüfen, ob der Sitzung eine Transaktion zugeordnet ist.": "如果一个会话已经与一个事务相关联，对`session.useTransaction()`的调用总是返回同一个对象。使用`session.isTransaction()`来检查交易是否与会话相关。",
        "Verschachtelte Transaktionen werden nicht unterstützt.": "不支持嵌套交易。",
        "Transaktion Callback": "交易回调",
        "Eine Alternative zu transaktionalen Sessions ist `database.transaction(callback)`.": "事务性会话的一个替代方法是`database.transaction(callback)`。",
        "Die Methode `database.transaction(callback)` führt einen asynchronen Callback innerhalb einer neuen transaktionalen Session aus. Wenn der Callback erfolgreich ist (das heisst kein Fehler geworfen wird), wird die Session automatisch committed (und damit ihre Transaktion committed und alle Änderungen geleert). Wenn der Callback fehlschlägt, führt die Sitzung automatisch `rollback()` aus, und der Fehler wird weitergeleitet.": "`database.transaction(callback)`方法在一个新的事务性会话中执行一个异步回调。如果回调成功（即没有抛出错误），会话就会自动提交（从而提交其事务并刷新所有更改）。如果回调失败，会话自动执行`rollback()`，并且错误被传播。",
        "Viele Datenbanken unterstützen verschiedene Arten von Transaktionen. Um das Transaktionsverhalten zu ändern, können Sie verschiedene Methoden für das zurückgegebene Transaktionsobjekt von `useTransaction()` aufrufen. Die Schnittstelle dieses Transaktionsobjekts hängt von dem verwendeten Datenbankadapter ab. Zum Beispiel hat das von einer MySQL-Datenbank zurückgegebene Transaktionsobjekt andere Optionen als das von einer MongoDB-Datenbank zurückgegebene. Verwenden Sie die Code-Vervollständigung oder sehen Sie sich die Schnittstelle des Datenbankadapters an, um eine Liste der möglichen Optionen zu erhalten.": "许多数据库支持不同类型的交易。为了改变交易行为，你可以为`useTransaction()`返回的交易对象调用不同的方法。这个事务对象的接口取决于所使用的数据库适配器。例如，从MySQL数据库返回的交易对象与从MongoDB数据库返回的交易对象有不同的选项。使用代码补全或查看数据库适配器的界面以获得可能的选项列表。",
        "Während Transaktionen für MySQL, PostgreSQL und SQLite standardmäßig funktionieren, müssen Sie MongoDB zunächst als \"Replikatsatz\" einrichten.": "虽然MySQL、PostgreSQL和SQLite的交易默认是有效的，但你必须首先将MongoDB设置为一个 \"复制集\"。",
        "Um eine Standard-MongoDB-Instanz in ein Replikatset zu konvertieren, lesen Sie bitte die offizielle Dokumentation link:https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[Convert a Standalone to a Replica Set].": "要将一个标准的MongoDB实例转换为一个副本集，请参考官方文档链接：https://docs.mongodb.com/manual/tutorial/convert-standalone-to-replica-set/[将单机转换为一个副本集]。",
        "Composite Primary-Key bedeutet, eine Entität hat mehrere Primärschlüssel, die automatisch zu einem \"zusammengesetzten Primärschlüssel\" zusammengefasst werden. Diese Art der Modellierung der Datenbank hat Vor- und Nachteile. Wir sind der Meinung, dass zusammengesetzte Primärschlüssel enorme praktische Nachteile haben, die ihre Vorteile nicht rechtfertigen, sodass sie als schlechte Praxis betrachtet werden sollten und daher vermieden werden sollten. Deepkit ORM unterstützt keine zusammengesetzten Primärschlüssel. In diesem Kapitel erklären wir warum und zeigen (bessere) Alternativen auf.": "复合主键是指一个实体有几个主键，这些主键被自动组合成一个 \"复合主键\"。这种建立数据库模型的方式有优点也有缺点。我们认为复合主键有巨大的实际缺点，不能证明它们的优点，所以它们应该被认为是不好的做法，因此要避免。Deepkit ORM不支持复合主键。在本章中，我们将解释原因并展示（更好的）替代方案。",
        "Nachteile": "劣势",
        "Joins sind nicht trivial. Obwohl sie in RDBMS hochgradig optimiert sind, stellen sie in Anwendungen eine ständige Komplexität dar, die leicht aus dem Ruder laufen und zu Leistungsproblemen führen kann. Leistung nicht nur in Bezug auf die Ausführungszeit der Abfragen, sondern auch in Bezug auf die Entwicklungszeit.": "连接并不是微不足道的。尽管它们在RDBMS中被高度优化，但它们在应用程序中代表了一种持续的复杂性，很容易失控并导致性能问题。性能不仅体现在查询执行时间上，也体现在开发时间上。",
        "Joins": "加入",
        "Jeder einzelne Join wird komplizierter, je mehr Felder beteiligt sind. Während viele Datenbanken Optimierungen implementiert haben, um Joins mit mehreren Feldern nicht per se langsamer zu machen, erfordert es vom Entwickler, diese Joins ständig im Detail zu durchdenken, da z. B. das Vergessen von Schlüsseln zu subtilen Fehlern führen kann (da der Join auch ohne Angabe aller Schlüssel funktioniert) und der Entwickler daher die vollständige zusammengesetzte Primärschlüsselstruktur kennen muss.": "涉及的字段越多，每个单独的连接就变得越复杂。虽然许多数据库已经实现了优化，使多字段的连接本身并不慢，但它要求开发人员不断地详细思考这些连接，因为，例如，忘记键可能会导致微妙的错误（因为即使没有指定所有的键，连接也会工作），因此开发人员需要知道完整的复合主键结构。",
        "Indizes": "指数",
        "Indizes mit mehreren Feldern (die zusammengesetzte Primärschlüssel sind) leiden unter dem Problem der Feldreihenfolge in Abfragen. Während Datenbanksysteme bestimmte Abfragen optimieren können, ist es bei komplexen Strukturen schwierig, effiziente Operationen zu schreiben, die alle definierten Indizes korrekt nutzen. Bei einem Index mit mehreren Feldern (wie einem zusammengesetzten Primärschlüssel) ist es normalerweise erforderlich, die Felder in der richtigen Reihenfolge zu definieren, damit die Datenbank den Index tatsächlich verwenden kann. Wenn die Reihenfolge nicht korrekt angegeben ist (z. B. in einer WHERE-Klausel), kann dies leicht dazu führen, dass die Datenbank den Index überhaupt nicht verwendet und stattdessen eine vollständige Tabellendurchsuchung durchführt. Zu wissen, welche Datenbank-Abfrage auf welche Weise optimiert, ist ein fortgeschrittenes Wissen, über das neue Entwickler in der Regel nicht verfügen, das aber erforderlich ist, sobald Sie mit zusammengesetzten Primärschlüsseln arbeiten, damit Sie das Beste aus Ihrer Datenbank herausholen und keine Ressourcen verschwenden.": "有多个字段的指数（属于复合主键）在查询中存在字段顺序的问题。虽然数据库系统可以优化某些查询，但对于复杂的结构，很难编写出正确使用所有定义索引的有效操作。对于一个有多个字段的索引（比如复合主键），通常需要以正确的顺序定义字段，以便数据库能够实际使用该索引。如果顺序没有被正确指定（例如在WHERE子句中），这很容易导致数据库根本不使用索引，而是执行全表扫描。知道哪种数据库查询以哪种方式进行优化是新的开发人员通常不具备的高级知识，但在你开始使用复合主键时就必须知道，这样你才能从数据库中获得最大的收益，不浪费资源。",
        "Migrationen": "迁移",
        "Sobald Sie entscheiden, dass eine bestimmte Entität ein zusätzliches Feld zur eindeutigen Identifizierung (und damit zum Composite Primary Key wird) benötigt, führt dies zur Anpassung aller Entitäten in Ihrer Datenbank, die Beziehungen zu dieser Entität haben.": "一旦你决定一个特定的实体需要一个额外的字段来唯一地识别它（从而成为复合主键），这将导致你数据库中所有与该实体有关系的实体的调整。",
        "Nehmen wir an, Sie haben z. B. eine Entität `User` mit zusammengesetztem Primärschlüssel und beschließen, in verschiedenen Tabellen einen Fremdschlüssel zu diesem `User` zu verwenden, z. B. in einer Pivot-Tabelle `audit_log`, `groups` und `posts`. Sobald Sie den Primärschlüssel von `User` ändern, müssen alle diese Tabellen in einer Migration ebenfalls angepasst werden.": "例如，假设你有一个带有复合主键的实体 \"用户\"，你决定在不同的表中使用这个 \"用户 \"的外键，例如在透视表 \"审计_日志\"、\"组 \"和 \"帖子 \"中。只要你改变了`user'的主键，所有这些表也必须在迁移中进行调整。",
        "Dies macht Migrationsdateien nicht nur viel komplexer, sondern kann auch zu größeren Ausfallzeiten bei der Ausführung von Migrationsdateien führen, da Schemaänderungen in der Regel entweder eine vollständige Datenbanksperre oder zumindest eine Tabellensperre erfordern. Je mehr Tabellen von einer großen Änderung wie einer Indexänderung betroffen sind, desto länger dauert die Migration. Und je größer eine Tabelle ist, desto länger dauert die Migration.": "这不仅使迁移文件变得更加复杂，而且在运行迁移文件时也会导致更大的停机时间，因为模式的改变通常需要一个完整的数据库锁或至少一个表锁。受大型变化（如索引变化）影响的表越多，迁移的时间就越长。而桌子越大，迁移的时间就越长。",
        "Denken Sie an die Tabelle `audit_log`. Solche Tabellen haben in der Regel viele Datensätze (etwa Millionen), und Sie müssen sie bei einer Schemaänderung nur deshalb anfassen, weil Sie beschlossen haben, einen zusammengesetzten Primärschlüssel zu verwenden und dem Primärschlüssel von `User` ein zusätzliches Feld hinzuzufügen. Je nach Größe all dieser Tabellen werden Migrationsänderungen dadurch entweder unnötig teurer oder in einigen Fällen sogar so teuer, dass eine Änderung des Primärschlüssels von `User` finanziell nicht mehr vertretbar ist. Dies führt in der Regel zu Umgehungslösungen (z. B. Hinzufügen eines eindeutigen Indexes zur Benutzertabelle), die zu technischen Schulden führen und früher oder später auf der Liste der Altlasten landen.": "考虑一下`audit_log`表。这样的表通常有很多记录（几百万条左右），你只需要在改变模式时接触它们，因为你已经决定使用复合主键，并在`用户'的主键上增加一个额外的字段。根据所有这些表的大小，这要么使迁移的费用不必要地增加，要么在某些情况下，费用高到改变 \"用户 \"的主键在经济上不再是合理的。这通常会导致变通的方法（例如给用户表添加唯一索引），导致技术债务，并迟早会被列入遗留问题清单。",
        "Bei großen Projekten kann dies zu enormen Ausfallzeiten führen (von Minuten bis Stunden) und manchmal sogar zur Einführung eines völlig neuen Migrationsabstraktionssystems, das im Wesentlichen Tabellen kopiert, Datensätze in Geistertabellen einfügt und nach der Migration Tabellen hin und her verschiebt. Diese zusätzliche Komplexität wird wiederum jeder Entität aufgezwungen, die eine Beziehung zu einer anderen Entität mit einem zusammengesetzten Primärschlüssel hat, und wird umso größer, je größer Ihre Datenbankstruktur wird. Das Problem wird immer schlimmer, ohne dass es eine Möglichkeit gibt, es zu lösen (außer durch die vollständige Entfernung des zusammengesetzten Primärschlüssels).": "对于大型项目来说，这可能会导致巨大的停机时间（从几分钟到几小时不等），有时甚至会引入一个全新的迁移抽象系统，该系统基本上是复制表，将记录插入幽灵表，在迁移后来回移动表。这种增加的复杂性反过来又强加在任何与另一个实体有复合主键关系的实体身上，而且你的数据库结构越大，这种复杂性就越大。这个问题越来越严重，没有办法解决（除了完全删除复合主键）。",
        "Auffindbarkeit": "可查找性",
        "Wenn Sie Datenbankadministrator oder Data Engineer/Scientist sind, arbeiten Sie in der Regel direkt an der Datenbank und erkunden die Daten, wenn Sie sie brauchen. Bei zusammengesetzten Primärschlüsseln muss jeder Benutzer, der SQL direkt schreibt, von allen beteiligten Tabellen den richtigen Primärschlüssel kennen (und die Spaltenreihenfolge, um korrekte Indexoptimierungen zu erhalten). Dieser zusätzliche Overhead erschwert nicht nur die Untersuchung von Daten, die Erstellung von Berichten usw., sondern kann auch zu Fehlern in älterem SQL führen, wenn ein zusammengesetzter Primärschlüssel plötzlich geändert wird. Das alte SQL ist wahrscheinlich immer noch gültig und läuft einwandfrei, liefert aber plötzlich falsche Ergebnisse, da das neue Feld im zusammengesetzten Primärschlüssel in der Verknüpfung fehlt. Es ist hierbei viel einfacher, lediglich einen Primärschlüssel zu haben. Dies erleichtert die Auffindbarkeit von Daten und stellt sicher, dass alte SQL-Abfragen auch dann noch korrekt funktionieren, wenn Sie sich entscheiden, die Art und Weise zu ändern, wie zum Beispiel ein Benutzerobjekt eindeutig identifiziert wird.": "如果你是一个数据库管理员或数据工程师/科学家，你通常直接在数据库上工作，并在需要时探索数据。有了复合主键，任何直接编写SQL的用户都需要知道所有涉及的表的正确主键（以及列的顺序以获得正确的索引优化）。这种额外的开销不仅使检查数据、创建报告等变得困难，而且如果一个复合主键突然被改变，还会导致旧的SQL出错。旧的SQL可能仍然有效并且运行良好，但是突然返回不正确的结果，因为复合主键中的新字段在连接中丢失了。在这里，只有一个主键要容易得多。这使得查找数据更加容易，并确保在你决定改变用户对象的唯一识别方式时，旧的SQL查询仍能正常工作，例如。",
        "Überarbeitung": "修订版",
        "Sobald ein zusammengesetzter Primärschlüssel in einer Entität verwendet wird, kann ein Refactoring des Schlüssels zu einem erheblichen zusätzlichen Refactoring führen. Da eine Entität mit einem zusammengesetzten Primärschlüssel in der Regel kein einzelnes eindeutiges Feld hat, müssen alle Filter und Verknüpfungen alle Werte des zusammengesetzten Schlüssels enthalten. Das bedeutet in der Regel, dass der Code auf die Kenntnis des zusammengesetzten Primärschlüssels angewiesen ist, sodass alle Felder abgerufen werden müssen (z. B. für URLs wie /user/:key1/:key2). Sobald dieser Schlüssel geändert wird, müssen alle Stellen, an denen dieses Wissen explizit verwendet wird, wie URLs, benutzerdefinierte SQL-Abfragen und andere Stellen, umgeschrieben werden.": "一旦在一个实体中使用了复合主键，重构该键就会导致大量的额外重构。由于具有复合主键的实体通常没有一个唯一的字段，所有的过滤器和链接必须包含复合主键的所有值。这通常意味着代码依赖于对复合主键的了解，因此必须检索所有字段（例如对于像/user/:key1/:key2这样的URL）。一旦这个键被改变，所有明确使用这个知识的地方，如URL、自定义SQL查询和其他地方，都必须被重写。",
        "Während ORMs in der Regel Joins automatisch erstellen, ohne die Werte manuell zu spezifizieren, können sie nicht automatisch das Refactoring für alle anderen Anwendungsfälle wie URL-Strukturen oder benutzerdefinierte SQL-Abfragen abdecken, und vor allem nicht für Stellen, an denen das ORM gar nicht verwendet wird, wie in Berichtssystemen und allen externen Systemen.": "虽然ORM通常会自动创建连接，而不需要手动指定值，但它们不能自动涵盖所有其他用例的重构，如URL结构或自定义SQL查询，尤其是在完全不使用ORM的地方，如报告系统和所有外部系统中。",
        "ORM-Komplexität": "ORM的复杂性",
        "Durch die Unterstützung von zusammengesetzten Primärschlüsseln steigt die Komplexität des Codes eines leistungsstarken ORM wie Deepkit ORM enorm an. Nicht nur, dass der Code und die Wartung komplexer und damit teurer werden, es werden auch mehr Edge-Cases von Benutzern auftreten, die behoben und gewartet werden müssen. Die Komplexität der Abfrageschicht, der Änderungserkennung, des Migrationssystems, der internen Verfolgung von Beziehungen usw. nimmt erheblich zu. Die Gesamtkosten, die mit dem Aufbau und der Unterstützung eines ORM mit zusammengesetzten Primärschlüsseln verbunden sind, sind alles in allem zu hoch und nicht zu rechtfertigen, weshalb Deepkit dies nicht unterstützt.": "支持复合主键会极大地增加像Deepkit ORM这样的强大ORM的代码的复杂性。不仅代码和维护会变得更加复杂，因此更加昂贵，而且会有更多来自用户的边缘案例需要被修复和维护。查询层、变化检测、迁移系统、内部跟踪关系等的复杂性大大增加。总的来说，建立和支持具有复合主键的ORM的整体成本太高，无法证明其合理性，这就是Deepkit不支持它的原因。",
        "Vorteile": "优势",
        "Abgesehen davon haben zusammengesetzte Primärschlüssel auch Vorteile, wenn auch nur sehr oberflächliche. Durch die Verwendung einer möglichst geringen Anzahl von Indizes für jede Tabelle wird das Schreiben (Einfügen/Aktualisieren) von Daten effizienter, da weniger Indizes gepflegt werden müssen. Außerdem wird die Struktur des Modells etwas sauberer (da es normalerweise eine Spalte weniger hat). Der Unterschied zwischen einem sequentiell geordneten, automatisch inkrementierenden Primärschlüssel und einem nicht inkrementierenden Primärschlüssel ist heutzutage jedoch völlig vernachlässigbar, da Festplattenplatz billig ist und der Vorgang in der Regel nur ein \"Append-Only\"-Vorgang ist, der sehr schnell ist.": "除此之外，复合主键也有优势，尽管是非常表面的优势。通过对每个表使用尽可能少的索引，写入（插入/更新）数据变得更加高效，因为需要维护的索引更少。这也使模型的结构更简洁一些（因为它通常少了一列）。然而，按顺序排列、自动递增的主键和不递增的主键之间的差别现在完全可以忽略不计，因为磁盘空间很便宜，而且这个过程通常只是一个追加操作，非常快。",
        "Es mag sicherlich ein paar Randfälle geben (und für ein paar sehr spezifische Datenbanksysteme), in denen es zunächst besser ist, mit zusammengesetzten Primärschlüsseln zu arbeiten. Aber selbst in diesen Systemen könnte es insgesamt (unter Berücksichtigung aller Kosten) sinnvoller sein, sie nicht zu verwenden und zu einer anderen Strategie zu wechseln.": "当然，在一些边缘情况下（以及一些非常特殊的数据库系统），最初使用复合主键会更好。但即使在这些系统中，不使用它们而改用另一种策略，总体上可能更合理（考虑到所有成本）。",
        "Alternative": "替代方案",
        "Eine Alternative zu zusammengesetzten Primärschlüsseln ist die Verwendung eines einzigen automatisch inkrementierenden numerischen Primärschlüssels, in der Regel \"id\" genannt, und die Verlagerung des zusammengesetzten Primärschlüssels in einen eindeutigen Index mit mehreren Feldern. Je nach verwendetem Primärschlüssel (abhängig von der erwarteten Zeilenzahl) verwendet die \"id\" entweder 4 oder 8 Bytes pro Datensatz.": "复合主键的一个替代方法是使用一个自动递增的数字主键，通常称为 \"id\"，并将复合主键移到一个具有多个字段的唯一索引中。根据所使用的主键（取决于预期的行数），\"id \"每条记录使用4或8个字节。",
        "Durch den Einsatz dieser Strategie ist man nicht mehr gezwungen, über die oben beschriebenen Probleme nachzudenken und eine Lösung zu finden, was die Kosten für immer größer werdende Projekte enorm senkt.": "通过使用这种策略，人们不再被迫思考上述问题并找到解决方案，这极大地降低了越来越大的项目的成本。",
        "Die Strategie bedeutet konkret, dass jede Entität ein \"id\"-Feld hat, normalerweise ganz am Anfang, und dieses Feld wird dann verwendet, um standardmäßig eindeutige Zeilen und in Joins zu identifizieren.": "该策略的具体含义是，每个实体都有一个 \"id \"字段，通常在最开始，然后这个字段在默认情况下和连接中被用来识别唯一的行。",
        "Als Alternative zu einem zusammengesetzten Primärschlüssel würden Sie stattdessen einen eindeutigen Mehrfeldindex verwenden.": "作为复合主键的替代品，你可以使用唯一的多字段索引来代替。",
        "Deepkit ORM unterstützt automatisch inkrementelle Primärschlüssel, auch für MongoDB. Dies ist die bevorzugte Methode zur Identifizierung von Datensätzen in Ihrer Datenbank. Für MongoDB können Sie jedoch die ObjectId (`_id: MongoId & PrimaryKey = ''`) als einfachen Primärschlüssel verwenden. Eine Alternative zum numerischen, automatisch inkrementierenden Primärschlüssel ist eine UUID, die ebenso gut funktioniert (jedoch etwas andere Leistungsmerkmale aufweist, da die Indexierung teurer ist).": "Deepkit ORM自动支持增量主键，包括对MongoDB。这是在数据库中识别记录的首选方法。然而，对于MongoDB，你可以使用ObjectId（`_id: MongoId & PrimaryKey = ''`）作为一个简单的主键。数字化的、自动递增的主键的一个替代品是UUID，它的效果同样好（但性能特征略有不同，因为索引的成本更高）。",
        "Zusammenfassung": "摘要",
        "Zusammengesetzte Primärschlüssel bedeuten im Wesentlichen, dass nach ihrer Einführung alle künftigen Änderungen und die praktische Verwendung mit wesentlich höheren Kosten verbunden sind. Während es zu Beginn wie eine saubere Architektur aussieht (weil man eine Spalte weniger hat), führt es zu erheblichen praktischen Kosten, sobald das Projekt tatsächlich entwickelt wird, und die Kosten steigen weiter, je größer das Projekt wird.": "复合主键本质上意味着，一旦它们到位，未来所有的变化和实际使用都要付出更高的代价。虽然它在开始时看起来是一个干净的架构（因为你少了一列），但一旦项目实际开发，它就会导致大量的实际成本，而且随着项目的扩大，成本会进一步增加。",
        "Betrachtet man die Asymmetrien zwischen Vor- und Nachteilen, so wird deutlich, dass zusammengesetzte Primärschlüssel in den meisten Fällen nicht zu rechtfertigen sind. Die Kosten sind viel größer als der Nutzen. Nicht nur für Sie als Benutzer, sondern auch für uns als Autor und Betreuer des ORM-Codes. Aus diesem Grund unterstützt Deepkit ORM keine zusammengesetzten Primärschlüssel.": "看一下优势和劣势之间的不对称性，就会发现复合主键在大多数情况下是不成立的。其成本远远大于收益。不仅是对作为用户的你，而且对作为ORM代码的作者和维护者的我们。由于这个原因，Deepkit ORM不支持复合主键。",
        "Das Soft-Delete Plugin ermöglicht es, Datenbankeinträge versteckt zu halten, ohne sie tatsächlich zu löschen. Wenn ein Datensatz gelöscht wird, wird er nur als gelöscht markiert und nicht wirklich gelöscht. Alle Abfragen filtern automatisch nach dieser gelöschten Eigenschaft, sodass es sich für den Benutzer so anfühlt, als ob er tatsächlich gelöscht wäre.": "软删除插件使隐藏数据库记录而不实际删除它们成为可能。当一条记录被删除时，它只被标记为删除，而不是实际删除。所有的查询都会自动过滤这个被删除的属性，所以对用户来说，感觉就像它真的被删除了一样。",
        "Um das Plugin zu verwenden, müssen Sie die SoftDelete-Klasse instanziieren und sie für jede Entität aktivieren.": "要使用该插件，你必须实例化SoftDelete类，并为每个实体激活它。",
        "Löschen": "删除",
        "Um Datensätze sanft zu löschen, verwenden Sie die üblichen Methoden: `deleteOne` oder `deleteMany` in einer Abfrage, oder Sie verwenden die Session, um sie zu löschen. Das Soft-Delete Plugin erledigt den Rest automatisch im Hintergrund.": "要软删除记录，使用通常的方法：查询中的`deleteOne`或`deleteMany`，或使用会话来删除它们。软删除插件在后台自动完成其余工作。",
        "Wiederherstellen": "恢复",
        "Gelöschte Datensätze können mithilfe einer aufgehobenen Abfrage über `SoftDeleteQuery` wiederhergestellt werden. Es hat `restoreOne` und `restoreMany`.": "被删除的记录可以通过`SoftDeleteQuery`使用取消的查询来恢复。它有`restoreOne`和`restoreMany`。",
        "Die Session unterstützt auch die Wiederherstellung von Elementen.": "该会议还支持元素的恢复。",
        "Hard Delete": "硬删除",
        "Um Datensätze hart zu löschen, verwenden Sie eine gehobene Abfrage über SoftDeleteQuery. Dies stellt im Wesentlichen das alte Verhalten ohne das Plugin für eine einzelne Abfrage wieder her.": "要硬删除记录，请通过SoftDeleteQuery使用解除的查询。这基本上恢复了没有单一查询插件的旧行为。",
        "Query deleted.": "查询删除。",
        "Bei einem \"lifted\" Query über `SoftDeleteQuery` können Sie auch gelöschte Datensätze einbeziehen.": "通过`SoftDeleteQuery`的 \"解除 \"查询，你也可以包括已删除的记录。",
        "Deleted by": "被删除的",
        "`deletedBy` kann über Abfrage und Sessions festgelegt werden.": "`deletedBy`可以通过查询和会话设置。",
        "Alle Arten von Providern werden in der Sektion xref:dependency-injection.adoc#di-providers[Dependency Injection Providers] aufgelistet und erklärt.": "所有类型的提供者都在xref:dependency-injection.adoc#di-providers[依赖注入提供者]一节中列出并解释。",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel xref:runtime-types.adoc[Runtime Types].": "这里需要提到的是，Deepkit的DI容器只适用于Deepkit的运行时类型。这意味着任何包含类、类型、接口和函数的代码都必须经过Deepkit类型编译器的编译，以便在运行时获得类型信息。参见xref:runtime-types.adoc[Runtime Types]一章。",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit中的依赖注入是基于运行时类型的，因此有必要正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion xref:dependency-injection.adoc#di-providers[Dependency Injection Providers], um zu erfahren, welche Werte übergeben werden können.": "在这种情况下，`injector`对象是依赖注入容器。函数`InjectorContext.forProviders`接收一个提供者的数组。参见xref:dependency-injection.adoc#di-providers[依赖注入提供者]一节，了解哪些值可以被传递。",
        "Asynchronous Providers": "异步提供者",
        "Asynchroner Provider sind aufgrund des Designs nicht möglich, da eine asynchroner": "由于设计原因，异步提供者是不可能的，因为异步的",
        "Dependency Injection Container bedeuten würde, dass das Anfordern von Providern ebenfalls asynchron": "依赖性注入容器将意味着对提供者的请求也是异步的。",
        "wäre und damit die gesamte Anwendung auf höchster Ebene bereits zur asynchronität gezwungen ist.": "因此，整个应用程序在最高级别上已经被迫进入异步状态。",
        "Um etwas asynchron zu initialisieren, sollte dieses Initialisieren in den Application Server Bootstrap verlagert werden,": "要异步初始化一些东西，这个初始化应该被移到应用服务器的启动阶段。",
        "da dort die Events asynchron sein können. Alternativ kann eine Initialisierung manuell angestossen werden.": "因为那里的事件可以是异步的。另外，也可以手动触发初始化。",
        "TODO: Explain it better, maybe example": "TODO: 更好地解释它，也许是例子",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln xref:validation.adoc[Validation] und xref:serialization.adoc[Serialization] genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "另外，前几章的所有序列化和验证类型xref:validation.adoc[验证]和xref:serialization.adoc[序列化]都可以用来非常详细地指定一个选项必须有哪些类型和内容限制。",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel xref:cli.adoc[CLI], xref:http.adoc[HTTP], oder": "与Deepkit框架一起工作的应用程序默认有一个`http`、一个`rpc`和一个`cli`范围。分别参见xref:cli.adoc[CLI], xref:http.adoc[HTTP], 或",
        "xref:rpc.adoc[RPC].": "xref:rpc.adoc[RPC]。",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit的事件系统是基于运行时类型的，因此有必要正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Deepkit Framework basiert auf Runtime Types in Deepkit Type. Stelle sicher, dass `@deepkit/type` korrekt installiert ist. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "Deepkit框架是基于Deepkit类型中的Runtime类型。确保`@deepkit/type`已正确安装。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Stellen Sie sicher, dass alle Peer-Abhängigkeiten installiert sind. Standardmäßig werden sie von NPM 7+ automatisch installiert.": "确保所有对等的依赖性都已安装。默认情况下，NPM 7+会自动安装它们。",
        "Um Ihre Anwendung zu kompilieren, benötigen wir den TypeScript-Compiler und empfehlen `ts-node`, um die App einfach auszuführen.": "为了编译你的应用程序，我们需要TypeScript编译器，并推荐`ts-node`来轻松运行应用程序。",
        "Eine Alternative zur Verwendung von `ts-node` besteht darin, den Quellcode mit dem TypeScript-Compiler zu kompilieren und den JavaScript-Quellcode direkt auszuführen. Dies hat den Vorteil, dass sich die Ausführungsgeschwindigkeit für kurze Befehle drastisch erhöht. Allerdings wird dadurch auch zusätzlicher Workflow-Overhead erzeugt, indem der Compiler entweder manuell ausgeführt oder ein Watcher eingerichtet wird. Aus diesem Grund wird in dieser Dokumentation in allen Beispielen `ts-node` verwendet.": "使用`ts-node`的另一种方法是用TypeScript编译器编译源代码，直接执行JavaScript源代码。这样做的好处是大幅提高短命令的执行速度。然而，通过手动运行编译器或设置观察器，它也会产生额外的工作流程开销。出于这个原因，本文档中的所有例子都使用了`ts-node`。",
        "Erste Applikation": "第一次申请",
        "Da das Deepkit Framework keine Konfigurationsdateien oder eine spezielle Ordnerstruktur verwendet, können Sie Ihr Projekt so strukturieren, wie Sie es wünschen. Die einzigen beiden Dateien, die Sie für den Start benötigen, sind die TypeScript-Datei app.ts und die TypeScript-Konfiguration tsconfig.json.": "由于Deepkit框架不使用配置文件或特殊的文件夹结构，你可以按照自己的意愿来构造你的项目。你唯一需要开始的两个文件是TypeScript文件app.ts和TypeScript配置tsconfig.json。",
        "Unser Ziel ist es, die folgenden Dateien in unserem Projektordner zu haben:": "我们的目标是在我们的项目文件夹中拥有以下文件。",
        "In diesem Code sehen Sie, dass wir einen Testbefehl über die Klasse `TestCommand` definiert und eine neue Anwendung erstellt haben, die wir direkt mit `run()` ausführen. Durch das Ausführen dieses Skripts starten wir die App.": "在这段代码中，你可以看到我们通过`TestCommand`类定义了一个测试命令，并创建了一个新的应用程序，我们直接用`run()`来运行。通过执行这个脚本，我们启动了应用程序。",
        "Mit dem Shebang in der ersten Zeile (`#!...`) können wir unser Skript mit dem folgenden Befehl ausführbar machen.": "有了第一行的shebang(`#!...`)，我们可以用下面的命令使我们的脚本可执行。",
        "Und dann ausführen:": "然后执行。",
        "Um nun unseren Testbefehl auszuführen, führen wir folgenden Befehl aus.": "现在，为了执行我们的测试命令，我们执行以下命令。",
        "In Deepkit Framework geschieht nun alles über diese `app.ts`. Sie können die Datei beliebig umbennen oder weitere anlegen. Eigene CLI commands, HTTP/RPC server, Migration commands, usw werden alle über diesen Einstiegspunkt gestartet.": "在Deepkit Framework中，现在所有的事情都是通过这个`app.ts`发生的。你可以随心所欲地重命名文件或创建更多的文件。自定义CLI命令、HTTP/RPC服务器、迁移命令等都是通过这个入口点启动。",
        "Um den HTTP/RPC-Server zu starten, führen Sie folgendes aus:": "要启动HTTP/RPC服务器，请执行以下操作。",
        "Um Anfragen bedienen zu können, lesen Sie bitte das Kapitel xref:http.adoc[HTTP] oder xref:rpc.adoc[RPC]. Im Kapitel xref:cli.adoc[CLI] kann mehr über CLI commands erfahren werden.": "为了能够为请求提供服务，请阅读xref:http.adoc[HTTP]或xref:rpc.adoc[RPC]章节。在xref:cli.adoc[CLI]一章中，你可以了解更多关于CLI的命令。",
        "App": "应用",
        "Über das `App`-Objekt startet wie Applikation.": "App \"对象启动应用程序。",
        "Die `run()`-Methode list dabei die Argumente aus und führt den entsprechenden CLI-Controller aus. Da `FrameworkModule` eigene CLI-Controller bereitstellt, die zum Beispiel für das Starten des HTTP-Servers verantwortlich sind, können diese darüber aufgerufen werden.": "`run()`方法列出参数并执行相应的CLI控制器。由于`FrameworkModule`提供了自己的CLI控制器，负责启动HTTP服务器，例如，可以通过它调用这些控制器。",
        "Über das `App`-Objekt kann auch der Dependency Injection Container angesprochen werden, ohne dass ein CLI-Controller ausgeführt wird.": "依赖性注入容器也可以通过`App`对象来解决，而不用执行CLI控制器。",
        "Deepkit Framework ist hochgradig modular und ermöglicht es Ihnen, Ihre Anwendung in mehrere praktische Module aufzuteilen. Jedes Modul hat seine eigene Dependency Injektion Sub-Container, Konfiguration, Befehle und vieles mehr. Im Kapitel \"Erste Applikation\" haben Sie bereits ein Modul erstellt - das Root-Modul. `new App` benötigt fast die gleichen Argumente wie ein Modul, denn es erstellt das Root-Modul im Hintergrund für Sie automatisch.": "Deepkit框架是高度模块化的，允许你将你的应用程序分成几个方便的模块。每个模块都有自己的依赖性注入子容器、配置、命令等等。在 \"第一个应用程序 \"一章中，你已经创建了一个模块--根模块。`new App`需要的参数和模块几乎一样，因为它在后台自动为你创建根模块。",
        "Sie können dieses Kapitel überspringen, wenn Sie nicht vorhaben, Ihre Anwendung in Untermodule aufzuteilen, oder wenn Sie nicht vorhaben, ein Modul als Paket für andere zur Verfügung zu stellen.": "如果你不打算把你的应用程序分成子模块，或者你不打算把一个模块作为包提供给其他人，你可以跳过这一章。",
        "Ein Modul ist eine einfache Klasse:": "一个模块是一个简单的类。",
        "Es hat zu diesem Zeitpunkt im Grunde keine Funktionalität, da seine Moduldefinition ein leeres Objekt ist und es keine Methoden hat, aber dies demonstriert die Beziehung zwischen Modulen und Ihrer Anwendung (Ihrem Stammmodul). Dieses Modul MyModule kann dann in Ihrer Anwendung oder in anderen Modulen importiert werden.": "在这个阶段，它基本上没有任何功能，因为它的模块定义是一个空对象，它没有任何方法，但这表明了模块和你的应用程序（你的根模块）之间的关系。然后，这个MyModule模块可以被导入到你的应用程序或其他模块中。",
        "Sie können nun diesem Modul Features hinzufügen, wie Sie es mit `App` tun würden. Die Argumente sind die gleichen, nur dass Importe in einer Moduldefinition nicht verfügbar sind. Fügen Sie HTTP/RPC/CLI-Controller, Dienste, eine Konfiguration, Event-Listener sowie verschiedene Modul-Hooks hinzu, um Module dynamischer zu gestalten.": "现在你可以像使用`App'那样向这个模块添加功能。参数是一样的，只是在模块定义中不能使用导入。添加HTTP/RPC/CLI控制器、服务、一个配置、事件监听器和各种模块钩子，使模块更加动态。",
        "Controllers": "控制器",
        "Module können Controller definieren, die von anderen Modulen verarbeitet werden. Wenn Sie zum Beispiel einen Controller mit Dekoratoren aus dem `@deepkit/http`-Paket hinzufügen, wird sein Modul `HttpModule` dies aufgreifen und die gefundenen Routen in seinem Router registrieren. Ein einzelner Controller kann mehrere solcher Dekoratoren enthalten. Es liegt an dem Modulautor, der Ihnen diese Dekoratoren gibt, wie er die Controller verarbeitet.": "模块可以定义由其他模块处理的控制器。例如，如果你添加了一个带有`@deepkit/http`包的装饰器的控制器，它的模块`HttpModule`会接收到这一点，并注册在其路由器中发现的路由。一个控制器可以包含几个这样的装饰器。这取决于给你这些装饰器的模块作者如何处理这些控制器。",
        "In Deepkit gibt es drei Pakete, die solche Controller verarbeitet: HTTP, RPC, und CLI. Siehe jeweils deren Kapitel, um mehr zu erfahren. Nachfolgend ist ein Beispiel eines HTTP-Controllers:": "在Deepkit中，有三个包可以处理这种控制器。HTTP、RPC和CLI。请参阅他们各自的章节以了解更多信息。下面是一个HTTP控制器的例子。",
        "Provider": "供应商",
        "Wenn Sie einen Provider im `providers`-Bereich Ihrer Anwendung definieren, ist dieser in Ihrer gesamten Anwendung zugänglich. Bei Modulen hingegen werden diese Provider automatisch in den Subcontainer für die Injektion von Abhängigkeiten dieses Moduls gekapselt. Sie müssen jeden Provider manuell exportieren, um ihn für ein anderes Modul bzw. ihrer Anwendung verfügbar zu machen.": "如果你在你的应用程序的`providers'区域定义了一个提供者，它可以在整个应用程序中被访问。另一方面，对于模块，这些提供者被自动封装在子容器中，用于注入该模块的依赖关系。你必须手动导出每个提供者，使其对另一个模块或你的应用程序可用。",
        "Um mehr darüber zu erfahren, wie Provider funktionieren, lesen Sie bitte das Kapitel xref:dependency-injection.adoc[Dependency Injection].": "要了解更多关于提供者的工作原理，请阅读xref:dependency-injection.adoc[依赖注入]一章。",
        "Wenn ein Benutzer dieses Modul importiert, hat er keinen Zugriff auf `HelloWorldService`, da dieser im Subdependency-Injection-Container von `MyModule` gekapselt ist.": "当用户导入这个模块时，他们将无法访问`HelloWorldService`，因为它被封装在`MyModule`的子依赖注入容器中。",
        "Exports": "出口",
        "Um Provider im Modul des Importeurs verfügbar zu machen, können Sie den Token des Providers in `exports` aufnehmen. Dadurch wird der Provider im Wesentlichen eine Ebene nach oben in den Dependency-Injection-Container des übergeordneten Moduls - des Importeurs - verschoben.": "为了使提供者在导入者的模块中可用，你可以在`exports`中包括提供者的token。这实质上是将提供者上移到父模块的依赖注入容器中的一个层次--进口商。",
        "Wenn Sie andere Provider wie `FactoryProvider`, `UseClassProvider` usw. haben, sollten Sie trotzdem nur den Klassentyp in den Exporten verwenden.": "如果你有其他的提供者，如`FactoryProvider`，`UseClassProvider`等，你仍然应该只在出口中使用类类型。",
        "We can now import that module and use its exported service in our application code.": "我们现在可以导入该模块并在我们的应用程序代码中使用其导出的服务。",
        "Lesen Sie das Kapitel xref:dependency-injection.adoc[Dependency Injection] um mehr darüber zu erfahren.": "阅读xref:dependency-injection.adoc[依赖注入]一章，了解更多。",
        "Im Deepkit Framework können Module und Ihre Anwendung über Konfigurationsoptionen verfügen. Eine Konfiguration kann z.B. aus Datenbank-URLs, Passwörtern, IPs usw. bestehen. Services, HTTP/RPC/CLI Controller sowie Template Funktionen können diese Konfigurationsoptionen über Dependency Injection auslesen.": "在Deepkit框架中，模块和你的应用程序可以有配置选项。例如，一个配置可以由数据库的URL、密码、IP等组成。服务、HTTP/RPC/CLI控制器和模板函数可以通过依赖性注入读取这些配置选项。",
        "Eine Konfiguration kann durch die Definition einer Klasse mit Eigenschaften definiert werden. Dies ist ein typsicherer Weg, um eine Konfiguration für Ihre gesamte Anwendung zu definieren, und ihre Werte werden automatisch serialisiert und validiert.": "一个配置可以通过定义一个带有属性的类来定义。这是一种类型安全的方式，可以为你的整个应用程序定义一个配置，其值会被自动序列化和验证。",
        "Beispiel": "例子",
        "Konfigurationsklasse": "配置类",
        "Die Werte für die Konfigurationsoptionen können entweder im Konstruktor des Moduls, mit der Methode `.configure()` oder über Konfigurationslader (z.B. Umgebungsvariablenlader) bereitgestellt werden.": "配置选项的值可以在模块的构造函数中提供，通过`.configure()`方法或通过配置加载器（如环境变量加载器）。",
        "Um die Konfigurationsoptionen eines importierten Moduls dynamisch zu ändern, können Sie den `process` Hook verwenden. Dies ist ein guter Ort, um entweder Konfigurationsoptionen umzuleiten oder ein importiertes Modul abhängig von der aktuellen Modulkonfiguration oder anderen Modulinstanzinformationen einzurichten.": "要动态地改变一个导入的模块的配置选项，你可以使用`process`钩子。这是一个很好的地方，既可以重定向配置选项，也可以根据当前的模块配置或其他模块实例信息设置导入的模块。",
        "Auf der Anwendungsebene funktioniert es etwas anders:": "在应用层面，它的工作方式有点不同。",
        "Wenn das Root-Anwendungsmodul aus einem regulären Modul erstellt wird, funktioniert es ähnlich wie reguläre Module.": "当根应用程序模块由普通模块创建时，其功能与普通模块类似。",
        "Konfigurationsoptionen Auslesen": "配置选项 读出",
        "Um eine Konfigurationsoption in einem Dienst zu verwenden, können Sie die normale Dependency Injection verwenden. Es ist möglich, entweder das gesamte Konfigurationsobjekt, einen einzelnen Wert oder einen Teil der Konfiguration zu injizieren.": "要在服务中使用配置选项，你可以使用正常的依赖注入。可以注入整个配置对象、单个值或配置的一部分。",
        "Partial": "部分",
        "Um nur einen Teilbereich der Konfigurationswerte zu injizieren, verwenden Sie den Typ `Pick`.": "要想只注入配置值的一个子集，请使用`pick`类型。",
        "Single value": "单一价值",
        "Um nur einen einzigen Wert zu injizieren, verwenden Sie den Indexzugriffsoperator.": "要只注入一个值，请使用索引访问操作符。",
        "All": "全部",
        "To inject all config values, use the class as dependency.": "要注入所有的配置值，请使用该类作为依赖关系。",
        "Die Konfigurationswerte Ihrer Anwendung und aller Module können im Debugger angezeigt werden. Aktivieren Sie die Debug-Option im `FrameworkModul` und öffnen Sie `http://localhost:8080/_debug/configuration`.": "你的应用程序和所有模块的配置值都可以在调试器中显示。激活`FrameworkModule`中的调试选项，并打开`http://localhost:8080/_debug/configuration`。",
        "Sie können auch `ts-node app.ts app:config` verwenden, um alle verfügbaren Konfigurationsoptionen, den aktiven Wert, ihren Standardwert, die Beschreibung und den Datentyp anzuzeigen.": "你也可以使用`ts-node app.ts app:config`来显示所有可用的配置选项、活动值、它们的默认值、描述和数据类型。",
        "Konfigurationswerte setzen": "设置配置值",
        "Standardmäßig werden keine Werte überschrieben, es werden also Standardwerte verwendet. Es gibt mehrere Möglichkeiten, Konfigurationswerte zu setzen.": "默认情况下，不会覆盖任何值，所以使用默认值。有几种方法来设置配置值。",
        "Umgebungsvariablen für jede Option": "每个选项的环境变量",
        "Umgebungsvariable über JSON": "通过JSON的环境变量",
        "dotenv-Dateien": "dotenv文件",
        "Sie können mehrere Methoden zum Laden der Konfiguration gleichzeitig verwenden. Die Reihenfolge, in der sie aufgerufen werden, ist dabei wichtig.": "你可以使用几种方法同时加载配置。它们被调用的顺序很重要。",
        "Environment variables": "环境变量",
        "Um die Einstellung jeder Konfigurationsoption über eine eigene Umgebungsvariable zu ermöglichen, verwenden Sie `loadConfigFromEnv`. Das Standardpräfix ist `APP_`, aber Sie können es ändern. Es lädt auch automatisch `.env`-Dateien. Standardmäßig wird eine Benennungsstrategie mit Großbuchstaben verwendet, aber auch das können Sie ändern.": "要允许通过自己的环境变量设置每个配置选项，请使用`loadConfigFromEnv`。默认的前缀是`APP_`，但你可以改变它。它还自动加载`.env`文件。默认情况下，它使用大写的命名策略，但你也可以改变这一点。",
        "Für Konfigurationsoptionen wie oben `pageTitle`, können Sie `APP_PAGE_TITLE=\"Anderer Titel\"` verwenden, um den Wert zu verändern.": "对于上述`pageTitle'这样的配置选项，你可以使用`APP_PAGE_TITLE=\"Other Title\"`来改变数值。",
        "JSON environment variable": "JSON环境变量",
        "Um mehrere Konfigurationsoptionen über eine einzige Umgebungsvariable zu ändern, verwenden Sie `loadConfigFromEnvVariable`. Das erste Argument ist der Name der Umgebungsvariablen.": "要通过一个环境变量改变多个配置选项，请使用`loadConfigFromEnvVariable`。第一个参数是环境变量的名称。",
        "DotEnv Dateien": "DotEnv文件",
        "Um mehrere Konfigurationsoptionen über eine dotenv-Datei zu ändern, verwenden Sie `loadConfigFromEnv`. Das erste Argument ist entweder ein Pfad zu einer dotenv (relativ zu `cwd`) oder mehrere Pfade. Wenn es ein Array ist, wird jeder Pfad ausprobiert, bis eine vorhandene Datei gefunden wird.": "要通过dotenv文件改变多个配置选项，使用`loadConfigFromEnv`。第一个参数是一个指向dotenv的路径（相对于`cwd`）或多个路径。如果它是一个数组，每个路径都被尝试，直到找到一个现有的文件。",
        "Module Configuration": "模块配置",
        "Jedes importierte Modul kann einen Modulnamen haben. Dieser Name wird für die oben verwendeten Konfigurationspfade verwendet.": "每个导入的模块都可以有一个模块名称。这个名字用于上面使用的配置路径。",
        "Für die Konfiguration von Umgebungsvariablen lautet der Pfad für die `FrameworkModule`-Option port beispielsweise `FRAMEWORK_PORT`. Alle Namen werden standardmäßig in Großbuchstaben geschrieben. Wenn ein Präfix von `APP_` verwendet wird, kann der Port über folgendes geändert werden:": "对于环境变量的配置，\"FrameworkModule \"选项端口的路径为例如 \"FRAMEWORK_PORT\"。所有的名字都默认以大写字母书写。如果使用`APP_`的前缀，可以通过以下方式改变端口。",
        "In Dotenv-Dateien wäre es auch `APP_FRAMEWORK_PORT=9999`.": "在Dotenv文件中，它也是`APP_FRAMEWORK_PORT=9999`。",
        "In JSON-Umgebungsvariablen über `loadConfigFromEnvVariable('APP_CONFIG')` hingegen ist es die Struktur der eigentlichen Konfigurationsklasse. `framework` wird zu einem Objekt.": "在JSON环境变量中通过`loadConfigFromEnvVariable('APP_CONFIG')`另一方面，它是实际配置类的结构。`framework`成为一个对象。",
        "Dies funktioniert für alle Module gleich. Für die Konfigurationsoption Ihrer Anwendung (`new App`) ist kein Modulpräfix erforderlich.": "这对所有模块的作用都是一样的。你的应用程序的配置选项（`new App`）不需要模块前缀。",
        "Das FrameworkModule bietet eine Möglichkeit, statische Dateien wie Bilder, PDFs, Binärdateien usw. über HTTP bereitzustellen. Mit der Konfigurationsoption `publicDir` können Sie angeben, welcher Ordner als Standard-Einstiegspunkt für Anfragen verwendet werden soll, die nicht zu einer HTTP-Controller-Route führen. Standardmäßig ist dieses Verhalten deaktiviert (leerer Wert).": "FrameworkModule提供了一种通过HTTP提供静态文件的方式，如图片、PDF、二进制文件等。通过配置选项`publicDir`，你可以指定哪个文件夹应该被用作不通往HTTP控制器路线的请求的默认入口点。默认情况下，这种行为是禁用的（空值）。",
        "Um die Bereitstellung öffentlicher Dateien zu aktivieren, setzen Sie `publicDir` auf einen Ordner Ihrer Wahl. Normalerweise würden Sie einen Namen wie `publicDir` wählen, um die Dinge offensichtlich zu machen.": "要启用公共文件的提供，将`publicDir`设置为你选择的文件夹。通常你会选择一个像`publicDir`这样的名字，使事情变得明显。",
        "Um die Option `publicDir` zu ändern, können Sie das erste Argument von `FrameworkModule` ändern.": "要改变`publicDir`选项，你可以改变`FrameworkModule`的第一个参数。",
        "Alle Dateien innerhalb dieses konfigurierten Ordners sind nun über HTTP zugänglich. Wenn Sie  beispielsweise `http://localhost:8080/logo.jpg` öffnen, sehen Sie das Bild `logo.jpg` im Verzeichnis `publicDir`.": "这个配置的文件夹内的所有文件现在都可以通过HTTP访问。例如，如果你打开`http://localhost:8080/logo.jpg`，你会看到`publicDir`目录下的图片`logo.jpg`。",
        "Deepkit verfügt über eine eigene leistungsstarke Datenbankabstraktionsbibliothek namens Deepkit ORM. Es handelt sich um eine ORM-Bibliothek (Object-Relational Mapping), die die Arbeit mit SQL-Datenbanken und MongoDB erleichtert.": "Deepkit有自己的强大的数据库抽象库，称为Deepkit ORM。它是一个对象关系映射（ORM）库，使其更容易与SQL数据库和MongoDB一起工作。",
        "Obwohl Sie jede beliebige Datenbankbibliothek verwenden können, empfehlen wir Deepkit ORM, da es die schnellste TypeScript-Datenbankabstraktionsbibliothek ist, die perfekt in das Deepkit-Framework integriert ist und viele Funktionen hat, die Ihren Workflow und Ihre Effizienz verbessern.": "虽然你可以使用任何数据库库，但我们推荐Deepkit ORM，因为它是最快的TypeScript数据库抽象库，与Deepkit框架完美结合，并有许多功能可以改善你的工作流程和效率。",
        "Um alle Informationen über Deepkit ORM zu erhalten, lesen Sie das Kapitel xref:database.adoc[Database].": "要获得关于Deepkit ORM的所有信息，请阅读xref:database.adoc[数据库]一章。",
        "Database Klassen": "数据库类",
        "Die einfachste Art, das `Database`-Objekt von Deepkit ORM innerhalb der Applikation zu verwenden, ist das Registrieren einer Klasse, die davon ableitet.": "在应用程序中使用Deepkit ORM的`Database'对象的最简单方法是注册一个从它派生的类。",
        "Erstellen Sie eine neue Klasse und geben Sie in ihrem Konstruktor den Adapter mit seinen Parametern an und fügen Sie dem zweiten Parameter alle Entitäten/Modelle hinzu, die mit dieser Datenbank verbunden sein sollen.": "创建一个新的类，并在其构造函数中指定带有参数的适配器，并在第二个参数中添加应连接到该数据库的所有实体/模型。",
        "Sie können nun diese Datenbankklasse als Provider registrieren. Wir aktivieren auch `migrateOnStartup`, das alle Tabellen in Ihrer Datenbank automatisch beim Bootstrap erstellt. Dies ist ideal für Rapid Prototyping, wird aber für ein ernsthaftes Projekt oder eine Produktionseinrichtung nicht empfohlen. Hier sollten dann normale Datenbank Migrationen verwendet werden.": "你现在可以把这个数据库类注册为一个提供者。我们还启用了`migrateOnStartup`，这将在启动时自动创建数据库中的所有表。这是快速制作原型的理想选择，但不建议用于严肃的项目或生产设置。那么这里应该使用正常的数据库迁移。",
        "Außerdem aktivieren wir `debug`, was uns erlaubt, den Debugger zu öffnen, wenn der Server der Anwendung gestartet wird, und Ihre Datenbankmodelle direkt in seinem integrierten ORM-Browser zu verwalten.": "我们还启用了`debug`，它允许我们在应用程序的服务器启动时打开调试器，并在其内置的ORM浏览器中直接管理你的数据库模型。",
        "Sie können nun überall auf `SQLiteDatabase` zugreifen, indem Sie Dependency Injection verwenden:": "现在你可以使用依赖注入在任何地方访问`SQLiteDatabase`。",
        "Mehr Datenbanken": "更多数据库",
        "Sie können so viele Datenbankklassen hinzufügen, wie Sie möchten, und sie so benennen, wie Sie möchten. Achten Sie darauf, den Namen jeder Datenbank zu ändern, damit sie bei der Verwendung des ORM-Browsers nicht mit anderen in Konflikt gerät.": "你可以添加任意多的数据库类，并按你喜欢的方式命名。请确保改变每个数据库的名称，以便在使用ORM浏览器时不会与其他数据库冲突。",
        "Daten Verwalten": "管理数据",
        "Sie haben jetzt alles eingerichtet, um Ihre Datenbankdaten mit dem Deepkit ORM Browser zu verwalten. Um den ORM-Browser zu öffnen und den Inhalt zu verwalten, schreiben Sie alle Schritte von oben in die Datei `app.ts` und starten den Server.": "现在你已经设置好了一切，可以用Deepkit ORM浏览器管理你的数据库数据。要打开ORM浏览器和管理内容，把上面的所有步骤写进`app.ts`文件并启动服务器。",
        "You can now open http://localhost:8080/_debug/database/default.": "你现在可以打开http://localhost:8080/_debug/database/default。",
        "Sie können das ER-Diagramm sehen. Im Moment ist nur eine Entität verfügbar. Wenn Sie weitere mit Beziehungen hinzufügen, sehen Sie alle Informationen auf einen Blick.": "你可以看到ER图。目前，只有一个实体可用。如果你增加了更多的与关系，你可以看到所有的信息，一目了然。",
        "Wenn Sie in der linken Seitenleiste auf `User` klicken, können Sie dessen Inhalt verwalten. Klicken Sie auf das `+`-Symbol, und ändern Sie den Titel des neuen Datensatzes. Nachdem Sie die erforderlichen Werte (wie den Benutzernamen) geändert haben, klicken Sie auf \"Bestätigen\". Dadurch werden alle Änderungen an die Datenbank übertragen und bleiben dauerhaft bestehen. Die Autoinkrement-ID wird automatisch zugewiesen.": "如果你点击左侧边栏的 \"用户\"，你可以管理其内容。点击`+`符号，改变新记录的标题。在你修改了所需的值（如用户名）后，点击 \"确认\"。这将把所有的变化转移到数据库，并使它们成为永久性的。自动增量ID是自动分配的。",
        "Mehr Lernen": "了解更多",
        "Um mehr über die Funktionsweise von `SQLiteDatabase` zu erfahren, lesen Sie bitte das Kapitel xref:database.adoc[Database] und seine Unterkapitel, wie z.B. die Abfrage von Daten, die Manipulation von Daten über Sessions, die Definition von Relationen und vieles mehr.": "要了解更多关于`SQLiteDatabase`的工作原理，请阅读xref:database.adoc[Database]一章及其子章，如查询数据、通过会话操作数据、定义关系等等。",
        "Bitte beachten Sie, dass sich die Kapitel dort auf die eigenständige Bibliothek `@deepkit/orm` beziehen und keine Dokumentation über den Teil des Deepkit Frameworks enthalten, den Sie oben in diesem Kapitel gelesen haben. In der Standalone-Bibliothek instanziieren Sie Ihre Datenbankklasse manuell, z. B. über `new SQLiteDatabase()`. In Ihrer Deepkit-Framework-Anwendung wird dies jedoch automatisch mithilfe des Dependency Injection Containers durchgeführt.": "请注意，那里的章节指的是独立的库`@deepkit/orm`，不包括你在本章上面读到的Deepkit框架部分的文档。在单机库中，你可以手动实例化你的数据库类，例如通过`new SQLiteDatabase()`。然而，在你的Deepkit框架应用程序中，这是用依赖性注入容器自动完成的。",
        "Deepkit Logger ist eine eigenständige Bibliothek mit einer primären Klasse Logger, die Sie zur Protokollierung von Informationen verwenden können. Diese Klasse wird automatisch im Dependency Injection Container Ihrer Deepkit Framework-Anwendung bereitgestellt.": "Deepkit Logger是一个独立的库，有一个主要的Logger类，你可以用它来记录信息。这个类会自动部署在你的Deepkit Framework应用程序的依赖注入容器中。",
        "Die Klasse `Logger` verfügt über mehrere Methoden, die sich jeweils wie `console.log` verhalten.": "`Logger`类有几个方法，每个方法的行为都像`console.log`。",
        "Standardmäßig hat ein Logger den Level \"info\", d.h. er verarbeitet nur Info-Meldungen und mehr (d.h. log, warning, error, aber nicht debug). Um den Log-Level zu ändern, rufen Sie zum Beispiel `logger.level = 5` auf.": "默认情况下，一个日志记录器的级别为`info`，也就是说，它只处理信息消息和更多的信息（即日志、警告、错误，但不包括调试）。要改变日志级别，例如调用`logger.level = 5`。",
        "Benutzen in der Anwendung": "在应用中使用",
        "Um den Logger in Ihrer Deepkit-Framework-Anwendung zu verwenden, können Sie einfach `Logger` in Ihre Services oder Controller injizieren.": "要在你的Deepkit框架应用程序中使用记录器，你可以简单地将`Logger`注入你的服务或控制器中。",
        "Farben": "颜色",
        "Der Logger unterstützt farbige Protokollmeldungen. Sie können Farben bereitstellen, indem Sie XML-Tags verwenden, die den Text umgeben, der in Farbe erscheinen soll.": "记录器支持彩色的日志信息。你可以通过使用围绕着你希望以彩色显示的文本的XML标签来提供颜色。",
        "Bei Transportern, die keine Farben unterstützen, werden die Farbinformationen automatisch entfernt. Im Standardtransporter (`ConsoleTransport`) wird die Farbe angezeigt. Die folgenden Farben sind verfügbar: `black`, `red`, `green`, `blue`, `cyan`, `magenta`, `white` und `grey`/`gray`.": "对于不支持颜色的运输工具，颜色信息会被自动删除。在标准传输器（`ConsoleTransport`）中，显示的是颜色。有以下颜色可供选择。黑\"、\"红\"、\"绿\"、\"蓝\"、\"青\"、\"品红\"、\"白 \"和 \"灰色\"/\"灰\"。",
        "Transporter": "运输车",
        "Sie können einen einzelnen oder mehrere Transporter konfigurieren. In einer Deepkit Framework-Anwendung wird der Transporter `ConsoleTransport` automatisch konfiguriert. Um zusätzliche Transporter zu konfigurieren, können Sie xref:dependency-injection.adoc#di-setup-calls[Setup Calls] verwenden:": "你可以配置一个传输器或多个传输器。在Deepkit Framework应用程序中，\"ConsoleTransport \"传输器是自动配置的。要配置额外的传输器，你可以使用xref:dependency-injection.adoc#di-setup-calls[设置调用]。",
        "Um alle Transporter durch eine neue Gruppe von Transportern zu ersetzen, verwenden Sie `setTransport`:": "要用一组新的运输工具替换所有运输工具，请使用`setTransport`。",
        "Formatter": "形成器",
        "Mit Formatierern können Sie das Nachrichtenformat ändern, z. B. den Zeitstempel hinzufügen. Wenn eine Anwendung über `server:start` gestartet wird, wird automatisch ein `DefaultFormatter` hinzugefügt (der Zeitstempel, Bereich und Protokollstufe hinzufügt), wenn kein anderer Formatter vorhanden ist.": "通过格式化器，你可以改变信息的格式，例如，添加时间戳。当一个应用程序通过`server:start'启动时，如果没有其他格式，会自动添加`DefaultFormatter'（它添加了时间戳、范围和协议级别）。",
        "Scoped Logger": "范围广泛的记录器",
        "Scoped Logger fügen jedem Protokolleintrag einen beliebigen Bereichsnamen hinzu, der hilfreich sein kann, um festzustellen, aus welchem Teilbereich Ihrer Anwendung der Protokolleintrag stammt.": "范围内的日志记录器为每个日志条目添加一个任意的区域名称，这有助于确定日志条目来自于应用程序的哪个子区域。",
        "JSON Transporter": "JSON传输器",
        "Um die Ausgabe in JSON-Protokolle zu ändern, können Sie den mitgelieferten `JSONTransport` verwenden.": "要改变输出为JSON协议，你可以使用提供的`JSONTransport`。",
        "Context Data": "背景数据",
        "Um einem Protokolleintrag kontextbezogene Daten hinzuzufügen, fügen Sie ein einfaches Objektliteral als letztes Argument hinzu. Nur Protokollaufrufe mit mindestens zwei Argumenten können kontextbezogene Daten enthalten.": "要向协议条目添加上下文数据，请添加一个简单的对象字面作为最后一个参数。只有至少有两个参数的协议调用才能包含上下文数据。",
        "Deepkit Framework kommt mit diversen Event-Tokens, auf die Event-Listener registriert werden können.": "Deepkit框架带有各种事件标记，事件监听器可以被注册。",
        "Siehe das Kapitel xref:events.adoc[Events], um mehr darüber zu erfahren, wie Events funktionieren.": "参见xref:events.adoc[Events]一章，以了解更多关于事件如何工作。",
        "Dispatch Events": "调度事件",
        "Events werden über die Klasse `EventDispatcher` gesendet. In einer Deepkit Framework Applikation kann dieser über Dependency Injection bereitgestellt werden.": "事件是通过 \"EventDispatcher \"类发送的。在Deepkit框架的应用程序中，可以通过依赖性注入来提供这种服务。",
        "Event Listener": "事件监听器",
        "Es gibt zwei Arten auf Events zu reagieren. Entweder über Controller Klassen oder reguläre Funktionen.": "对事件的反应有两种方式。无论是通过控制器类还是常规函数。",
        "Beide werden in der App oder in Modulen unter `listeners` registriert.": "两者都在应用中或模块中的 \"听众 \"下注册。",
        "_Controller Listener_": "控制者监听器_",
        "_Functional Listener_": "_Functional Listener_",
        "Framework Events": "框架事件",
        "Deepkit Framework selbst hat mehrere Ereignisse aus dem Anwendungsserver, auf die Sie hören können.": "Deepkit Framework本身有几个来自应用服务器的事件，你可以监听。",
        "In diesem Kapitel erfahren Sie, wie Sie Ihre Anwendung in JavaScript kompilieren, für Ihre Produktionsumgebung konfigurieren und über Docker bereitstellen können.": "在本章中，你将学习如何用JavaScript编译你的应用程序，为你的生产环境配置它，并通过Docker部署它。",
        "TypeScript kompilieren": "编译TypeScript",
        "Nehmen wir an, Sie haben eine Anwendung wie diese in einer Datei `app.ts`:": "假设你在文件`app.ts`中拥有一个这样的应用程序。",
        "Wenn Sie `ts-node app.ts server:start` verwenden, sehen Sie, dass alles korrekt funktioniert. In einer Produktionsumgebung würden Sie den Server in der Regel nicht mit `ts-node` starten. Sie würden ihn in JavaScript kompilieren und dann den Node verwenden. Dazu müssen Sie eine korrekte `tsconfig.json` mit den richtigen Konfigurationsoptionen haben. In der Sektion \"Erste Applikation\" ist Ihre `tsconfig.json` so konfiguriert, dass sie JavaScript im Ordner `./dist` ausgibt. Wir gehen davon aus, dass Sie das auch so konfiguriert haben.": "如果你使用`ts-node app.ts server:start`，你会看到一切工作正常。在生产环境中，你通常不会用`ts-node`启动服务器。你会用JavaScript编译，然后使用节点。要做到这一点，你必须有一个正确的`tsconfig.json`和正确的配置选项。在 \"第一个应用程序 \"部分，你的`tsconfig.json`被配置为输出JavaScript到`./dist`文件夹。我们假设你也是这样配置的。",
        "Wenn alle Compiler-Einstellungen korrekt sind und Ihr `outDir` auf einen Ordner wie z.B. `dist` zeigt, dann werden, sobald Sie den Befehl `tsc` in Ihrem Projekt ausführen, alle Ihre verlinkten Dateien in den Dateien in der `tsconfig.json` zu JavaScript kompiliert. Es reicht, wenn Sie Ihre Einstiegsdateien in dieser Liste angeben. Alle importierten Dateien werden ebenfalls automatisch kompiliert und müssen nicht explizit in die `tsconfig.json` eingefügt werden. `tsc` ist Teil von Typescript, wenn Sie `npm install typescript` installieren.": "如果所有的编译器设置都是正确的，并且你的`outDir`指向`dist`这样的文件夹，那么只要你在项目中执行`tsc`命令，你在`tsconfig.json`中的所有链接文件都会被编译成JavaScript。在这个列表中指定你的条目文件即可。所有导入的文件也是自动编译的，不需要明确添加到`tsconfig.json`中。`tsc`是Typescript的一部分，当你安装`npm install typescript`时。",
        "Der TypeScript-Compiler gibt nichts aus, wenn er erfolgreich war. Sie können die Ausgabe von `dist` jetzt überprüfen.": "如果成功了，TypeScript编译器不会输出任何东西。现在你可以检查`dist'的输出。",
        "Sie sehen, dass es nur eine Datei gibt. Sie können sie über `node dist/app.js` ausführen und erhalten die gleiche Funktionalität wie mit `ts-node app.ts`.": "你看，只有一个文件。你可以通过`node dist/app.js`运行它，获得与`ts-node app.ts`相同的功能。",
        "Für ein Deployment ist es wichtig, dass die TypeScript-Dateien korrekt kompiliert werden und alles direkt über Node funktioniert. Sie könnten nun einfach Ihren `dist`-Ordner einschließlich Ihrer `node_modules` verschieben und `node dist/app.js server:start` ausführen und Ihre App ist erfolgreich deployed. Sie würden jedoch andere Lösungen wie Docker verwenden, um Ihre Anwendung korrekt zu verpacken.": "对于部署来说，重要的是TypeScript文件被正确编译，所有的东西都直接通过Node工作。现在你可以简单地移动你的`dist`文件夹，包括你的`node_modules`，然后运行`node dist/app.js server:start`，你的应用程序就成功部署了。然而，你会使用其他解决方案，如Docker来正确打包你的应用程序。",
        "In einer Produktionsumgebung würden Sie den Server nicht an `localhost` binden, sondern höchstwahrscheinlich an alle Geräte über `0.0.0.0`. Wenn Sie nicht hinter einem Reverse-Proxy stehen, würden Sie auch den Port auf 80 einstellen. Um diese beiden Einstellungen zu konfigurieren, müssen Sie das `FrameworkModule` anpassen. Die beiden Optionen, die uns interessieren, sind `host` und `port`. Damit sie von außen über Umgebungsvariablen oder über .dotenv-Dateien konfiguriert werden können, müssen wir dies zunächst zulassen. Glücklicherweise hat unser obiger Code dies bereits mit der Methode `loadConfigFromEnv()` getan.": "在生产环境中，你不会将服务器绑定到 \"localhost\"，而很可能是通过 \"0.0.0.0 \"绑定到所有设备。如果你不在一个反向代理后面，你也会把端口设置为80。为了配置这两个设置，你需要定制`FrameworkModule'。我们感兴趣的两个选项是`host`和`port`。为了使它们能够通过环境变量或通过.dotenv文件进行外部配置，我们必须首先允许这样做。幸运的是，我们上面的代码已经用`loadConfigFromEnv()`方法完成了这个工作。",
        "Bitte lesen Sie das Kapitel xref:framework.adoc#confiruration[Konfiguration], um mehr darüber zu erfahren, wie Sie die Konfigurationsoptionen der Anwendung einstellen können.": "请参考xref:framework.adoc#confiruration[配置]一章，了解更多关于如何设置应用程序的配置选项。",
        "Um zu sehen, welche Konfigurationsoptionen verfügbar sind und welchen Wert sie haben, können Sie den Befehl `ts-node app.ts app:config` verwenden. Sie können sie auch im Framework-Debugger sehen.": "要查看哪些配置选项是可用的，以及它们有什么价值，你可以使用`ts-node app.ts app:config`命令。你也可以在框架调试器中看到它们。",
        "SSL": "SSL",
        "Es wird empfohlen (und manchmal auch vorgeschrieben), Ihre Anwendung über HTTPS mit SSL laufen zu lassen. Es gibt mehrere Optionen zur Konfiguration von SSL. Um SSL zu aktivieren, verwenden Sie": "建议（有时需要）通过HTTPS和SSL运行你的应用程序。在配置SSL方面有几个选项。要启用SSL，请使用",
        "`framework.ssl` und konfigurieren Sie dessen Parameter mit den folgenden Optionen.": "`framework.ssl`，并通过以下选项配置其参数。",
        "Local SSL": "本地SSL",
        "In der lokalen Entwicklungsumgebung können Sie selbstsignierte HTTPs mit der Option `framework.selfSigned` aktivieren.": "在本地开发环境中，你可以用`framework.selfSigned`选项来启用自签名的HTTPs。",
        "Wenn Sie diesen Server jetzt starten, ist Ihr HTTP-Server als HTTPS unter `https://localhost:8080/` verfügbar. In Chrome erhalten Sie beim Öffnen dieser URL jetzt die Fehlermeldung \"NET::ERR_CERT_INVALID\", da selbstsignierte Zertifikate als Sicherheitsrisiko gelten: `chrome://flags/#allow-insecure-localhost`.": "如果你现在启动这个服务器，你的HTTP服务器就可以作为HTTPS在`https://localhost:8080/`。在Chrome浏览器中，你现在打开这个URL时会收到错误信息 \"NET::ERR_CERT_INVALID\"，因为自签名证书被认为是一种安全风险：`chrome://flags/#allow-insecure-localhost`。",
        "Die Services und Controller im Deepkit Framework sind so konzipiert, dass sie SOLID und sauberen Code unterstützen, der gut konzipiert, gekapselt und getrennt ist. Diese Eigenschaften machen den Code einfach zu testen.": "Deepkit框架中的服务和控制器被设计为支持SOLID和干净的代码，这些代码被精心设计、封装和分离。这些特点使代码易于测试。",
        "Diese Dokumentation zeigt Ihnen, wie Sie ein Test-Framework namens link:https://jestjs.io[Jest] mit `ts-jest` einrichten können. Führen Sie dazu den folgenden Befehl aus, um `jest` und `ts-jest` zu installieren.": "这篇文档告诉你如何用`ts-jest`建立一个名为link:https://jestjs.io[Jest]的测试框架。要做到这一点，运行以下命令来安装`jest`和`ts-jest`。",
        "Jest benötigt ein paar Konfigurationsoptionen, um zu wissen, wo die Testanzüge zu finden sind und wie der TS-Code zu kompilieren ist. Fügen Sie die folgende Konfiguration zu Ihrer `package.json` hinzu:": "Jest需要一些配置选项来知道在哪里找到测试套件，以及如何编译TS代码。在你的`package.json`中添加以下配置。",
        "Ihre Testdateien sollten den Namen `*.spec.ts` tragen. Erstellen Sie eine Datei `test.spec.ts` mit folgendem Inhalt.": "你的测试文件应该被命名为`*.spec.ts`。创建一个`test.spec.ts`文件，内容如下。",
        "Mit dem Befehl jest können Sie nun alle Ihre Testanzüge auf einmal ausführen.": "通过jest命令，你现在可以一次运行所有的测试服。",
        "Bitte lesen Sie die link:https://jestjs.io[Jest-Dokumentation], um mehr darüber zu erfahren, wie das Jest CLI-Tool funktioniert und wie Sie anspruchsvollere Tests und ganze Test-Suites schreiben können.": "请阅读链接：https://jestjs.io[Jest文档]，以了解更多关于Jest CLI工具的工作方式，以及如何编写更复杂的测试和整个测试套件。",
        "Unit Test": "单位测试",
        "Wann immer möglich sollten Sie Ihre Services mit einem Unit-Test teste. Je einfacher, besser getrennt und besser definiert Ihre Service-Abhängigkeiten sind, desto einfacher ist es, sie zu testen. In diesem Fall können Sie einfache Tests wie den folgenden schreiben:": "只要有可能，你应该用单元测试来测试你的服务。你的服务依赖关系越简单、分离得越好、定义得越清楚，测试起来就越容易。在这种情况下，你可以写一些简单的测试，如下面的测试。",
        "Integration tests": "集成测试",
        "Es ist nicht immer möglich, Unit-Tests zu schreiben, und es ist auch nicht immer der effizienteste Weg, um geschäftskritischen Code und Verhalten abzudecken. Besonders wenn Ihre Architektur sehr komplex ist, ist es von Vorteil, wenn Sie einfach End-to-End-Integrationstests durchführen können.": "编写单元测试并不总是可能的，也不总是覆盖关键业务代码和行为的最有效方式。特别是当你的架构非常复杂时，能够轻松运行端到端的集成测试是一个优势。",
        "Wie Sie bereits im Kapitel Dependency Injection gelernt haben, ist der Dependency Injection Container das Herzstück von Deepkit. Hier werden alle Dienste aufgebaut und betrieben. Ihre Anwendung definiert Dienste (Provider), Controller, Listener und Importe. Bei Integrationstests wollen Sie nicht unbedingt alle Dienste in einem Testfall zur Verfügung haben, aber Sie wollen in der Regel eine abgespeckte Version der Anwendung zur Verfügung haben, um die kritischen Bereiche zu testen.": "正如你在 \"依赖注入 \"一章中已经学到的，依赖注入容器是Deepkit的核心。这里是所有服务建立和运行的地方。你的应用程序定义了服务（提供者）、控制器、监听器和导入。在集成测试中，你不一定想在一个测试案例中拥有所有的服务，但你通常想拥有一个精简的应用程序版本来测试关键领域。",
        "Wenn Sie Ihre Anwendung in mehrere Module aufgeteilt haben, können Sie diese leichter testen. Nehmen wir zum Beispiel an, Sie haben ein `AppCoreModul` erstellt und möchten einige Services testen.": "如果你把你的应用程序分为几个模块，你可以更容易地测试它们。例如，假设你已经创建了一个 \"AppCoreModule\"，你想测试一些服务。",
        "Sie verwenden Ihr Modul wie folgt:": "你按以下方式使用你的模块。",
        "Und testen Sie es, ohne den gesamten Anwendungsserver zu booten.": "并在不启动整个应用服务器的情况下进行测试。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit中的CLI程序是基于运行时类型的，因此有必要正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Siehe xref:framework.adoc#framework-modules[Framework Modules], um mehr über App Module zu erfahren.": "参见xref:framework.adoc#framework-modules[框架模块]以了解更多关于应用模块的信息。",
        "Siehe xref:dependency-injection.adoc[Dependency Injection] für mehr Informationen.": "更多信息见xref:dependency-injection.adoc[依赖注入]。",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen xref:serialization.adoc[Serialization] und xref:validation.adoc[Validation] Features.": "所有的参数都被自动转换（反序列化）为定义的TypeScript类型并被验证。这是通过`@deepkit/type`包及其xref:serialization.adoc[序列化]和xref:validation.adoc[验证]功能实现的。",
        "Die Umwandlung geschieht automatisch mit dem Feature xref:serialization.adoc#serialisation-loosely-convertion[Weiche Typenkonvertierung].": "这种转换是通过xref:serialization.adoc#serialisation-loosely-conversion[软类型转换]这一特性自动完成的。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in": "可以应用`@deepkit/type`中的所有验证类型。更多相关信息请见",
        "xref:http.adoc#http-validation[HTTP Validation] zu finden.": "xref:http.adoc#http-validation[HTTP Validation]。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in xref:http.adoc#http-validation[HTTP Validation] zu finden.": "可以应用`@deepkit/type`中的所有验证类型。关于这一点，请参阅xref:http.adoc#http-validation[HTTP Validation]。",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel xref:serialization.adoc[Serialization] und xref:validation.adoc[Validation].": "指定模型中的属性可以包含所有TypeScript类型和`@deepkit/type`支持的验证类型。参见xref:serialization.adoc[序列化]和xref:validation.adoc[验证]章节。",
        "Siehe xref:validation.adoc[Validation] für mehr Informationen dazu.": "请参阅xref:validation.adoc[Validation]获取更多相关信息。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu xref:template.adoc[Template].": "带有TSX的模板引擎变体的优点是，使用的变量会自动进行HTML转义。见xref:template.adoc[Template]。",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion xref:http.adoc#http-events[HTTP Events].": "默认情况下，所有错误都以JSON格式返回给客户端。这个行为可以根据需要在事件系统中的`httpWorkflow.onControllerError'事件下进行调整。见xref:http.adoc#http-events[HTTP Events]一节。",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (sieh xref:http.adoc#http-events[HTTP Events]) nicht zu `controllerError` sondern zu `accessDenied`.": "错误 \"HttpAccessDeniedError \"是一个特殊情况。一旦它被抛出，HTTP工作流（见xref:http.adoc#http-events[HTTP Events]）就不会跳到`controllerError`，而是跳到`accessDenied`。",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion xref:http.adoc#http-route-name[HTTP Route Name] einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "方法`Redirect.toRoute`使用路由的名称。如何设置路由名称可以在xref:http.adoc#http-route-name[HTTP路由名称]部分看到。如果这个被引用的路由（查询或路径）包含参数，这些参数可以通过第二个参数指定。",
        "Siehe xref:dependency-injection.adoc#di-scopes[Dependency Injection Scopes], um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见xref:dependency-injection.adoc#di-scopes[依赖注入作用域]，了解如何将提供者放在`http`作用域中。",
        "HTTP middlewares allow you to hook into the request/response cycle as an alternative to HTTP events. Its API allows you to use all middlewares from the Express/Connect framework.": "HTTP中间件允许你作为HTTP事件的替代品，钩住请求/响应周期。它的API允许你使用Express/Connect框架的所有中间件。",
        "A middleware can either be a class (which is instantiated by the dependency injection container) or a simple function.": "一个中间件可以是一个类（由依赖注入容器实例化），也可以是一个简单的函数。",
        "Global": "全球",
        "By using httpMiddleware.for(MyMiddleware) a middleware is registered for all routes, globally.": "通过使用httpMiddleware.for(MyMiddleware)，在全球范围内为所有路由注册一个中间件。",
        "Per Controller": "每个控制器",
        "You can limit middlewares to one or multiple controllers in two ways. Either by using the `@http.controller` or `httpMiddleware.for(T).forControllers()`. `excludeControllers` allow you to exclude controllers.": "你可以通过两种方式将中间件限制在一个或多个控制器上。可以通过使用`@http.controller`或`httpMiddleware.for(T).forControllers()`。`excludeControllers`允许你排除控制器。",
        "Per Route Name": "每个路线名称",
        "`forRouteNames` along with its counterpart `excludeRouteNames` allow you to filter the execution of a middleware per route names.": "`forRouteNames`和其对应的`excludeRouteNames`允许你根据路由名称过滤中间件的执行。",
        "Per Action/Route": "每个行动/路线",
        "To execute a middleware only for a certain route, you can either use `@http.GET().middleware()` or": "要想只为某个路由执行一个中间件，你可以使用`@http.GET().middleware()`或",
        "`httpMiddleware.for(T).forRoute()` where forRoute has multiple options to filter routes.": "`httpMiddleware.for(T).forRoute()`其中forRoute有多个选项来过滤路由。",
        "`forRoutes()` allows as first argument several way to filter for routes.": "`forRoutes()`允许作为第一个参数的几种方式来过滤路线。",
        "Path Pattern": "路径模式",
        "`path` supports wildcard *.": "`path`支持通配符*。",
        "HTTP Method": "HTTP方法",
        "Filter all routes by a HTTP method.": "通过一个HTTP方法过滤所有路由。",
        "Category": "类别",
        "`category` along with its counterpart `excludeCategory` allow you to filter per route category.": "`类别'和其对应的`排除类别'允许你按路线类别进行过滤。",
        "`group` along with its counterpart `excludeGroup` allow you to filter per route group.": "`group`和其对应的`excludeGroup`允许你按路由组过滤。",
        "Per Modules": "每个模块",
        "You can limit the execution of a module for a whole module.": "你可以限制一个模块的执行，对整个模块进行限制。",
        "Per Self Modules": "每个自我模块",
        "To execute a middleware for all controllers/routes of a module where the middleware was registered use `forSelfModules()`.": "使用`forSelfModules()`来为注册了中间件的模块的所有控制器/路由执行一个中间件。",
        "Timeout": "超时",
        "All middleware needs to execute `next()` sooner or later. If a middleware does not execute `next()` withing a timeout, a warning is logged and the next middleware executed. To change the default of 4seconds to something else use timeout(milliseconds).": "所有的中间件迟早都需要执行`next()'。如果一个中间件在超时内没有执行`next()`，就会记录一个警告并执行下一个中间件。要把默认的4秒改为其他的，请使用timeout(milliseconds)。",
        "Multiple Rules": "多种规则",
        "To combine multiple filters, you can chain method calls.": "为了组合多个过滤器，你可以连锁调用方法。",
        "Express Middleware": "快捷中间件",
        "Almost all express middlewares are supported. Those who access certain request methods of express are not yet supported.": "几乎所有的快递中间件都被支持。那些访问快递的某些请求方法还不被支持。",
        "Willkommen bei der Deepkit-Dokumentation.": "欢迎来到Deepkit的文档。",
        "In dieser Dokumentation finden Sie weitere Informationen über die Verwendung der einzelnen Bibliotheken und des Deepkit-Frameworks in allen Einzelheiten mit Beispielcode.": "在这个文档中，你会发现更多关于使用各个库和Deepkit框架的信息，并附有示例代码的全部细节。",
        "Work in Progress": "正在进行的工作",
        "Diese Dokumentation ist noch in Arbeit.": "该文件仍在进行中。",
        "Obwohl es bereits einige Platzhalter gibt, sind viele, besonders im Bereich der Datenbanken, noch nicht geschrieben worden.": "虽然有些占位符已经存在，但许多占位符，特别是在数据库领域，还没有被写出来。",
        "Wir sind ständig dabei, die Dokumentation zu verbessern.": "我们正在不断改进文件。",
        "Wenn Sie dringend etwas brauchen, gehen Sie bitte in unseren Discord-Server.": "如果你有紧急需要，请到我们的Discord服务器。",
        "API": "API",
        "Verwenden Sie die API-Dokumentation, um sehr detaillierte Informationen über die API der einzelnen Module zu erhalten.": "使用API文档可以获得关于每个模块的API的非常详细的信息。",
        "link:https://deepkit.io/assets/api-docs/modules.html[API Documentation, role=big]": "link:https://deepkit.io/assets/api-docs/modules.html[API文档, role=big]",
        "Support": "支持",
        "Wenn Sie Hilfe benötigen, treten Sie bitte dem Discord-Community-Server bei:": "如果你需要帮助，请加入Discord社区服务器。",
        "link:https://deepkit.io/community[Community, role=big]": "link:https://deepkit.io/community[community, role=big]",
        "Deepkit Framework": "Deepkit框架",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe xref:runtime-types.adoc[Runtime Types]), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus xref:validation.adoc[Validation] definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "在 Deepkit RPC 中，函数的类型是从 TypeScript 代码本身中提取的（见 xref:runtime-types.adoc[Runtime Types]），因此不需要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。只要从xref:validation.adoc[Validation]中定义了额外的约束，这些约束也会被自动验证。这使得通过RPC进行的通信极为类型安全和有效。Deepkit RPC中通过`rxjs`对流媒体的支持，也使这个RPC框架成为实时通信的合适工具。",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "由于Deepkit RPC是基于运行时类型的，因此必须正确安装`@deepkit/type`。参见xref:runtime-types.adoc#runtime-types-installation[运行时类型安装]。",
        "Siehe xref:dependency-injection.adoc[Dependency Injection], um mehr zu erfahren.": "参见xref:dependency-injection.adoc[依赖注入]以了解更多。",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu xref:rpc.adoc#rpc-nominal-types[RPC Nominal Types].": "RPC函数可以抛出错误。默认情况下，这些错误被转发到客户端并在那里再次抛出。如果使用了自定义错误类，其名义类型应被启用。参见xref:rpc.adoc#rpc-nominal-types[RPC名义类型]。",
        "Siehe hierzu auch xref:dependency-injection.adoc[Dependency Injection].": "另见xref:dependency-injection.adoc[依赖性注入]。",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "每个属性都可以添加额外的元数据，可以通过Reflection API读取。参见xref:runtime-types.adoc#runtime-types-reflection[运行时类型反思]以获得更多信息。",
        "Siehe xref:validation.adoc#validation-constraint-types[Validation Constraint Types].": "见xref:validation.adoc#validation-constraint-types[验证约束类型]。",
        "Siehe xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection], um mehr darüber zu erfahren.": "参见xref:runtime-types.adoc#runtime-types-reflection[运行时类型反思]以了解更多。",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion xref:serialization.adoc#serialisation-custom-serialiser[Custom Serializer] erfahren werden.": "Deepkit Type支持自定义序列化目标，但已经配备了强大的JSON序列化目标，该目标将数据序列化为JSON对象，然后可以使用JSON.stringify正确而安全地转换为JSON。通过`@deepkit/bson`，BSON也可以作为一个序列化目标。如何创建一个自定义的序列化目标（例如为数据库驱动），可以在xref:serialization.adoc#serialisation-custom-serialiser[自定义序列化器]一节中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in xref:validation.adoc[Validation]. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel xref:validation.adoc[Validation] auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "请注意，尽管蚕食者也检查数据的兼容性，但这些验证与xref:validation.adoc[验证]中的验证是不同的。只有`cast`函数在成功反序列化后还会调用xref:validation.adoc[Validation]章节中的完整验证过程，如果数据无效会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe xref:validation.adoc[Validation].": "另外，`validatedDeserialize`可以用来在反序列化后进行验证。另一种方法是手动调用`validate`或`validates`函数来处理来自`deserialize`函数的反序列化数据，见xref:validation.adoc[Validation]。",
        "Standardmäßig wird `@deepkit/type` mit einem JSON-Serialisierer und einer Typ-Validierung für TypeScript-Typen geliefert. Sie können diesen erweitern und die Serialisierungsfunktionalität erweitern oder entfernen oder die Art und Weise der Validierung ändern, da die Validierung auch mit dem Serializer verbunden ist.": "默认情况下，`@deepkit/type`带有一个JSON序列化器和TypeScript类型的类型验证。你可以对此进行扩展，添加或删除序列化功能，或改变验证的方式，因为验证也与序列化器相关。",
        "New Serialisierer": "新连载机",
        "Ein Serializer ist einfach eine Instanz der Klasse `Serializer` mit registrierten Serializer-Vorlagen. Serializer-Vorlagen sind kleine Funktionen, die JavaScript-Code für den JIT-Serializer-Prozess erstellen. Für jeden Typ (String, Number, Boolean usw.) gibt es eine eigene Serializer-Vorlage, die für die Rückgabe von Code für die Datenkonvertierung oder -validierung zuständig ist. Dieser Code muss mit der JavaScript-Engine kompatibel sein, die der Benutzer verwendet.": "一个序列化器只是一个带有注册序列化器模板的`Serializer`类的实例。串行器模板是为JIT串行器过程创建JavaScript代码的小函数。对于每一种类型（字符串、数字、布尔值等），都有一个单独的串行器模板，负责返回数据转换或验证的代码。这段代码必须与用户使用的JavaScript引擎兼容。",
        "Nur während der Ausführung der Compiler-Vorlagenfunktion haben Sie (oder sollten Sie) vollen Zugriff auf den vollständigen Typ. Die Idee ist, dass Sie alle Informationen, die für die Konvertierung eines Typs erforderlich sind, direkt in den JavaScript-Code einbetten sollten, was zu hochgradig optimiertem Code (auch JIT-optimierter Code genannt) führt.": "只有在编译器模板函数的执行过程中，你（或你应该）才能完全接触到完整的类型。这个想法是，你应该把转换类型所需的所有信息直接嵌入到JavaScript代码中，从而产生高度优化的代码（也称为JIT优化的代码）。",
        "Im folgenden Beispiel wird ein leerer Serializer erstellt.": "在下面的例子中，一个空的序列化器被创建。",
        "Wie Sie sehen können, wurde nichts umgewandelt (`created` ist immer noch eine Zahl, aber wir haben sie als `Date` definiert). Um das zu ändern, fügen wir eine Serializer-Vorlage für die Deserialisierung des Typs Datum hinzu.": "正如你所看到的，没有任何东西被转换（\"创建 \"仍然是一个数字，但我们已经将其定义为 \"日期\"）。为了改变这种情况，我们为日期类型的反序列化添加一个序列化器模板。",
        "Jetzt wandelt unser Serialisierer den Wert in ein Date-Objekt um.": "现在我们的序列化器将该值转换为一个Date对象。",
        "Um dasselbe für die Serialisierung zu tun, registrieren wir eine weitere Serialisierungsvorlage.": "为了对序列化做同样的处理，我们注册另一个序列化模板。",
        "Unser neuer Serialisierer konvertiert das Datum im Serialisierungsprozess nun korrekt vom Date-Objekt in einen String.": "我们的新序列化器现在可以在序列化过程中正确地将日期从Date对象转换为字符串。",
        "Beispiele": "实例",
        "Um viele weitere Beispiele zu sehen, können Sie einen Blick in den Code des link:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON-Serializers] werfen, der in Deepkit Type enthalten ist.": "要看更多的例子，你可以看看Deepkit Type中包含的链接:https://github.com/deepkit/deepkit-framework/blob/master/packages/type/src/serializer.ts#L1688[JSON序列化器]的代码。",
        "Erweitern eines Serialisierers": "扩展一个串行器",
        "Wenn Sie einen bereits vorhandenen Serialisierer erweitern möchten, können Sie dies über die Klassenvererbung tun. Dies funktioniert, weil Serialisierer so geschrieben werden sollten, dass sie ihre Vorlagen im Konstruktor registrieren.": "如果你想扩展一个现有的序列化器，你可以使用类的继承来实现。这样做的原因是，应该编写蚕食者在构造函数中注册其模板。",
        "Die Template-Engine ermöglicht es, typsichere, schnelle und sichere HTML-Templates zu schreiben. Sie basiert auf TSX und ist sofort einsatzbereit, sobald Sie die Dateierweiterung `.tsx` verwenden und die `tsconfig.json` entsprechend anpassen.": "模板引擎使编写类型安全、快速和安全的HTML模板成为可能。它基于TSX，只要你使用文件扩展名`.tsx`并相应调整`tsconfig.json`，就可以使用。",
        "Wichtig dabei ist: Es ist nicht kompatibel zu React. Sobald React eingesetzt werden soll, ist `@deepkit/template` inkompatibel. Deepkit's Template engine ist nur für SSR (Server-Side-Rendering) gedacht.": "重要的是，它与React不兼容。一旦要使用React，`@deepkit/template`就不兼容了。Deepkit的模板引擎只用于SSR（服务器端渲染）。",
        "In your tsconfig you have to adjust following settings: `jsx` and `jsxImportSource`": "在你的tsconfig中，你必须调整以下设置：`jsx`和`jsxImportSource`。",
        "Jetzt können Sie TSX direkt in Ihrem Controller verwenden.": "现在你可以在你的控制器中直接使用TSX。",
        "Wenn Sie eine solches TSX in Ihrer Routenmethode zurückgeben, wird der HTTP-Inhaltstyp automatisch auf `text/html; charset=utf-8` gesetzt.": "如果你在路由方法中返回这样的TSX，HTTP内容类型会自动设置为`text/html; charset=utf-8`。",
        "Sie können Ihre Templates so strukturieren, wie Sie es von React gewohnt sind. Entweder modularisieren Sie Ihr Layout in mehrere Funktions- oder Klassenkomponenten.": "你可以按照你在React中习惯的方式构造你的模板。要么将你的布局模块化为几个功能或类组件。",
        "Am einfachsten ist es, eine Funktion zu verwenden, die TSX zurückgibt.": "最简单的方法是使用一个返回TSX的函数。",
        "Funktionskomponenten können (anders als in React) asynchron sein. Dies ist ein wichtiger Unterschied zu anderen Template-Engines, die Sie vielleicht kennen, wie React.": "函数组件可以是异步的（与React不同）。这与你可能知道的其他模板引擎，如React，是一个重要的区别。",
        "Alle Funktionen haben Zugriff auf den Dependency Injection Container und können ab dem dritten Parameter beliebige Dependencies referenzieren.": "所有的函数都可以访问依赖注入容器，并且可以引用从第三个参数开始的任何依赖关系。",
        "Eine alternative Art, eine Komponente zu schreiben, ist eine Klassenkomponente. Sie werden im Dependency Injection Container behandelt und instanziiert und haben somit Zugriff auf alle im Container registrierten Dienste. Dadurch ist es möglich, in Ihren Komponenten beispielsweise direkt auf eine Datenquelle wie eine Datenbank zuzugreifen.": "另一种编写组件的方式是类组件。它们在依赖注入容器中被处理和实例化，因此可以访问在容器中注册的所有服务。这使得在你的组件中直接访问数据源（如数据库）成为可能，例如。",
        "Für Klassenkomponenten sind die ersten Konstruktorargumente reserviert. `props` kann beliebig definiert werden, `children` ist immer \"any\", und dann folgen optionale Abhängigkeiten, die Sie beliebig wählen können. Da Klassenkomponenten im Dependency Injection Container instanziiert werden, haben Sie Zugriff auf alle Ihre Services.": "第一个构造函数参数是为类组件保留的。`props`可以任意定义，`children`总是 \"any\"，然后是可选的依赖关系，你可以任意选择。由于类组件在依赖注入容器中被实例化，你可以访问你的所有服务。",
        "Die Template-Engine hat alle verwendeten Variablen automatisch bereinigt, sodass Sie Benutzereingaben sicher direkt in der Vorlage verwenden können. Um dynamisches HTML zu rendern, können Sie die Funktion html verwenden.": "模板引擎已经自动清理了所有使用的变量，所以你可以安全地在模板中直接使用用户输入。要渲染动态HTML，你可以使用html函数。",
        "Die Template-Engine versucht, den generierten JSX-Code so zu optimieren, dass es für NodeJS/V8 viel einfacher ist, den HTML-String zu generieren. Damit dies korrekt funktioniert, sollten Sie alle Ihre Komponenten aus der Hauptdatei app.tsx in separate Dateien verschieben. Eine Struktur könnte so aussehen:": "模板引擎试图优化生成的JSX代码，这样NodeJS/V8就更容易生成HTML字符串了。为了正确地工作，你应该把你的所有组件从主app.tsx文件移到单独的文件中。一个结构可以是这样的。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in xref:serialization.adoc[Serialization] mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个在运行时不提供任何安全保障的 \"作为数字 \"的类型铸造。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。关于这方面的更多信息，请参阅xref:serialization.adoc[Serialization]。",
        "In den dazugehörigen Kapiteln (xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "在相应的章节（xref:cli.adoc[CLI], xref:http.adoc[HTTP], xref:rpc.adoc[RPC], xref:database.adoc[Database]）中，详细解释了何时自动发生验证。确保你知道哪里需要定义限制或类型，不要使用`any`来使这些验证自动良好安全地工作。这可以为你节省大量的手工工作以保持代码的清洁和安全。",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` vorgenommen werden.": "在Deepkit中，可以使用`validate`、`is`或`assert`函数进行类型验证。",
        "Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "函数`is`是一个所谓的类型保护，`assert`是一个类型断言。两者都将在下一节进行解释。",
        "Each property can add additional meta-data that can be read via the Reflection API. See xref:runtime-types.adoc#runtime-types-reflection[Runtime Types Reflection] for more information.": "每个属性都可以添加额外的元数据，可以通过Reflection API读取。更多信息请参见xref:runtime-types.adoc#runtime-types-reflection[运行时类型反思]。"
    },
    "polish": {
        "Einführung": "Wprowadzenie",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript to JavaScript, który się skaluje. Język przeznaczony do implementacji złożonych przypadków użycia. Umożliwia ona pisanie języka JavaScript z typami, które są sprawdzane i usuwane w czasie kompilacji. Ten typ bezpieczeństwa pozwala na łatwiejsze pisanie i obsługę złożonych aplikacji. Między innymi to właśnie sprawiło, że język TypeScript stał się tak popularny: Umożliwia on znajdowanie błędów w kodzie, zwłaszcza na dużą skalę, znacznie szybciej i łatwiej niż byłoby to możliwe w przypadku czystego JavaScriptu - i działa raczej z JavaScriptem niż przeciwko niemu.",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "Deepkit to TypeScript, który się skaluje. Szkielet napisany w języku TypeScript dla języka TypeScript, przeznaczony do tworzenia bardzo złożonego oprogramowania w języku TypeScript. Przenosi on do TypeScriptu wiele wzorców projektowych znanych z języka Enterprise i wprowadza zupełnie nowe funkcje, które są możliwe tylko dzięki nowemu systemowi typów TypeScriptu, aby zwiększyć szybkość tworzenia oprogramowania, zwłaszcza w zespołach. Z tego nowego podejścia mogą skorzystać również małe aplikacje, ponieważ Deepkit zawiera wiele bibliotek dla bardzo typowych przypadków użycia, które można stosować pojedynczo lub w połączeniu. Sam szkielet został zaprojektowany tak, aby był tak zwinny, jak to tylko możliwe, i tak złożony, jak to konieczne, nie tylko po to, aby szybko uzyskać pierwsze wyniki, ale także aby utrzymać szybkość rozwoju w dłuższej perspektywie.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript jest obecnie największą społecznością programistów na świecie i zapewnia programistom odpowiednio duży wybór wielu bibliotek i narzędzi, które mogą zaspokoić potrzeby projektu. Nie zawsze jednak łatwo jest znaleźć odpowiednią bibliotekę. Często filozofie, API i właściwości kodu tych bibliotek różnią się tak bardzo, że programista musi wprowadzić wiele lepkiego kodu i dodatkowych abstrakcji, aby biblioteki te mogły ze sobą poprawnie współpracować. W ostatnich dziesięcioleciach wielokrotnie sprawdzało się dostarczanie podstawowych funkcji, których potrzebuje niemal każdy projekt, w postaci pięknie wyabstrahowanych bibliotek zebranych w ramy przez producenta lub społeczność: Java Spring, PHP Symfony/Laravel i C++ QT to tylko kilka znanych i udanych przykładów.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "Szkielety te często oferują programiście rozpowszechnione i znane od dziesięcioleci koncepcje, które są zaimplementowane w bibliotekach lub komponentach, dzięki czemu można je wygodnie zharmonizować ze sobą i stosować w razie potrzeby. Oferowane funkcje i wzorce projektowe nie są przypadkowe, lecz opierają się na koncepcjach, które niekiedy mają kilkadziesiąt lat i sprawdziły się w konkurencji z alternatywnymi pomysłami.",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript poczynił na przestrzeni lat ogromne postępy, dzięki czemu można obecnie stosować coraz więcej wzorców projektowych ze środowiska korporacyjnego. Wzorce projektowe, które można znaleźć w coraz większej liczbie bibliotek, frameworków i narzędzi. Jednak JavaScript, a także TypeScript mają ten problem, że aby efektywnie stosować wiele sprawdzonych wzorców korporacyjnych, w samym języku brakuje decydujących funkcji. Nie oznacza to, że tych wzorców projektowych nie można stosować ogólnie, ale że są one mniej wydajne niż w innych obecnych językach.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript całkowicie usuwa informacje o swoim typie w czasie kompilacji, gdy TypeScript jest konwertowany na JavaScript, więc w wygenerowanym JavaScripcie ani w czasie wykonywania nie ma o nim żadnych informacji. Nie ulega wątpliwości, że typy są bardzo cenne podczas tworzenia programu i sprawdzania jego poprawności. Jednak typy mają również ogromną wartość w czasie pracy. Wartość ta jest odzwierciedlona, gdy dane są konwertowane/serializowane w czasie wykonywania, dane są walidowane, do obiektów dodawane są metainformacje lub wymagane są informacje o interfejsie. W tych i wielu innych przypadkach użycia informacje o typie mogą być bardzo przydatne w czasie pracy, ponieważ dostarczają bibliotekom informacji niezbędnych do wydajnego działania. Obecnie wiele z tych przypadków użycia korzysta z alternatywnych rozwiązań, które nie do końca naśladują system typów TypeScript i zmuszają programistę do pisania typów w nowy sposób, który nie ma nic wspólnego ze składnią TypeScript. W rezultacie potężny system typów TypeScript nie może już pokazać swojej siły w tym miejscu, a zamiast tego trzeba stosować mniej ergonomiczne i mniej wydajne sposoby pracy.",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Firma Deepkit opracowała kompilator typów, który pozostawia informacje o typach w miejscu, umożliwiając obliczanie typów dynamicznych w czasie wykonywania zadania oraz odczytywanie istniejących informacji o typach w czasie wykonywania zadania. Dzięki tej zmianie paradygmatu możliwe są zupełnie nowe sposoby pracy, które zapewniają informacje wymagane w wyżej wymienionych przypadkach użycia, radykalnie upraszczają tworzenie złożonego oprogramowania i nadają kodowi większą wyrazistość. W ten sposób po raz pierwszy można wykorzystać pełną moc i ekspresyjność języka TypeScript w trybie runtime.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "W oparciu o tę zmianę paradygmatu firma Deepkit opracowała cały szereg bibliotek dla przypadków użycia, które można znaleźć w niemal każdym programie: Walidacja, Serializacja, Abstrakcja bazy danych, Parser CLI, Router HTTP, Framework RPC, Logger, System szablonów, System zdarzeń i wiele innych. Zasadnicza różnica w stosunku do innych bibliotek polega na tym, że informacje o typie są podstawą funkcjonalności i jak najwięcej TypeScriptu powinno być ponownie wykorzystywane w czasie działania, tak aby programista musiał pisać mniej szablonów, a nawet złożone programy mogły na pierwszy rzut oka zorientować się, co robią. Wreszcie, jedną z kluczowych cech języka TypeScript jest nadawanie ekspresji nawet złożonemu kodowi, a Deepkit przenosi te zalety ekspresyjności do trybu runtime w postaci potężnego szkieletu, który pozwala teraz lepiej skalować architekturę aplikacji za pomocą odpowiednich wzorców korporacyjnych.",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit składa się z dwóch dużych obszarów: Po pierwsze, biblioteki Deepkit oraz Deepkit Framework. Biblioteki Deepkit to cała rodzina samodzielnych bibliotek TypeScript (pakiety NPM), które są dobre w jednym temacie i są zoptymalizowane, dobrze przetestowane i zaprojektowane tak, aby optymalnie się uzupełniały. W projekcie można korzystać z poszczególnych bibliotek Deepkit lub z całego frameworka Deepkit, który łączy w sobie wszystkie możliwości bibliotek i uzupełnia je o dodatkowe narzędzia, takie jak debugger. Wszystko to razem pozwala programiście tworzyć złożone, szybkie i gotowe do produkcji aplikacje.",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit obsługuje cały szereg przypadków użycia. Od prostych narzędzi wiersza poleceń (programów CLI), przez aplikacje internetowe i mikrousługi, po aplikacje desktopowe i mobilne. Kod został zaprojektowany tak, aby działał w każdym znanym silniku JavaScript (zarówno w przeglądarce, jak i NodeJS) i może być wspaniale zintegrowany z innymi frameworkami, takimi jak Angular, React i Vue.",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "Założeniem Deepkit Framework jest stosowanie czystego kodu, zasad SOLID oraz wzorców projektowych dla przedsiębiorstw, aby nie tylko zapewnić odpowiednio wysoką jakość kodu, ale także umożliwić użytkownikowi stosowanie tych zasad. Deepkit również stara się promować te same zasady w swojej dokumentacji i przykładach, ale nie zmusza programisty do ich przestrzegania.",
        "High-Performance": "Wysokowydajna strona",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "Jednym z najtrudniejszych problemów w tworzeniu oprogramowania jest utrzymanie wysokiego tempa rozwoju nawet po miesiącach lub latach, zwłaszcza gdy kod i zespół się rozrastają. Istnieje wiele frameworków, które obiecują szybki start i dzięki którym można w krótkim czasie złożyć bardziej złożone aplikacje. Jednak ich wspólnym problemem jest to, że tempo rozwoju drastycznie spada, im starszy jest projekt lub im większy jest zespół. Nierzadko zdarza się, że już po kilku miesiącach i przy udziale zaledwie kilku programistów tempo rozwoju spada do poziomu 1% pierwotnego tempa.",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "Aby przeciwdziałać temu zjawisku, konieczne jest stosowanie ustalonych wzorców projektowych oraz wcześniejsze użycie odpowiednich frameworków i bibliotek. Wzorce projektowe dla przedsiębiorstw zyskały popularność, ponieważ doskonale skalują się nawet w przypadku większych aplikacji i dużych zespołów. Prawidłowo stosowane ujawniają swoje możliwości zwłaszcza wtedy, gdy projekt ma być realizowany w dłuższym okresie czasu (od kilku miesięcy do lat).",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "Wzorce projektowe mają swoje zalety w teorii, ale w praktyce prawie każdy wzorzec ma też wady. Wady te różnią się w zależności od języka i szkieletu, ponieważ język i szkielet same w sobie decydują o tym, jak ergonomicznie można zastosować dany wzorzec. To, że dany wzorzec może być użyty w danym języku, nie oznacza, że automatycznie czyni on rozwój lepszym i szybszym.",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "Niektóre języki są lepiej przystosowane do stosowania pewnych wzorców niż inne. W JavaScript, a nawet w samym TypeScript, można często stosować różne wzorce projektowe, ale istnieją ograniczenia, które znacznie pogarszają wrażenia użytkownika, a tym samym szybkość działania. Na przykład dekoratory Typescript ze wszystkimi ich osobliwościami mogą stać się niezbędne, jeśli framework wstrzykiwania zależności to określa i jest na nim oparty.",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "System typów runtime Deepkit zapewnia, że te wzorce projektowe mogą być stosowane w najbardziej ergonomiczny sposób i przy użyciu jak najmniejszej ilości szablonów, co uwalnia ich potencjał do utrzymania wysokiego tempa rozwoju nie tylko na początku, ale także w dłuższej perspektywie.",
        "Isomorphic TypeScript": "Izomorficzny język TypeScript",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "Jedną z największych zalet języka TypeScript jest to, że złożony kod można pisać lepiej w wielu przypadkach użycia. Obejmuje to frontend, backend, narzędzia CLI, aplikacje mobilne i desktopowe oraz wiele innych. Jeśli projekt obejmuje te przypadki użycia i opiera się prawie wyłącznie na języku TypeScript, nazywa się go izomorficznym TypeScript. Stosowanie języka TypeScript w jak największej ilości kodu może znacznie przyspieszyć proces tworzenia. Wówczas nagle pojawiają się następujące korzyści:",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "Kod może być współdzielony między działami (frontend, backend, mikroserwisy itp.).",
        "Models, Typen und Interfaces": "Modele, typy i interfejsy",
        "Validation": "Walidacja",
        "Business logic": "Logika biznesowa",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "Ujednolicony system audytu pojedynczego menedżera pakietów.",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "Ponowne wykorzystanie znanych bibliotek innych firm we wszystkich działach.",
        "Wissensteilung innerhalb der Teams.": "Dzielenie się wiedzą w ramach zespołów.",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "Rekrutacja jest uproszczona do jednej grupy (i to największej: programistów JavaScript).",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit Framework i jego system typów runtime zostały zaprojektowane tak, aby maksymalnie wykorzystać te i inne zalety izomorficznego TypeScriptu, pozwalając mu zabłysnąć swoimi maksymalnymi możliwościami.",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "Stare podejścia, takie jak dual stack (frontend i backend w różnych językach), nie są już w stanie dotrzymać kroku, ponieważ samo przełączanie kontekstu między językami kosztuje już ogromną ilość energii i czasu. Wszystkie inne zalety, które zostały już wyjaśnione, sprawiają, że porównanie to jest niesprawiedliwe. Izomorficzny stos technologiczny, taki jak TypeScript, jest na podstawowym poziomie wielokrotnie szybszy w czasie tworzenia oprogramowania niż jakakolwiek kombinacja podwójnego stosu backend/frontend, takiego jak Java/JavaScript, PHP/JavaScript czy nawet JavaScript/JavaScript. Ponieważ większa szybkość opracowywania oznacza również mniej czasu potrzebnego na wykonanie tych samych funkcji, oznacza to również, że Isomorphic TypeScript pozwala zaoszczędzić pieniądze. Oprócz wszystkich przedstawionych już zalet jest to najważniejszy argument przemawiający za stosowaniem Isomorphic TypeScript we wszystkich kolejnych projektach, zwłaszcza komercyjnych.",
        "Runtime Types": "Typy w czasie rzeczywistym",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "Udostępnienie informacji o typie w TypeScript w czasie uruchamiania zmienia wiele rzeczy. Umożliwia to nowe sposoby pracy, które wcześniej były możliwe tylko w okrężny sposób lub wcale. Deklarowanie typów i schematów stało się istotną częścią nowoczesnych procesów programowania. GraphQL, walidatory, ORM-y, kodery takie jak ProtoBuf i wiele innych zależą od posiadania informacji o schemacie dostępnych w czasie pracy, aby zapewnić podstawową funkcjonalność. Te narzędzia i biblioteki wymagają czasem od programisty nauki zupełnie nowych języków, które zostały opracowane specjalnie dla danego przypadku użycia. Na przykład ProtoBuf i GraphQL mają swój własny język deklaracji, a walidatory często opierają się na własnych API schematów lub nawet na schemacie JSON, który również jest niezależnym sposobem definiowania struktur. Niektóre z nich wymagają uruchamiania generatorów kodu za każdym razem, gdy wprowadzana jest zmiana, aby dostarczyć informacje o schemacie również do trybu runtime. Innym znanym wzorcem jest używanie eksperymentalnych dekoratorów TypeScript do dostarczania metainformacji do klas w czasie działania.",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "Ale czy to wszystko jest konieczne? TypeScript oferuje bardzo wydajny język do opisywania nawet bardzo złożonych struktur. W rzeczywistości TypeScript jest obecnie touring-complete, co w przybliżeniu oznacza, że teoretycznie każdy rodzaj programu może być odwzorowany w TypeScript. Oczywiście, ma to swoje praktyczne ograniczenia, ale ważne jest to, że TypeScript jest w stanie całkowicie zastąpić dowolny format deklaracji, taki jak GraphQL, ProtoBuf, JSON Schema i wiele innych. W połączeniu z systemem typów w czasie uruchamiania możliwe jest uwzględnienie wszystkich opisanych narzędzi i ich przypadków użycia w samym języku TypeScript, bez konieczności stosowania generatora kodu. Dlaczego jednak nadal nie ma rozwiązania, które umożliwiałoby właśnie to?",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "W ciągu ostatnich kilku lat język TypeScript przeszedł ogromną transformację. Został on kilkakrotnie całkowicie przepisany, otrzymał podstawowe funkcje oraz przeszedł wiele iteracji i zmian. W międzyczasie TypeScript osiągnął jednak takie dopasowanie do rynku produktów, które znacznie spowalnia tempo wprowadzania fundamentalnych innowacji i przełomowych zmian. TypeScript sprawdził się i pokazał, jak powinien wyglądać bardzo uroczy system typów dla bardzo dynamicznego języka, jakim jest JavaScript. Rynek z wdzięcznością przyjął ten postęp i zapoczątkował nową erę w rozwoju JavaScript.",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "To jest właśnie dobry moment, aby na poziomie podstawowym zbudować narzędzia na bazie samego języka, które umożliwią realizację powyższych założeń. Deepkit chce być impulsem do przeniesienia sprawdzonych przez dziesięciolecia wzorców projektowych z takich języków jak Java i PHP nie tylko zasadniczo do TypeScript, ale w nowy i lepszy sposób, który działa nie przeciwko, ale z JavaScriptem. Dzięki informacji o typie w czasie wykonywania, po raz pierwszy są one nie tylko zasadniczo możliwe, ale także umożliwiają tworzenie zupełnie nowych, znacznie prostszych wzorców projektowych, które nie są możliwe w językach takich jak Java czy PHP. Sam język TypeScript położył tutaj fundamenty pod znaczne ułatwienie życia programisty dzięki zupełnie nowym podejściom w połączeniu ze sprawdzonymi rozwiązaniami.",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "Odczytywanie informacji o typie w czasie wykonywania aplikacji to umiejętność, na której Deepkit buduje swoje podstawy. Interfejs API bibliotek Deepkit jest w dużej mierze ukierunkowany na wykorzystanie jak największej ilości informacji o typach w języku TypeScript w celu uzyskania jak największej wydajności. System typów w czasie wykonywania oznacza, że informacja o typie jest czytelna w czasie wykonywania, a typy dynamiczne są obliczalne. Oznacza to na przykład, że można odczytywać wszystkie właściwości klas oraz wszystkie parametry i typy zwrotne funkcji.",
        "Nehmen wir als Beispiel diese Funktion:": "Weźmy na przykład tę funkcję:",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "W samym języku JavaScript można odczytać kilka informacji w czasie wykonywania. Na przykład nazwa funkcji (jeśli nie została zmieniona za pomocą minimalizatora):",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "Z drugiej strony, można odczytać liczbę parametrów:",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "Przy użyciu nieco większej ilości kodu można również odczytać nazwy parametrów. Jednak nie da się tego zrobić bez podstawowego parsera JavaScript lub RegExp na log.toString(), więc na tym koniec. Ponieważ TypeScript tłumaczy powyższą funkcję na język JavaScript w następujący sposób:",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "informacja, że `message` jest typu string, a typ zwracany jest typu `void`, nie jest już dostępna. Informacje te zostały nieodwracalnie zniszczone przez język TypeScript.",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "Jednak dzięki systemowi typów w czasie wykonywania programu informacje te mogą zostać zachowane, dzięki czemu typy komunikatów i typ zwracany można odczytać programowo.",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit właśnie to umożliwia. Podłącza się on do kompilacji TypeScript i zapewnia, że wszystkie informacje o typie są wbudowane w generowany JavaScript. Funkcje takie jak typeOf() (nie mylić z operatorem typeof, z małą literą o) umożliwiają programiście dostęp do tych danych. Można zatem tworzyć biblioteki oparte na tych informacjach o typach, co pozwala programiście wykorzystać już napisane typy TypeScript do wielu różnych zastosowań.",
        "Installation": "Instalacja",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "Aby zainstalować system typu runtime Deepkit, potrzebne są dwa pakiety. Kompilator typów w `@deepkit/type-compiler` oraz niezbędny runtime w `@deepkit/type`. Kompilator typów można zainstalować w pliku `package.json` _devDependencies_, ponieważ jest on potrzebny tylko w czasie kompilacji.",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "Informacje o typie Runtime Type nie są domyślnie generowane. Musi być ustawiona `\"reflection\": true` w pliku `tsconfig.json`, aby włączyć ją we wszystkich plikach w tym samym folderze tego pliku lub we wszystkich podfolderach. Jeśli mają być używane dekoratory, `\"experimentalDecorators\": true` musi być włączone w pliku `tsconfig.json`. Nie jest to ściśle niezbędne do pracy z `@deepkit/type`, ale jest konieczne dla pewnych funkcji innych bibliotek deepkit oraz w `@deepkit/framework`.",
        "_Datei: tsconfig.json_": "Plik: tsconfig.json_",
        "Type compiler": "Kompilator typów",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "Sam TypeScript nie pozwala na konfigurowanie kompilatora typów za pomocą pliku `tsconfig.json`. Konieczne jest albo bezpośrednie użycie API kompilatora TypeScript, albo systemu budowania, takiego jak Webpack z _ts-loader_. Aby uniknąć tej niedogodności dla użytkowników Deepkit, kompilator typów Deepkit automatycznie instaluje się w `node_modules/typescript`, gdy zainstalowany jest `@deepkit/type-compiler` (odbywa się to za pomocą haków instalacyjnych NPM).",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "Dzięki temu wszystkie narzędzia budujące, które mają dostęp do lokalnie zainstalowanego TypeScriptu (tego w `node_modules/typescript`), będą miały automatycznie włączony kompilator typów. Dzięki temu _tsc_, Angular, webpack, _ts-node_ i niektóre inne narzędzia automatycznie współpracują z kompilatorem typów Deepkit.",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "Jeśli kompilator typów nie mógł zostać zainstalowany automatycznie (na przykład dlatego, że haki instalacyjne NPM są wyłączone), można to zrobić ręcznie za pomocą następującego polecenia:",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "Zauważ, że `deepkit-type-install` musi być wykonany, jeśli lokalna wersja typescript została zaktualizowana (na przykład, jeśli wersja typescript w package.json zmieniła się i `npm install` został wykonany).",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "Jeśli kompilator typów ma być użyty w kompilacji webpacka, można to zrobić za pomocą pakietu `ts-loader` (lub dowolnego innego, który obsługuje rejestrację transformatorów).",
        "_Datei: webpack.config.js_": "Plik: webpack.config.js_",
        "Typen-Decorators": "Dekoratorzy typu",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "Dekoratory typów to zwykłe typy TypeScript, które zawierają metainformacje umożliwiające zmianę zachowania różnych funkcji w czasie wykonywania. Deepkit udostępnia już pewne dekoratory typów, które obejmują niektóre przypadki użycia. Na przykład właściwość klasy może być oznaczona jako klucz główny, referencja lub indeks. Biblioteka bazy danych może wykorzystać te informacje w czasie pracy, aby utworzyć poprawne zapytania SQL bez wcześniejszego generowania kodu.",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Do każdego typu można także dodać ograniczenia walidatora, takie jak `MaxLength`, `Maximum` czy `Positive`. Można również powiedzieć serializatorowi, w jaki sposób ma serializować lub deserializować określoną wartość. Ponadto możliwe jest tworzenie całkowicie niestandardowych dekoratorów typów i odczytywanie ich w czasie wykonywania, co pozwala na bardzo indywidualne korzystanie z systemu typów w czasie wykonywania.",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit posiada cały zestaw dekoratorów typów, z których wszystkie mogą być używane bezpośrednio z `@deepkit/type`. Zostały one zaprojektowane tak, aby nie pochodziły z wielu bibliotek, aby nie wiązać kodu bezpośrednio z konkretną biblioteką, taką jak Deepkit RPC czy Deepkit Database. Pozwala to na łatwiejsze ponowne wykorzystanie typów, nawet we frontendzie, mimo że używane są na przykład dekoratory typów baz danych.",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "Poniżej znajduje się lista istniejących dekoratorów typów. Walidator i serializator `@deepkit/type` i `@deepkit/bson` oraz baza danych Deepkit z `@deepkit/orm` używały tej informacji w różny sposób. Więcej informacji na ten temat można znaleźć w odpowiednich rozdziałach.",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Liczby całkowite i zmiennoprzecinkowe są zdefiniowane jako `number` i mają kilka podwariantów:",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "W tym przypadku `id` użytkownika jest liczbą w czasie pracy, ale jest interpretowany jako liczba całkowita podczas sprawdzania poprawności i serializacji.",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "Oznacza to, że na przykład w walidacji nie można używać liczb zmiennoprzecinkowych, a serializator automatycznie konwertuje liczby zmiennoprzecinkowe na całkowite.",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "Podtypy mogą być używane w ten sam sposób i są przydatne, jeśli ma być dozwolony pewien zakres liczb.",
        "Float": "Float",
        "UUID": "UUID",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4 jest zwykle przechowywany w bazie danych jako liczba binarna, a w JSON jako ciąg znaków.",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "Oznacza to pole jako ObjectId dla MongoDB. Rozwiązuje się jako ciąg znaków. Jest przechowywany w MongoDB w postaci binarnej.",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save as bigint in JavaScript has a unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the BinaryBigInt is available.": "Domyślnie zwykły typ bigint serializuje się jako number w JSON (i long w BSON). Ma to jednak ograniczenia w tym, co można zapisać, ponieważ bigint w JavaScript ma nieograniczony potencjalny rozmiar, podczas gdy liczby w JavaScript i long w BSON są ograniczone. Aby obejść to ograniczenie, można skorzystać z funkcji BinaryBigInt.",
        "Same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (abs(x)).": "To samo co bigint, ale serializuje się do unsigned binary o nieograniczonym rozmiarze (zamiast 8 bajtów w większości baz danych) w bazach danych i do łańcucha w JSON. Wartości ujemne zostaną zamienione na dodatnie (abs(x)).",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM przechowuje BinaryBigInt jako pole binarne.",
        "`SignedBinaryBigInt` is the same as BinaryBigInt but is able to store negative values as well.": "SignedBinaryBigInt\" jest taki sam jak \"BinaryBigInt\", ale może również przechowywać wartości ujemne.",
        "Deepkit ORM stores SignedBinaryBigInt as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "Deepkit ORM przechowuje SignedBinaryBigInt w postaci binarnej. Liczba binarna ma dodatkowy bajt ze znakiem wiodącym i jest reprezentowana jako liczba uint: 255 dla wartości ujemnej, 0 dla zera lub 1 dla wartości dodatniej.",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "Aby zmienić nazwę właściwości w serializacji.",
        "Group": "Grupa",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "Właściwości można łączyć w grupy. W przypadku serializacji można na przykład wykluczyć grupę z serializacji. Więcej informacji na ten temat można znaleźć w rozdziale Serializacja.",
        "Data": "Dane",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "Każda właściwość może zawierać dodatkowe metadane, które można odczytać za pomocą interfejsu API Reflection. Zobacz <<runtime-types-reflection>>, aby uzyskać więcej informacji.",
        "Excluded": "Wyłączone",
        "Each property can be excluded from the serialization process for a specific target.": "Każdą właściwość można wykluczyć z procesu serializacji dla określonego celu.",
        "Embedded": "Wbudowana strona",
        "Marks the field as an embedded type.": "Oznacza pole jako typ wbudowany.",
        "It's possible to change the prefix (which is per default the property name).": "Istnieje możliwość zmiany prefiksu (który domyślnie jest nazwą właściwości).",
        "Entity": "Podmiot",
        "To annotate interfaces with entity information. Only used in the database context.": "Aby nadać interfejsom adnotacje z informacjami o encji. Używane tylko w kontekście bazy danych.",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "Baza danych",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Siehe dazu Kapitel Validation <<validation-constraint-types>>.": "Patrz rozdział Walidacja <<validation-constraint-types>>.",
        "Benutzerdefinierte Type-Decorators": "Dekoratorzy typów niestandardowych",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "Dekorator typu można zdefiniować w następujący sposób:",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "Zwyczajowo dekorator typu jest definiowany jako literał obiektu z pojedynczą opcjonalną właściwością `__meta`, której typem jest tuple. Pierwszy wpis w tej krotce jest jej unikalną nazwą, a wszystkie kolejne wpisy w krotce są dowolnymi opcjami. W ten sposób dekorator typu można wyposażyć w dodatkowe opcje.",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "Dekorator typu jest używany z operatorem przecięcia `&`. Na jednym typie można zastosować dowolną liczbę dekoratorów typu.",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "Dekoratory typu można odczytać za pomocą obiektów typu `typeOf<T>()` i `metaAnnotation`:",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "Wynik w `annotation` jest albo tablicą opcji, jeśli użyto dekoratora typu `myAnnotation`, albo `undefined`, jeśli nie. Jeśli dekorator typu ma dodatkowe opcje widoczne w `AnnotationOption`, przekazane wartości należy umieścić w tablicy.",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "Dostarczone już dekoratory typu, takie jak `MapName`, `Group`, `Data` itp. mają swoje własne obiekty adnotacji:",
        "Siehe das Kapitel <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "Aby dowiedzieć się więcej na ten temat, zobacz rozdział <<runtime-types-reflection>>.",
        "External Classes": "Klasy zewnętrzne",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "Ponieważ TypeScript domyślnie nie zawiera informacji o typie, typy/klasy importowane z innych pakietów (które nie użyły @deepkit/type-compiler) nie będą miały dostępnych informacji o typie.",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "Aby przypisać typy do zewnętrznej klasy, należy użyć `annotateClass` i upewnić się, że funkcja ta jest wykonywana w fazie bootstrap aplikacji, zanim zaimportowana klasa zostanie użyta gdzie indziej.",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "Klasa MyExternalClass` może być teraz używana w funkcjach serializacji oraz w interfejsie API refleksji.",
        "To following shows how to annotate generic classes:": "Poniżej przedstawiono sposób tworzenia adnotacji do klas generycznych:",
        "Reflection": "Odbicie",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "W celu bezpośredniej pracy z informacjami o typie istnieją dwa podstawowe warianty: Obiekty typu i klasy Reflection. Klasy refleksji zostały omówione poniżej. Funkcja `typeOf` zwraca obiekty typu, które są bardzo prostymi literałami obiektów. Zawsze zawiera on `kind`, który jest liczbą i otrzymuje swoje znaczenie za pomocą enum `ReflectionKind`. Klasa `ReflectionKind` jest zdefiniowana w pakiecie `@deepkit/type` w następujący sposób:",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "Istnieje wiele możliwych typów obiektów, które mogą zostać zwrócone. Najprostsze z nich to `never`, `any`, `unknown`, `void, null,` i `undefined`, które są reprezentowane w następujący sposób:",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "Na przykład numer 0 jest pierwszym wpisem enum `ReflectionKind`, w tym przypadku `never`, numer 1 jest drugim wpisem, tutaj `any`, i tak dalej. Odpowiednio, typy prymitywne takie jak `string`, `number`, `boolean` są reprezentowane w następujący sposób:",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "Te dość proste typy nie mają żadnych dalszych informacji o obiekcie typu, ponieważ zostały przekazane bezpośrednio jako argument typu do `typeOf`. Jeśli jednak typy są przekazywane za pomocą aliasów typów, dodatkowe informacje można znaleźć w obiekcie typu.",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "W tym przypadku dostępna jest również nazwa aliasu typu `Title`. Jeśli alias typu jest generyczny, przekazane typy stają się również dostępne w obiekcie typu.",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "Jeśli przekazany typ jest wynikiem działania operatora dostępu do indeksu, to kontener i typ indeksu są obecne:",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "Interfejsy i obiekty literalne są wyprowadzane jako Reflection.objectLiteral i zawierają właściwości i metody w tablicy `types`.",
        "Index Signatures sind ebenfalls in dem `types` array.": "Sygnatury indeksów znajdują się również w tablicy `types`.",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "Klasy są podobne do literałów obiektów i również posiadają swoje właściwości i metody w tablicy `types`, oprócz `classType`, która jest referencją do samej klasy.",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "Zwróć uwagę, że typ Reflection.propertySignature został zmieniony na Reflection.property, a Reflection.methodSignature na Reflection.method. Ponieważ właściwości i metody klas mają dodatkowe atrybuty, informacje te można również pobierać. Te ostatnie zawierają dodatkowo `visibility`, `abstract` i `default`.",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "Obiekty typu klasy zawierają tylko właściwości i metody samej klasy, a nie jej nadklas. Jest to przeciwieństwo obiektów typu interfejsów/obiektów-literałów, które mają wszystkie sygnatury właściwości i sygnatury metod wszystkich rodziców rozwiązane w `typach`. Aby rozwiązać właściwości i metody nadklas, można użyć albo ReflectionClass i jego `ReflectionClass.getProperties()` (zobacz następne sekcje) albo `resolveTypeMembers()` z `@deepkit/type`.",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "Istnieje cała gama obiektów typu. Na przykład literał, literał szablonu, obietnica, enum, unia, tablica, tuple i wiele innych. Aby dowiedzieć się, które z nich istnieją i jakie informacje są dostępne, zaleca się zaimportowanie `Type` z `@deepkit/type`. Jest to `union` ze wszystkimi możliwymi podtypami, takimi jak TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass i wiele innych. Tam też można znaleźć dokładną strukturę.",
        "Type Cache": "Typ Pamięć podręczna",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "Obiekty typu są buforowane dla aliasów typów, funkcji i klas, gdy tylko nie zostanie przekazany żaden argument generyczny. Oznacza to, że wywołanie funkcji `typeOf<MyClass>()` zawsze zwraca ten sam obiekt.",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "Jednak gdy tylko zostanie użyty typ generyczny, zawsze tworzone są nowe obiekty, nawet jeśli przekazywany typ jest zawsze taki sam. Dzieje się tak dlatego, że teoretycznie możliwa jest nieskończona liczba kombinacji, a taka pamięć podręczna stanowiłaby w praktyce wyciek pamięci.",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "Jednak gdy tylko typ jest instancjonowany kilka razy w typie rekurencyjnym, jest on buforowany. Jednak czas trwania pamięci podręcznej jest ograniczony tylko do momentu obliczenia typu, a później już nie istnieje. Ponadto, mimo że obiekt typu jest buforowany, zwracana jest nowa referencja, która nie jest dokładnie tym samym obiektem.",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "MyType<string>` jest buforowany tak długo, jak długo obliczany jest `Object`. PropertySignature `a` i `b` mają więc ten sam `typ` z pamięci podręcznej, ale nie są tym samym obiektem Type.",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "Wszystkie obiekty typu niebędące typami głównymi mają właściwość parent, która zwykle wskazuje na otaczającego rodzica. Jest to przydatne na przykład w celu sprawdzenia, czy dany typ jest częścią unii, czy nie.",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "Ref 1\" wskazuje na rzeczywisty obiekt typu unii.",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "W przypadku obiektów typu buforowanego, jak pokazano na powyższym przykładzie, właściwości `parent` nie zawsze są prawdziwymi rodzicami. Na przykład w przypadku klasy, która jest używana wielokrotnie, mimo że typy bezpośrednie w `types` (TypePropertySignature i TypeMethodSignature) wskazują na właściwą klasę TypeClass, to `type` tych typów sygnatur wskazuje na typy sygnatur klasy TypeClass buforowanego wpisu. Warto o tym wiedzieć, aby nie odczytywać w nieskończoność struktury nadrzędnej, lecz tylko bezpośrednią strukturę nadrzędną. Fakt, że rodzic nie ma nieskończonej precyzji, wynika z przyczyn wydajnościowych.",
        "JIT Cache": "Pamięć podręczna JIT",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "W dalszej części opisano niektóre funkcje i właściwości, które często bazują na obiektach typu. Aby zaimplementować niektóre z nich w sposób wydajny, potrzebna jest pamięć podręczna JIT (just in time) dla każdego typu obiektu. Można to zrobić za pomocą polecenia `getJitContainer(type)`. Ta funkcja zwraca prosty obiekt, na którym można zapisać dowolne dane. Dopóki nie jest przechowywana żadna referencja do tego obiektu, jest on automatycznie usuwany przez GC, gdy tylko obiekt typu przestanie być obiektem odniesienia.",
        "Reflection-Klassen": "Klasy refleksji",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "Oprócz funkcji `typeOf<>()` istnieją różne klasy refleksji, które stanowią alternatywę OOP dla obiektów typu. Klasy refleksji są dostępne tylko dla klas, literałów interfejsów/obiektów i funkcji oraz ich bezpośrednich podtypów (właściwości, metod, parametrów). Wszystkie głębsze typy muszą być ponownie odczytane za pomocą obiektów typu.",
        "Typeninformation empfangen": "Informacje o typie odbiornika",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "W celu zapewnienia funkcji operujących na typach przydatne może być zaoferowanie użytkownikowi ręcznego podania typu. Na przykład w funkcji sprawdzania poprawności przydatne może być podanie żądanego typu jako pierwszego argumentu typu oraz danych, które mają być sprawdzone jako pierwszego argumentu funkcji.",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "Aby funkcja mogła otrzymać typ `string`, musi to zakomunikować kompilatorowi typów.",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType` z referencją do pierwszego argumentu typu `T` sygnalizuje kompilatorowi typów, że każde wywołanie `validate` powinno umieścić typ na drugim miejscu (ponieważ `type` jest zadeklarowany na drugim miejscu). Aby odczytać te informacje w czasie pracy, używana jest funkcja `resolveReceiveType`.",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "Warto przypisać wynik do tej samej zmiennej, aby niepotrzebnie nie tworzyć nowej. W `type` jest teraz albo przechowywany obiekt typu, albo wyrzucany jest błąd, jeśli na przykład nie został przekazany żaden argument typu, kompilator typów Deepkita nie został poprawnie zainstalowany lub emitowanie informacji o typie nie jest włączone (zobacz sekcję dotyczącą instalacji powyżej).",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "Ten rozdział jest przeznaczony do szczegółowego zapoznania się z tym, jak Deepkit koduje i odczytuje informacje o typie w języku JavaScript. Wyjaśnia, w jaki sposób typy są faktycznie konwertowane na kod bajtowy, emitowane w JavaScript, a następnie interpretowane w czasie wykonywania.",
        "Typen-Compiler": "Kompilator typów",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "Kompilator typów (w @deepkit/type-compiler) jest odpowiedzialny za odczytywanie zdefiniowanych typów w plikach TypeScript i kompilowanie ich do postaci kodu bajtowego. Ten kod bajtowy zawiera wszystko, co jest potrzebne do wykonania typów w trybie runtime.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "W chwili pisania tego tekstu kompilator typów jest tak zwanym transformatorem języka TypeScript. Transformator ten jest wtyczką do samego kompilatora TypeScript i konwertuje drzewo składni abstrakcyjnej (AST) języka TypeScript na inne drzewo składni TypeScript. W tym procesie kompilator typów Deepkit odczytuje AST, tworzy odpowiedni kod bajtowy i wstawia go do AST.",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "Sam TypeScript nie pozwala na skonfigurowanie tego pluginu aka transformatora za pomocą tsconfig.json. Konieczne jest albo bezpośrednie użycie API kompilatora TypeScript, albo systemu budowania, takiego jak Webpack z `ts-loader`. Aby uniknąć tej niedogodności dla użytkowników Deepkit, kompilator typów Deepkit automatycznie instaluje się w `node_modules/typescript`, gdy zainstalowany jest `@deepkit/type-compiler`. Dzięki temu wszystkie narzędzia budujące, które mają dostęp do lokalnie zainstalowanego TypeScriptu (tego w `node_modules/typescript`), będą miały automatycznie włączony kompilator typów. Dzięki temu tsc, Angular, webpack, ts-node i niektóre inne narzędzia automatycznie współpracują z kompilatorem typów Deepkit.",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "Jeśli nie włączono automatycznego wykonywania skryptów instalacyjnych NPM i nie zmodyfikowano lokalnie zainstalowanego skryptu, proces ten należy w razie potrzeby wykonać ręcznie. Kompilatora typów można też użyć ręcznie w narzędziu budującym, takim jak webpack. Patrz rozdział Instalacja powyżej.",
        "Bytecode Encoding": "Kodowanie bajtkodu",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "Kod bajtowy jest sekwencją poleceń dla maszyny wirtualnej i jest zakodowany w samym JavaScripcie jako tablica z referencjami i ciągiem znaków (właściwy kod bajtowy).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "Same istniejące komendy mają rozmiar jednego bajtu i można je znaleźć w `@deepkit/type-spec` jako enumy `ReflectionOp`. W chwili pisania tego tekstu zestaw poleceń liczy ponad 81 poleceń.",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "Sekwencja poleceń jest zakodowana jako ciąg znaków, co pozwala zaoszczędzić pamięć. Tak więc typ `string[]` jest konceptualizowany jako program bajtowy `[string, array]`, który ma bajty `[5, 37]` i jest kodowany według następującego algorytmu:",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "Odpowiednio, 5 staje się znakiem `&`, a 37 staje się znakiem `F`. Razem tworzą one `&F` i są emitowane w języku Javascript jako `['&F']`.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "Aby zapobiec konfliktom nazw, każdy typ otrzymuje \"_Ω\" jako prefiks. Dla każdego jawnie zdefiniowanego typu, który jest eksportowany lub używany przez typ eksportowany, JavaScript emituje kod bajtowy. Klasy i funkcje również otrzymują kod bajtowy bezpośrednio jako właściwość.",
        "Virtuelle Maschine": "Maszyna wirtualna",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "Maszyna wirtualna (w `@deepkit/type` klasa Processor) w trybie runtime jest odpowiedzialna za dekodowanie i wykonywanie zakodowanego bajtkodu. Zwraca ona zawsze obiekt typu, patrz rozdział Refleksja powyżej.",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Walidacja to proces sprawdzania poprawności danych. Poprawność jest zapewniona, jeśli typ jest poprawny i spełnione są dodatkowe zdefiniowane ograniczenia. W pakiecie Deepkit zasadniczo rozróżnia się walidację typu i walidację dodatkowych ograniczeń.",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "Walidację stosuje się zawsze wtedy, gdy dane pochodzą ze źródła, które uważa się za niepewne. Niepewność oznacza, że nie można przyjąć żadnych gwarantowanych założeń dotyczących typów lub zawartości danych, a zatem dane te mogą mieć dosłownie dowolną wartość w czasie wykonywania zadania.",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "Na przykład dane wprowadzane przez użytkowników nie są na ogół uważane za bezpieczne. Dane z żądania HTTP (parametr zapytania, treść), argumenty CLI lub wczytany plik muszą zostać zweryfikowane. Jeśli zmienna jest zadeklarowana jako liczba, musi się w niej znajdować również liczba, w przeciwnym razie program może się zawiesić lub może wystąpić luka w zabezpieczeniach.",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "Na przykład w kontrolerze trasy HTTP najważniejszym priorytetem jest sprawdzenie każdego wejścia użytkownika (parametru zapytania, ciała). Szczególnie w środowisku TypeScript nie należy używać rzutowania typów, ponieważ jest ono z gruntu niebezpieczne.",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "Ten często spotykany kod jest błędem, który może doprowadzić do awarii programu lub powstania luki w zabezpieczeniach, ponieważ użyto rzutowania typu `jak liczba`, które nie zapewnia żadnego bezpieczeństwa w czasie wykonywania programu. Użytkownik może po prostu przekazać łańcuch jako `limit`, a program będzie wtedy pracował z łańcuchem w `limit`, chociaż kod opiera się na tym, że musi to być liczba. Aby zachować to bezpieczeństwo w czasie pracy, stosuje się walidatory i strażniki typów. Można też użyć serializera do konwersji `limit` na liczbę. Więcej informacji na ten temat można znaleźć w rozdziale <<serializacja>>.",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "Walidacja jest niezbędnym elementem każdej aplikacji i lepiej jest ją stosować raz za często niż raz za rzadko. Deepkit udostępnia wiele opcji walidacji i ma wydajną implementację, więc w większości przypadków nie trzeba się martwić o czas wykonania. Użyj jak najwięcej walidacji, a w razie wątpliwości użyj więcej, aby się zabezpieczyć.",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "Wiele komponentów Deepkit, takich jak router HTTP, abstrakcja RPC, ale także sama abstrakcja bazy danych, ma wbudowaną walidację, która jest wykonywana automatycznie, tak że w wielu przypadkach nie ma potrzeby wykonywania jej ręcznie.",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "W odpowiednich rozdziałach (<<cli>>, <<http>>, <<rpc>>, <<database>>) szczegółowo wyjaśniono, kiedy walidacja odbywa się automatycznie. Upewnij się, że wiesz, gdzie należy zdefiniować ograniczenia lub typy i nie używaj `każdego`, aby te walidacje działały dobrze i bezpiecznie automatycznie. Dzięki temu można zaoszczędzić wiele pracy ręcznej związanej z utrzymaniem czystości i bezpieczeństwa kodu.",
        "Benutzung": "Użyj strony",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "Podstawową funkcją walidatora jest sprawdzanie wartości pod kątem jej typu. Na przykład, czy wartość jest ciągiem znaków. Nie chodzi o to, co zawiera łańcuch, lecz tylko o jego typ. W typie skryptu istnieje wiele typów: string, number, boolean, bigint, obiekty, klasy, interfejsy, generics, typy mapowane i wiele innych. Dzięki rozbudowanemu systemowi typów w języku Typescript dostępna jest duża liczba różnych typów.",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "W samym języku JavaScript typy prymitywne można analizować za pomocą operatora `typeof`. W przypadku bardziej złożonych typów, takich jak interfejsy, typy odwzorowane czy generic set/map, nie jest to już możliwe i konieczna jest biblioteka walidatorów, taka jak `@deepkit/type`. Deepkit jest jedynym rozwiązaniem, które umożliwia bezpośrednią walidację wszystkich typów TypesScript bez konieczności korzystania z objazdów.",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "Typ `username` to string. Jeśli walidator ma sprawdzić, czy zmienna `username` jest ciągiem znaków, można to łatwo zrobić za pomocą samego JavaScriptu.",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "Funkcja `isString` może być zatem postrzegana jako walidator typów. W samym języku JavaScript staje się to jednak trudniejsze, gdy trzeba sprawdzić liczby. Istnieją specjalne funkcje, takie jak NaN (\"Not a Number\"), gdy nieprawidłowy ciąg znaków jest przekształcany na liczbę.",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "Operator `typeof` zwraca liczbę, choć jest to wartość NaN (\"Not a Number\"), która dosłownie mówi, że nie chce być liczbą. Od tego momentu należy przeprowadzać specjalne dodatkowe kontrole, takie jak `isNaN()`, i szybko staje się oczywiste, że należy korzystać z zewnętrznych bibliotek, takich jak Deepkit, które automatycznie uwzględniają te osobliwości.",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "W Deepkit, walidacja typu może być przeprowadzona za pomocą funkcji `validate`, `is` lub `assert`. Funkcja `is` jest tzw. strażnikiem typu, a `assert` jest asercją typu. Obie te kwestie zostaną wyjaśnione w następnym rozdziale.",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "Funkcja `validate` zwraca tablicę znalezionych błędów, a w przypadku powodzenia - pustą tablicę. Każdy wpis w tej tablicy opisuje dokładny kod błędu oraz komunikat o błędzie, a także ścieżkę, gdy tylko sprawdzane są bardziej złożone typy, takie jak obiekty lub tablice.",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "Wszystkie trzy funkcje są wykorzystywane w mniej więcej taki sam sposób. Typ jest określany lub przywoływany jako pierwszy argument typu, a dane są przekazywane jako pierwszy argument funkcji.",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "Podczas pracy z bardziej złożonymi typami, takimi jak klasy lub interfejsy, tablica może również zawierać kilka wpisów.",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "Walidator obsługuje również typy głęboko rekursywne. Ścieżki są następnie oddzielane kropką.",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "Wykorzystaj zalety, jakie oferuje Ci język TypeScript. Na przykład bardziej złożone typy, takie jak `user`, mogą być używane w wielu miejscach bez konieczności ich wielokrotnego deklarowania. Na przykład, jeśli `user` ma być walidowany bez jego `id`, można użyć narzędzi TypeScript do szybkiego i efektywnego tworzenia podtypów pochodnych. W duchu zasady DRY (Don't Repeat Yourself - nie powtarzaj się).",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit jest jedynym dużym frameworkiem, który może w ten sposób uzyskiwać dostęp do typów TypeScripts w czasie uruchamiania. Jeśli typy mają być używane zarówno we front-endzie, jak i w backendzie, można je przenieść do osobnego pliku i w ten sposób importować wszędzie. Skorzystaj z tej opcji, aby zachować wydajność i czystość kodu.",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "Rzutowanie typu (w przeciwieństwie do strażnika typu) w TypeScripcie nie jest konstrukcją wykonywaną w czasie rzeczywistym, lecz jest obsługiwane w samym systemie typów. Nie jest to bezpieczny sposób przypisywania typu do nieznanych danych.",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "Kod `as string` nie jest bezpieczny. Zmienna `data` może mieć dosłownie dowolną wartość, na przykład `{username: 123}`, lub nawet `{}`, i spowoduje, że `username` nie będzie ciągiem znaków, lecz czymś zupełnie innym, a zatem kod `username.startsWith('@')` spowoduje błąd, tak że w najgorszym przypadku program się zawiesi. Aby zagwarantować, że `data` posiada właściwość `username` o typie string, należy użyć strażników typu.",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "Strażnicy typów to funkcje, które podpowiadają TypeScriptowi, jakiego typu mają być przekazywane dane w czasie wykonywania. Zaopatrzony w tę wiedzę TypeScript udoskonala (\"zawęża\") typ w dalszym toku kodu.  Na przykład `any` można zamienić na łańcuch lub inny typ w bezpieczny sposób.",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "Jeśli istnieją dane, których typ nie jest znany (`każdy` lub `nieznany`), strażnik typu pomaga zawęzić je bardziej precyzyjnie na podstawie samych danych. Jednak strażnik typu jest tak bezpieczny, jak jego implementacja. Jeśli popełnisz błąd, może to mieć poważne konsekwencje, ponieważ podstawowe założenia nagle okażą się nieprawdziwe.",
        "Type-Guard": "Typ-Guard",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "Strażnik typu na wyżej wymienionym typie `User` może wyglądać w najprostszej postaci następująco. Należy zauważyć, że wyjaśnione powyżej specjalne właściwości NaN nie są częścią tego typu i dlatego nie jest on w pełni poprawny.",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "Strażnik typu zawsze zwraca wartość logiczną i jest zwykle używany bezpośrednio w operacji If.",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "Pisanie osobnej funkcji dla każdego zabezpieczenia typu, zwłaszcza dla bardziej złożonych typów, a następnie dostosowywanie jej za każdym razem, gdy zmienia się typ, jest niezwykle żmudne, podatne na błędy i nieefektywne. Dlatego Deepkit oferuje funkcję `is`, która automatycznie zapewnia ochronę typu dla dowolnego typu TypeScript. W ten sposób automatycznie uwzględnia się cechy szczególne, takie jak wspomniany wyżej problem z NaN. Funkcja `is` robi to samo co `validate`, ale zamiast tablicy błędów zwraca po prostu boolean.",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "Częściej spotykanym wzorcem jest zwracanie błędu bezpośrednio w przypadku błędnej walidacji, tak aby nie był wykonywany kolejny kod. Można to wykorzystać w różnych miejscach, nie zmieniając całego przepływu kodu.",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "Alternatywnie można użyć asercji typu TypeScript. Funkcja `assert` automatycznie wyrzuca błąd, jeśli podane dane nie są poprawnie zweryfikowane do typu. Specjalna sygnatura funkcji, która wyróżnia asercje typu TypeScript, pomaga TypeScriptowi automatycznie zawęzić przekazywaną zmienną.",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "Skorzystaj z zalet, jakie TypeScript oferuje również tutaj. Typy można ponownie wykorzystać lub dostosować za pomocą różnych funkcji języka TypeScript.",
        "Error Reporting": "Zgłaszanie błędów",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "Funkcje `is`, `assert` i `validates` zwracają jako wynik wartość logiczną. Aby uzyskać dokładne informacje o nieudanych regułach walidacji, można użyć funkcji `validate`. Zwraca pustą tablicę, jeśli wszystko zostało pomyślnie zwalidowane. Jeśli wystąpią błędy, tablica zawiera jeden lub więcej wpisów o następującej strukturze:",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "Funkcja otrzymuje dowolny typ TypeScript jako pierwszy argument typu oraz dane do sprawdzenia jako pierwszy argument.",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "Można również stosować typy złożone, takie jak interfejsy, klasy lub generyczne.",
        "Einschränkungen": "Ograniczenia",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "Oprócz sprawdzania typów, do typu można dodać dowolne inne ograniczenia. Sprawdzanie tych dodatkowych ograniczeń treści odbywa się automatycznie po sprawdzeniu samych typów. Odbywa się to we wszystkich funkcjach walidacji, takich jak `validate`, `is` i `assert`. Ograniczenie może polegać na przykład na tym, że ciąg znaków musi mieć określoną minimalną lub maksymalną długość.",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "Ograniczenia te są dodawane do typów rzeczywistych za pomocą dekoratorów typów. Istnieje cała gama dekoratorów, z których można korzystać. Można zdefiniować własne dekoratory i używać ich zgodnie z potrzebami w przypadku rozszerzonych potrzeb.",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "Za pomocą `&` do typu rzeczywistego można dodać dowolną liczbę dekoratorów typu. Wynik, tutaj `username`, może być następnie użyty we wszystkich funkcjach walidacyjnych, ale także w innych typach.",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "Funkcja `validate` podaje użyteczne komunikaty o błędach, które wynikają z ograniczeń.",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "Informacje te mogą być na przykład automatycznie wyświetlane na formularzu i tłumaczone za pomocą \"kodu\". Dzięki istniejącej ścieżce dla obiektów i tablic, pola formularza mogą być filtrowane i wyświetlane z odpowiednim błędem.",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "Często przydatnym przypadkiem jest także definiowanie wiadomości e-mail z ograniczeniem RegExp. Po zdefiniowaniu typu można go używać w dowolnym miejscu.",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "Można dodać dowolną liczbę ograniczeń.",
        "Constraint Types": "Typy ograniczeń",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "Walidacja przy użyciu niestandardowej funkcji walidatora. Więcej informacji można znaleźć w następnej sekcji Walidator niestandardowy.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Określa wyrażenie regularne jako wzorzec sprawdzania poprawności. Zazwyczaj używane do sprawdzania poprawności wiadomości e-mail lub bardziej złożonej walidacji zawartości.",
        "Alpha": "Alfa",
        "Validation for alpha characters (a-Z).": "Walidacja dla znaków alfa (a-Z).",
        "Alphanumeric": "Alfanumeryczne",
        "Validation for alpha and numeric characters.": "Walidacja dla znaków alfanumerycznych i numerycznych.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Walidacja dla znaków ASCII.",
        "Decimal&lt;number, number&gt;": "Liczba dziesiętna&lt;liczba, liczba&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Walidacja łańcucha reprezentującego liczbę dziesiętną, np. 0,1, .3, 1,1, 1,00003, 4,0 itd.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Sprawdzanie poprawności liczb, które są wielokrotnością podanej liczby.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinDługość&lt;liczba&gt;, MaxDługość&lt;liczba&gt;",
        "Validation for min/max length for arrays or strings.": "Walidacja minimalnej/maksymalnej długości tablic lub łańcuchów.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Obejmuje&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "Walidacja uwzględniania/wykluczania elementu tablicy lub podłańcucha",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimalna&lt;liczba&gt;, Maksymalna&lt;liczba&gt;;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Walidacja, czy wartość jest minimalną lub maksymalną podaną liczbą. Tak samo jak `>=` i `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "To samo co minimum/maksimum, ale nie obejmuje samej wartości. Tak samo jak `>` i `<`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Dodatni, Ujemny, DodatniNieZero, UjemnyNieZero.",
        "Validation for a value being positive or negative.": "Walidacja wartości dodatniej lub ujemnej.",
        "BeforeNow, AfterNow": "Przed teraz, Po teraz",
        "Validation for a date value compared to now (new Date)..": "Walidacja dla wartości daty w stosunku do teraz (nowa data)...",
        "Email": "E-mail:",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Prosta walidacja regexp wiadomości e-mail za pomocą `/^\\S+@\\S+$/`. Jest automatycznie `stringiem`, więc nie trzeba robić `string & Email`.",
        "integer": "liczba całkowita",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Sprawdza, czy podana liczba jest liczbą całkowitą w odpowiednim zakresie. Jest automatycznie `number`, więc nie trzeba robić `number & integer`.",
        "See Special types: integer/floats for more information": "Więcej informacji można znaleźć w części Typy specjalne: integer/floats.",
        "Benutzerdefinierte Validator": "Walidator niestandardowy",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "Jeśli wbudowane walidatory nie są wystarczające, można utworzyć własne funkcje walidacji i używać ich za pomocą dekoratora `Validate`.",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "Zwróć uwagę, że niestandardowa funkcja walidacji jest wykonywana po wywołaniu wszystkich wbudowanych walidatorów typów. Jeśli walidator zakończy się niepowodzeniem, wszystkie kolejne walidatory dla bieżącego typu są pomijane. W każdym typie może wystąpić tylko jedna awaria.",
        "Generic Validator": "Walidator ogólny",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "W funkcji walidatora dostępny jest obiekt Type, za pomocą którego można uzyskać więcej informacji o typie, który korzysta z walidatora. Istnieje także możliwość zdefiniowania dowolnej opcji walidatora, która musi być przekazana do typu walidacji, co czyni walidator konfigurowalnym. Dzięki tym informacjom i ich referencjom nadrzędnym można tworzyć potężne walidatory generyczne.",
        "Serialisation": "Serializacja",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "Serializacja to proces przekształcania typów danych w format odpowiedni np. do transportu lub przechowywania. Deserializacja to proces cofania tego procesu. Odbywa się to bezstratnie, tzn. dane mogą być konwertowane do i z obiektu serializacji bez utraty informacji o typie danych lub samych danych.",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "W języku JavaScript serializacja odbywa się zwykle między obiektami JavaScript i JSON. JSON obsługuje tylko łańcuchy, liczby, symbole booleańskie, obiekty i tablice. Z drugiej strony, JavaScript obsługuje wiele innych typów, takich jak BigInt, ArrayBuffer, tablice typowane, Date, instancje klas niestandardowych i wiele innych. Teraz, aby przesłać dane JavaScript do serwera przy użyciu JSON, potrzebny jest proces serializacji (na kliencie) i deserializacji (na serwerze) lub odwrotnie, jeśli serwer wysyła dane do klienta jako JSON. Użycie `JSON.parse` i `JSON.stringify` często nie jest wystarczające, ponieważ nie jest bezstratne.",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "Ten proces serializacji jest absolutnie konieczny w przypadku nietrywialnych danych, ponieważ JSON traci informacje nawet w przypadku podstawowych typów, takich jak data. Nowa data jest ostatecznie serializowana jako ciąg znaków w JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "Jak widać, wynikiem działania polecenia JSON.stringify jest łańcuch JSON. Po ponownej deserializacji za pomocą JSON.parse nie otrzymamy obiektu `date`, lecz ciąg znaków.",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "Chociaż istnieją różne obejścia pozwalające nauczyć JSON.parse deserializacji obiektów danych, są one podatne na błędy i nie działają dobrze. Aby umożliwić bezpieczną dla typu serializację i deserializację dla tego przypadku i wielu innych typów, konieczny jest proces serializacji.",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "Dostępne są cztery główne funkcje: `serialize`, `cast`/`deserialize` i `validatedDeserialize`. Pod maską tych funkcji domyślnie używany jest globalnie dostępny serializator JSON z `@deepkit/type`, ale można też użyć własnego celu serializacji.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type obsługuje niestandardowe cele serializacji, ale jest już wyposażony w wydajny cel serializacji JSON, który serializuje dane jako obiekty JSON, a następnie może być poprawnie i bezpiecznie przekonwertowany na JSON za pomocą JSON.stringify. Dzięki `@deepkit/bson`, BSON może być również używany jako cel serializacji. Jak utworzyć niestandardowy cel serializacji (na przykład dla sterownika bazy danych), można dowiedzieć się w sekcji <<serializacja-niestandardowy-serializator>>.",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Należy pamiętać, że mimo iż serializatory również sprawdzają dane pod kątem zgodności, walidacje te różnią się od walidacji opisanej w rozdziale <<walidacja>>. Tylko funkcja `cast` wywołuje również pełny proces walidacji z rozdziału <<validation>> po udanej deserializacji i wyrzuca błąd, jeśli dane nie są poprawne.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "Alternatywnie, do walidacji po deserializacji można użyć polecenia `validatedDeserialize`. Inną alternatywą jest ręczne wywołanie funkcji `validate` lub `validates` na zdeserializowanych danych z funkcji `deserialize`, zobacz rozdział <<walidacja>>.",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "Wszystkie funkcje z serializacji i walidacji rzucają `ValidationError` z `@deepkit/type` w przypadku błędów.",
        "Cast": "Odlew",
        "Todo": "Todo",
        "Deserialisierung": "Deserializacja",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "Funkcja `deserialize` domyślnie konwertuje przesyłane dane za pomocą serializatora JSON na odpowiednie, określone typy. Serializator JSON oczekuje obiektu JSON, tj. ciągu znaków, liczby, booleanu, obiektu lub tablicy. Zazwyczaj uzyskuje się go za pomocą wywołania JSON.parse.",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "Jeśli został już przekazany prawidłowy typ danych (na przykład obiekt Date w przypadku `created`), to jest on traktowany tak, jak jest.",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "Jako pierwszy argument typu można podać nie tylko klasę, ale także dowolny typ TypeScript. W ten sposób można również przekazywać prymitywy lub bardzo złożone typy:",
        "Weiche Typenkonvertierung": "Konwersja typu miękkiego",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "W procesie deserializacji wykonywana jest miękka konwersja typów. Oznacza to, że można zaakceptować i automatycznie przekonwertować ciąg znaków i liczbę na typ łańcuchowy lub liczbę na typ łańcuchowy. Jest to przydatne na przykład wtedy, gdy dane są przyjmowane za pośrednictwem adresu URL i przekazywane do deserializatora. Ponieważ adres URL jest zawsze ciągiem znaków, Deepkit Type nadal próbuje rozwiązać typy Number i Boolean.",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "W serializator JSON wbudowane są następujące konwersje typów miękkich:",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*: Number lub Bigint akceptują String, Number i BigInt. `parseFloat` lub `BigInt(x)` są używane w przypadku konieczności dokonania konwersji.",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*: Boolean akceptuje Number i String. 0, '0', 'false' jest interpretowane jako `false`. 1, '1', 'true' jest interpretowane jako `true`.",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*string*: String akceptuje opcje Number, String, Boolean i wiele innych. Wszystkie wartości nie będące łańcuchami są automatycznie konwertowane za pomocą `String(x)`.",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "Konwersję miękką można również wyłączyć:",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "W przypadku nieprawidłowych danych nie jest podejmowana próba ich konwersji, a zamiast tego wyświetlany jest komunikat o błędzie.",
        "Serialisierung": "Serializacja",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "Funkcja `serialize` domyślnie konwertuje przekazane dane za pomocą serializatora JSON na obiekt JSON, czyli: String, Number, Boolean, Object lub Array. Wynik tej operacji można następnie bezpiecznie przekształcić w JSON za pomocą JSON.stringify.",
        "Type-Decorators": "Typ-Dekoratory",
        "Integer": "Integer",
        "Mapped": "Mapowany",
        "Naming Strategy": "Strategia nazewnictwa",
        "Benutzerdefinierter Serializer": "Serializator niestandardowy",
        "Dependency Injection": "Wstrzykiwanie zależności",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "Wstrzykiwanie zależności (Dependency Injection, DI) to wzorzec projektowy, w którym klasy i funkcje _odbierają_ swoje zależności. Jest ona zgodna z zasadą odwrócenia kontroli (IoC) i pomaga lepiej rozdzielić złożony kod w celu znacznej poprawy testowalności, modularności i przejrzystości. Chociaż istnieją inne wzorce projektowe, takie jak wzorzec lokalizatora usług, które stosują zasadę IoC, DI stał się dominującym wzorcem, zwłaszcza w oprogramowaniu dla przedsiębiorstw.",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "Aby zilustrować zasadę działania IoC, podajemy przykład:",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "Klasa UserRepository ma zależność HttpClient. Ta zależność sama w sobie nie rzuca się w oczy, ale problematyczne jest to, że UserRepository samo tworzy HttpClienta. Jest to oczywiste na pierwszy rzut oka, ale ma swoje wady: Co zrobić, jeśli chcemy zastąpić klienta HttpClient? Co zrobić, jeśli chcemy przetestować UserRepository w teście jednostkowym, nie pozwalając na wysyłanie prawdziwych żądań HTTP? Skąd wiemy, że klasa w ogóle używa HttpClient?",
        "Inversion of Control": "Odwrócenie kontroli",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "W myśli Inversion of Control (IoC) jest następujący alternatywny wariant, który ustawia HttpClient jako jawną zależność w konstruktorze (znany również jako wstrzykiwanie konstruktora).",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "Teraz to już nie UserRepository jest odpowiedzialne za tworzenie HttpClient, lecz użytkownik UserRepository. Jest to odwrócenie kontroli (IoC). Sterowanie zostało odwrócone lub odwrócone. W szczególności kod ten wykorzystuje wstrzykiwanie zależności, ponieważ zależności są odbierane (wstrzykiwane), a nie tworzone lub żądane. Wstrzykiwanie zależności to tylko jeden z wariantów zastosowania IoC.",
        "Service Locator": "Lokalizator usług",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "Oprócz DI, sposobem na zastosowanie zasady IoC jest także Service Locator (SL). Jest to powszechnie uważane za odpowiednik wstrzykiwania zależności (Dependency Injection), ponieważ żąda ono zależności, a nie je otrzymuje. Gdyby w powyższym kodzie zażądać HttpClient w następujący sposób, można by mówić o wzorcu lokalizatora usług.",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "Funkcja `locator.getHttpClient` może mieć dowolną nazwę. Alternatywą mogą być, na przykład, wywołania funkcji takich jak `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` lub wywołanie kontenera takie jak `container.get(HttpClient)`. Import globalny jest nieco inną odmianą lokalizatora usług, w której jako lokalizatora używa się samego systemu modułów:",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "Wszystkie te warianty mają tę wspólną cechę, że jawnie żądają zależności HttpClient. Żądanie to może wystąpić nie tylko we właściwościach jako wartość domyślna, ale także gdzieś w środku kodu. Ponieważ w środku kodu oznacza to, że nie jest on częścią interfejsu typu, użycie HttpClient jest ukryte. W zależności od wariantu żądania HttpClient, zastąpienie go inną implementacją może być czasami bardzo trudne lub całkowicie niemożliwe. Szczególnie w obszarze testów jednostkowych i dla jasności, mogą pojawić się tu trudności, tak że lokalizator usług jest obecnie klasyfikowany jako anty-wzorzec w pewnych sytuacjach.",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "W przypadku metody Dependency Injection nic nie jest żądane, lecz jest jawnie dostarczane przez użytkownika lub odbierane przez kod. Jak widać na przykładzie Inversion of Control, wzorzec wstrzykiwania zależności został już tam zastosowany. W szczególności można tu zaobserwować wstrzykiwanie konstruktora, ponieważ zależność jest zadeklarowana w konstruktorze. Zatem UserRepository musi być teraz używane w następujący sposób.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "Kod, który chce używać UserRepository, musi także dostarczyć (wstrzyknąć) wszystkie jego zależności. O tym, czy HttpClient powinien być tworzony za każdym razem od nowa, czy też za każdym razem powinien być używany ten sam, decyduje teraz użytkownik klasy, a nie sama klasa. Nie jest już ona żądana (z punktu widzenia klasy), jak w przypadku lokalizatora usług, ani - w początkowym przykładzie - tworzona całkowicie przez samą klasę. Takie odwrócenie przepływu ma wiele zalet:",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "Kod jest łatwiejszy do zrozumienia, ponieważ wszystkie zależności są wyraźnie widoczne.",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "Kod jest łatwiejszy do testowania, ponieważ wszystkie zależności są jasne i w razie potrzeby można je łatwo zmienić.",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "Kod jest bardziej modularny, ponieważ zależności można łatwo wymieniać.",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "Promuje to zasadę separacji interesów, ponieważ UserRepository nie jest już odpowiedzialne za samodzielne tworzenie bardzo złożonych zależności w razie wątpliwości.",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "Jednak oczywistą wadę można dostrzec również bezpośrednio: Czy naprawdę muszę sam tworzyć lub zarządzać wszystkimi zależnościami, takimi jak HttpClient? Tak, istnieje wiele przypadków, w których samodzielne zarządzanie zależnościami jest całkowicie uzasadnione. Dobre API charakteryzuje się tym, że zależności nie wymykają się spod kontroli, a nawet wtedy są przyjemne w użyciu. Może się tak zdarzyć w przypadku wielu aplikacji lub złożonych bibliotek. Fasady znakomicie nadają się do udostępniania użytkownikowi w uproszczony sposób bardzo złożonego, niskopoziomowego interfejsu API z wieloma zależnościami.",
        "Dependency Injection Container": "Kontener wstrzykiwania zależności",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "W przypadku bardziej złożonych aplikacji nie jest jednak konieczne samodzielne zarządzanie wszystkimi zależnościami, ponieważ do tego właśnie służy tzw. kontener wstrzykiwania zależności (ang. dependency injection container). W ten sposób nie tylko automatycznie tworzone są wszystkie obiekty, ale także automatycznie \"wstrzykiwane\" są zależności, dzięki czemu nie jest już konieczne ręczne wywoływanie polecenia \"nowy\". Istnieją różne typy wstrzykiwania, takie jak wstrzykiwanie konstruktora, wstrzykiwanie metody lub wstrzykiwanie właściwości. Ułatwia to zarządzanie nawet skomplikowanymi konstrukcjami z wieloma zależnościami.",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "Kontener Dependency Injection (nazywany również kontenerem DI lub kontenerem IoC) jest dostarczany z Deepkitem w `@deepkit/injector` lub jest już zintegrowany poprzez moduły aplikacji we frameworku Deepkit. Powyższy kod wyglądałby tak, gdyby użyto niskopoziomowego API z pakietu `@deepkit/injector`.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "Obiektem `injector` jest w tym przypadku kontener wstrzykujący zależności. Zamiast używać \"new UserRepository\", kontener zwraca instancję UserRepository używając `get(UserRepository)`. Aby statycznie zainicjować kontener, do funkcji `InjectorContext.forProviders` przekazywana jest lista dostawców (w tym przypadku są to po prostu klasy).",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "Ponieważ DI polega na dostarczaniu zależności, zależności są dostarczane do kontenera, stąd termin techniczny \"dostawca\". Istnieją różne typy dostawców: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Wszystkie te elementy razem pozwalają na odwzorowanie bardzo elastycznych architektur za pomocą kontenera DI.",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "Wszystkie zależności między dostawcami są automatycznie rozwiązywane i gdy tylko pojawi się wywołanie `injector.get()`, obiekty i zależności są tworzone, buforowane i poprawnie przekazywane jako argument konstruktora (wstrzyknięcie konstruktora), ustawiane jako właściwość (wstrzyknięcie właściwości) lub przekazywane do wywołania metody (wstrzyknięcie metody).",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "Aby zamienić HttpClient na inny, można zdefiniować dla HttpClient innego dostawcę (tutaj ValueProvider):",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "Gdy tylko UserRepository zostanie zażądane przez `injector.get(UserRepository)`, otrzymuje obiekt AnotherHttpClient. Alternatywnie można tutaj również użyć ClassProvider, dzięki czemu wszystkie zależności AnotherHttpClient będą również zarządzane przez kontener DI.",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "Wszystkie typy dostawców są wymienione i wyjaśnione w sekcji <<dependency-injection-providers>>.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "Należy tutaj wspomnieć, że kontener DI firmy Deepkit działa tylko z typami runtime firmy Deepkit. Oznacza to, że każdy kod zawierający klasy, typy, interfejsy i funkcje musi zostać skompilowany przez Deepkit Type Compiler, aby informacje o typach były dostępne w czasie wykonywania. Więcej informacji na ten temat można znaleźć w rozdziale <<runtime-types>>.",
        "Dependency Inversion": "Inwersja zależności",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "Przykład UserRepository z Inversion of Control pokazuje, że UserRepository zależy od niższego poziomu, a mianowicie od biblioteki HTTP. Ponadto jako zależność deklaruje się konkretną implementację (klasę), a nie abstrakcję (interfejs). Na pierwszy rzut oka może się wydawać, że odpowiada to paradygmatom obiektowym, ale może to prowadzić do problemów, zwłaszcza w przypadku złożonych i dużych architektur.",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "Alternatywnym wariantem byłoby przeniesienie zależności od HttpClient do abstrakcji (interfejsu) i tym samym nie importowanie kodu z biblioteki HTTP do UserRepository.",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "Jest to tzw. zasada inwersji zależności. UserRepository nie jest już bezpośrednio zależne od biblioteki HTTP, a zamiast tego opiera się na abstrakcji (interfejsie). Rozwiązuje w ten sposób dwa podstawowe cele tej zasady:",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "Moduły wysokopoziomowe nie powinny importować niczego z modułów niskopoziomowych.",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "Implementacje powinny być oparte na abstrakcjach (interfejsach).",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "Połączenie obu implementacji (UserRepository z biblioteką HTTP) może być teraz wykonane za pomocą kontenera DI Container.",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "Ponieważ kontener DI firmy Deepkit potrafi rozwiązywać abstrakcyjne zależności (interfejsy), takie jak HttpClientInterface, UserRepository automatycznie otrzymuje implementację HttpClient, ponieważ HttpClient zaimplementował interfejs HttpClientInterface. Można to zrobić albo przez HttpClient specjalnie implementując interfejs HttpClientInterface (`class HttpClient implements HttpClientInterface`), albo przez API HttpClienta, które jest po prostu zgodne z interfejsem HttpClientInterface.",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "Gdy tylko HttpClient zmieni swoje API (na przykład usunie metodę `get`) i tym samym nie będzie już kompatybilny z HttpClientInterface, kontener DI wyrzuci błąd (\"zależność HttpClientInterface nie została dostarczona\").",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "W tym przypadku użytkownik, który chce połączyć obie implementacje, jest zobowiązany do znalezienia rozwiązania. Na przykład można tu zarejestrować klasę adaptera, która implementuje interfejs HttpClientInterface i poprawnie przekazuje wywołania metod do HttpClient.",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "Należy zauważyć, że chociaż w teorii zasada odwrócenia zależności ma swoje zalety, w praktyce ma też istotne wady. Prowadzi to nie tylko do zwiększenia ilości kodu (ponieważ trzeba napisać więcej interfejsów), ale także do większej złożoności (ponieważ każda implementacja ma teraz interfejs dla każdej zależności). Ta cena jest opłacalna dopiero wtedy, gdy aplikacja osiągnie pewien rozmiar i potrzebna jest elastyczność. Jak każdy wzorzec projektowy i zasada, także ta ma swój współczynnik kosztu do użycia, który należy przemyśleć przed jej zastosowaniem.",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "Wzorce projektowe nie powinny być stosowane na ślepo i powszechnie nawet w najprostszym kodzie. Jeśli jednak spełnione są warunki wstępne, takie jak złożona architektura, duże aplikacje lub skalowalny zespół, odwracanie zależności i inne wzorce projektowe dopiero wtedy ujawniają swoją prawdziwą siłę.",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Ponieważ Dependency Injection w Deepkit opiera się na typach Runtime, konieczne jest, aby `@deepkit/type` był już poprawnie zainstalowany.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Jeśli to się powiedzie, `@deepkit/injector` może zostać zainstalowany sam lub framework Deepkit, który już używa biblioteki pod maską.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Po zainstalowaniu biblioteki można bezpośrednio korzystać z jej interfejsu API.",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "Aby użyć teraz metody Dependency Injection, można skorzystać z trzech możliwości.",
        "Injector API (Low Level)": "API wtryskiwacza (poziom niski)",
        "Module API": "Interfejs API modułu",
        "App API (Deepkit Framework)": "Interfejs API aplikacji (struktura Deepkit)",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "Jeśli `@deepkit/injector` ma być używany bez Deepkit Framework, zalecane są dwa pierwsze warianty.",
        "Injector API": "API wtryskiwacza",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "Interfejs API Injector został już przedstawiony we wprowadzeniu do Wstrzykiwania zależności. Charakteryzuje się bardzo prostą obsługą za pomocą pojedynczej klasy `InjectorContext`, która tworzy pojedynczy kontener DI i jest szczególnie przydatna w prostszych aplikacjach bez modułów.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "W tym przypadku obiekt `injector` jest kontenerem wstrzykiwania zależności. Funkcja `InjectorContext.forProviders` pobiera tablicę dostawców. Zobacz sekcję <<dependency-injection-providers>>, aby dowiedzieć się, jakie wartości można przekazywać.",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "Nieco bardziej złożonym interfejsem API jest klasa `InjectorModule`, która umożliwia przechowywanie dostawców w różnych modułach w celu utworzenia wielu zamkniętych kontenerów DI na moduł. Umożliwia to również stosowanie klas konfiguracyjnych dla poszczególnych modułów, co ułatwia automatyczne dostarczanie sprawdzonych wartości konfiguracyjnych do dostawców. Moduły mogą się wzajemnie importować i eksportować dostawców, tworząc hierarchię i ładnie odseparowaną architekturę.",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "Tego interfejsu API należy używać, jeśli aplikacja jest bardziej złożona i nie jest wykorzystywany framework Deepkit.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "Obiektem `injector` jest w tym przypadku kontener wstrzykujący zależności. Dostawców można podzielić na różne moduły, a następnie zaimportować w różnych miejscach za pomocą importu modułów. W ten sposób powstaje naturalna hierarchia, która odzwierciedla hierarchię aplikacji lub architektury.",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "Moduł InjectorContext powinien być zawsze przypisany do najwyższego modułu w hierarchii, zwanego również modułem głównym lub modułem aplikacji. InjectorContext ma wtedy tylko zadanie pośredniczące: wywołania funkcji `injector.get()` są po prostu przekazywane do modułu głównego. Dostawców można jednak uzyskać także z modułów niebędących modułami root, przekazując moduł jako drugi argument.",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "Wszystkie moduły niebędące modułami root są domyślnie hermetyzowane, dzięki czemu wszyscy dostawcy w tym module są dostępni tylko dla niego samego. Jeżeli provider ma być dostępny także dla innych modułów, musi zostać wyeksportowany. Dzięki eksportowi dostawca zostaje przeniesiony do modułu nadrzędnego w hierarchii i może być używany.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "Aby domyślnie wyeksportować wszystkich dostawców do najwyższego poziomu, czyli modułu głównego, można użyć opcji `forRoot`. Dzięki temu wszyscy dostawcy mogą być wykorzystywani przez wszystkie inne moduły.",
        "App API": "API aplikacji",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Po użyciu frameworka Deepkit moduły definiuje się za pomocą interfejsu API `@deepkit/app`. Jest on oparty na interfejsie API modułu, więc dostępne są także jego możliwości. Ponadto możliwe jest korzystanie z zaawansowanych haków i definiowanie mechanizmów ładowania konfiguracji w celu odwzorowania jeszcze bardziej dynamicznych architektur.",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "W rozdziale <<framework-modules>> opisano to bardziej szczegółowo.",
        "Providers": "Dostawcy",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "Istnieje kilka sposobów dostarczania zależności w kontenerze Dependency Injection. Najprostszym wariantem jest po prostu określenie klasy. Jest to również tzw. krótki ClassProvider.",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "Jest to specjalny dostawca, ponieważ określona jest tylko klasa. Wszyscy inni dostawcy muszą być określeni jako literały obiektów.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "Domyślnie wszyscy dostawcy są oznaczeni jako singleletons, czyli w danym momencie istnieje tylko jedna instancja. Aby utworzyć nową instancję za każdym razem, gdy jest ona przekazywana, można użyć opcji `transient`. Spowoduje to, że za każdym razem będą tworzone klasy lub będą wykonywane fabryki.",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "Oprócz krótkiego ClassProvider istnieje również zwykły ClassProvider, który jest literałem obiektu, a nie klasą.",
        "Dies ist Äquivalent zu diesen beiden:": "Jest to równoważne z tymi dwoma:",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "Można go użyć do wymiany dostawcy z inną klasą.",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "W tym przykładzie klasa `OtherUserRepository` jest teraz również zarządzana w kontenerze DI, a wszystkie jej zależności są automatycznie rozwiązywane.",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "W przypadku tego dostawcy można podać wartości statyczne.",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "Ponieważ nie tylko instancje klas mogą być przekazywane jako zależności, jako `useValue` można podać dowolną wartość. Jako token dostawcy można również użyć symbolu lub elementu pierwotnego (ciąg znaków, liczba, boolean).",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "Tokeny dostawcy prymitywnego muszą być zadeklarowane z typem wtrysku jako zależnością.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "Dzięki połączeniu aliasu inject i prymitywnych tokenów dostawcy, zależności mogą być również dostarczane z pakietów, które nie zawierają informacji o typie runtime.",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "Następnie należy je zadeklarować po stronie użytkownika w następujący sposób:",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "Można zdefiniować przekierowanie do już zdefiniowanego dostawcy.",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "Funkcji można użyć do podania wartości dla dostawcy. Funkcja ta może również zawierać parametry, które z kolei są przekazywane przez kontener DI. W ten sposób można uzyskać dostęp do innych zależności lub opcji konfiguracyjnych.",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "Oprócz klas i prymitywów można również udostępniać abstrakcje (interfejsy). Odbywa się to za pomocą funkcji `provide` i jest szczególnie przydatne, gdy przekazywana wartość nie zawiera żadnych informacji o typie.",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "Jeśli kilku dostawców zaimplementowało interfejs Połączenie, używany jest ostatni dostawca.",
        "Als Argument für provide() sind alle anderen Provider möglich.": "Wszystkie inne providery są możliwe jako argumenty funkcji provide().",
        "Constructor/Property Injection": "Wstrzykiwanie konstruktora/właściwości",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "W większości przypadków stosuje się wstrzykiwanie konstruktora. Wszystkie zależności są określane jako argumenty konstruktora i są automatycznie wstrzykiwane przez kontener DI.",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "Zależności opcjonalne powinny być oznaczone jako takie, w przeciwnym razie może zostać wywołany błąd, jeśli nie zostanie znaleziony żaden dostawca.",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "Alternatywą dla wstrzykiwania konstruktora jest wstrzykiwanie właściwości. Jest to zwykle stosowane, gdy zależność jest opcjonalna lub konstruktor jest z innych powodów zbyt pełny. Właściwości są przypisywane automatycznie, gdy tylko instancja zostanie utworzona (a więc gdy zostanie wykonany konstruktor).",
        "Konfiguration": "Konfiguracja",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "Kontener Dependency Injection umożliwia także wstrzykiwanie opcji konfiguracyjnych. Taki zastrzyk konfiguracji można otrzymać poprzez wstrzyknięcie konstruktora lub właściwości.",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "Interfejs API modułu obsługuje definicję konfiguracji, która jest zwykłą klasą. Dzięki wyposażeniu takiej klasy we właściwości każda z nich pełni rolę opcji konfiguracyjnej. Ze względu na sposób definiowania klas w języku TypeScript, pozwala to na określenie typu i wartości domyślnych dla każdej właściwości.",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "Opcje konfiguracyjne `domain` i `debug` mogą być teraz wygodnie używane w bezpiecznych typach dostawców.",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "Wartości samych opcji można ustawić za pomocą funkcji `configure()`.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Opcje, które nie mają wartości domyślnej, a mimo to są niezbędne, można podać za pomocą znaku `!`. Zmusza to użytkownika modułu do podania wartości, w przeciwnym razie zostanie wyświetlony błąd.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Ponadto, wszystkie typy serializacji i walidacji z poprzednich rozdziałów <<walidacja>> i <<serializacja>> mogą być użyte do bardzo szczegółowego określenia ograniczeń typu i zawartości, jakie musi mieć opcja.",
        "Injection": "Wtrysk",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "Opcje konfiguracyjne, podobnie jak inne zależności, mogą być bezpiecznie i łatwo wstrzykiwane przez kontener DI, jak pokazano wcześniej. Najprostszą metodą jest odwołanie się do pojedynczej opcji za pomocą operatora dostępu do indeksu:",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "Do opcji konfiguracyjnych można odwoływać się nie tylko pojedynczo, ale także grupowo. Do tego celu służy typ użytkowy TypeScript `Partial`:",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "Aby uzyskać wszystkie opcje konfiguracyjne, można również bezpośrednio odwołać się do klasy konfiguracji:",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "Zaleca się jednak, aby odwoływać się tylko do tych opcji konfiguracyjnych, które są rzeczywiście używane. Nie tylko upraszcza to testy jednostkowe, ale także ułatwia sprawdzenie, co jest rzeczywiście potrzebne w kodzie.",
        "Scopes": "Lunety",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "Domyślnie wszystkie providery kontenera DI są singletonami i dlatego są instancjonowane tylko raz. Oznacza to, że w przykładzie UserRepository zawsze istnieje tylko jedna instancja UserRepository podczas całego czasu działania. W żadnym momencie nie jest tworzona druga instancja, chyba że użytkownik zrobi to ręcznie, używając słowa kluczowego \"new\".",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "Istnieją jednak różne przypadki użycia, w których dostawca powinien być tworzony tylko przez krótki czas lub tylko podczas określonego zdarzenia. Takim zdarzeniem może być na przykład żądanie HTTP lub wywołanie RPC. Oznaczałoby to, że za każdym razem, gdy wystąpi zdarzenie, tworzona jest nowa instancja, a gdy ta instancja nie jest już używana, jest automatycznie usuwana (przez garbage collector).",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "Żądanie HTTP jest klasycznym przykładem zakresu. Na przykład do tego zakresu można zarejestrować dostawców takich jak sesja, obiekt użytkownika lub innych dostawców związanych z żądaniami. Aby utworzyć zakres, wystarczy wybrać dowolną nazwę zakresu, a następnie określić go za pomocą dostawców.",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "Gdy tylko zostanie określony zakres, nie można już uzyskać tego dostawcy bezpośrednio przez kontener DI, więc poniższe wywołanie kończy się niepowodzeniem:",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "Zamiast tego należy utworzyć kontener DI o określonym zakresie. Będzie się to działo za każdym razem, gdy nadejdzie żądanie HTTP:",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "Do tego kontenera DI można teraz zgłaszać żądania od dostawców, którzy również są zarejestrowani w tym zakresie, a także od wszystkich dostawców, którzy nie zdefiniowali zakresu.",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "Ponieważ wszystkie providery są domyślnie singletonami, każde wywołanie `get(UserSession)` zawsze zwróci tę samą instancję dla kontenera scoped. Jeśli zostanie utworzonych kilka kontenerów tematycznych, zostanie również utworzonych kilka sesji UserSessions.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "Aplikacje działające z Deepkit Framework mają domyślnie zakresy `http`, `rpc` i `cli`. Zobacz rozdział <<cli>>, <<http>> lub <<rpc>>.",
        "Setup Calls": "Konfiguracja połączeń",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "Wywołania konfiguracji umożliwiają manipulowanie wynikiem działania dostawcy. Jest to przydatne na przykład do stosowania innego wariantu wstrzykiwania zależności - wstrzykiwania metod.",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "Wywołań konfiguracyjnych można używać tylko z interfejsem API modułu lub interfejsem API aplikacji i są one rejestrowane powyżej modułu.",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "Metoda `setupProvider` zwraca obiekt proxy UserRepository, na którym mogą być wywoływane jego metody. Należy zauważyć, że te wywołania metod są jedynie umieszczane w kolejce i nie są w tym momencie wykonywane. W związku z tym nie jest zwracana żadna wartość zwrotna.",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "Oprócz wywoływania metod można również ustawiać właściwości.",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "To zadanie jest również po prostu umieszczane w kolejce.",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "Wywołania lub zadania w kolejce są następnie wykonywane na rzeczywistym wyniku dostawcy, gdy tylko zostanie on utworzony. Oznacza to, że w przypadku ClassProvider są one stosowane do instancji klasy zaraz po jej utworzeniu, w przypadku FactoryProvider - do wyniku działania fabryki, a w przypadku ValueProvider - do dostawcy.",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "Aby odwoływać się nie tylko do wartości statycznych, ale także do innych dostawców, można użyć funkcji `injectorReference`. Zwraca to referencję do dostawcy, który jest również żądany przez kontener DI podczas wykonywania poleceń konfiguracji.",
        "*Abstractions/Interfaces*": "*Abstrakcje/Interfejsy*.",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Wywołania konfiguracji można również przypisać do interfejsu.",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Programy z interfejsem wiersza poleceń (CLI) to programy, które komunikują się z użytkownikiem za pośrednictwem terminala w postaci tekstu wprowadzanego i wyprowadzanego. Zaletą interakcji z aplikacją w tym wariancie jest to, że potrzebny jest tylko terminal - lokalny lub przez połączenie SSH.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Aplikacja CLI w Deepkit ma pełny dostęp do kontenera DI, a zatem może uzyskać dostęp do wszystkich dostawców i opcji konfiguracyjnych.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "Argumenty i opcje aplikacji CLI są kontrolowane przez parametry metod za pomocą typów TypeScript i są automatycznie serializowane i walidowane.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI jest jednym z trzech punktów wejścia do aplikacji Deepkit Framework. W Deepkit Framework aplikacja jest zawsze uruchamiana za pomocą programu CLI, który sam jest napisany w języku TypeScript przez użytkownika. Nie istnieje zatem globalne narzędzie CLI do uruchamiania aplikacji Deepkit, specyficzne dla programu Deepkit. W ten sposób uruchamia się serwer HTTP/RPC, wykonuje migracje lub uruchamia własne polecenia. Wszystko to odbywa się za pośrednictwem tego samego punktu wejścia, tego samego pliku. Po użyciu frameworka Deepkit poprzez zaimportowanie `FrameworkModule` z `@deepkit/framework`, aplikacja otrzymuje dodatkowe polecenia dla serwera aplikacji, migracji i innych.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "Szkielet CLI umożliwia łatwe rejestrowanie własnych poleceń i jest oparty na prostych klasach. W rzeczywistości jest on oparty na `@deepkit/app`, małym pakiecie, który jest przeznaczony tylko do tego celu i może być również używany niezależnie bez frameworka Deepkit. W tym pakiecie znajdują się dekoratory, które są potrzebne do dekorowania klasy kontrolera CLI.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "Kontrolery są zarządzane lub inicjowane przez kontener Dependency Injection i dlatego mogą korzystać z innych dostawców. Więcej informacji na ten temat znajduje się w rozdziale <<wstrzykiwanie zależności>>.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Ponieważ programy CLI w Deepkit bazują na typach runtime, konieczne jest, aby @deepkit/type był już poprawnie zainstalowany. Zobacz <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Jeśli to się uda, można zainstalować @deepkit/app lub framework Deepkit, który już używa biblioteki pod maską.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Zwróć uwagę, że `@deepkit/app` jest oparty na dekoratorach TypeScript i ta właściwość musi być odpowiednio aktywowana za pomocą `experimentalDecorators`.",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "Aby utworzyć polecenie dla aplikacji, należy utworzyć kontroler CLI. Jest to prosta klasa, która posiada metodę `exeecute` i jest wyposażona w informacje o poleceniu.",
        "_Datei: app.ts_": "_Plik: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "W dekoratorze `@cli.controller` jako pierwszy argument zdefiniowana jest unikalna nazwa aplikacji CLI. W obiekcie na drugiej pozycji można opcjonalnie dodać dalsze opcje, takie jak opis.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "Ten kod jest już kompletną aplikacją CLI i może być uruchomiony w ten sposób:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "Widać, że dostępne jest polecenie \"test\". Aby wykonać tę operację, należy przekazać nazwę jako argument:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "Możliwe jest również uczynienie pliku wykonywalnym za pomocą `chmod +x app.ts`, tak aby do jego uruchomienia wystarczyło polecenie `./app.ts`. Należy zauważyć, że tzw.",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang jest niezbędny. Shebang oznacza kombinację znaków `#!` na początku programu skryptowego. W powyższym przykładzie jest to już obecne: `&#35;!/usr/bin/env ts-node-script` i używa trybu skryptowego `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "W ten sposób można utworzyć i zarejestrować dowolną liczbę poleceń. Unikalna nazwa podana w `@cli.controller` powinna być dobrze dobrana i umożliwiać grupowanie poleceń za pomocą znaku `:` (np. `user:create`, `user:remove`, itd.).",
        "Argumente": "Argumenty",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "Aby dodać argumenty, nowe parametry są dodawane do metody `execute` i dekorowane dekoratorem `@arg`.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "Jeśli teraz wykonasz to polecenie bez podania nazwy, zostanie wyświetlony błąd:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "Użycie `--help` pozwoli uzyskać więcej informacji o wymaganych argumentach:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Gdy tylko nazwa zostanie przekazana jako argument, metoda `execute` w TestCommand zostanie wykonana, a nazwa zostanie przekazana poprawnie.",
        "Flags": "Flagi",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flagi to kolejny sposób przekazywania wartości do polecenia. W większości przypadków są one opcjonalne, ale nie muszą być. Parametry ozdobione `@flag nazwa` mogą być przekazywane przez `--nazwa wartość` lub `--nazwa=wartość`.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "W widoku pomocy można teraz zobaczyć w \"OPCJACH\", że konieczna jest flaga `--id`. Jeśli zostanie to wprowadzone poprawnie, polecenie otrzyma tę wartość.",
        "Boolean Flags": "Boolean Flagi",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flagi mają tę zaletę, że można ich także używać jako bezwartościowych flag, na przykład w celu aktywowania określonego zachowania. Gdy tylko parametr zostanie oznaczony jako opcjonalny Boolean, zachowanie to zostanie uaktywnione.",
        "Multiple Flags": "Wiele flag",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "Aby przekazać kilka wartości do tej samej flagi, można ją oznaczyć jako tablicę.",
        "Single Character Flags": "Flagi jednoznakowe",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "Aby umożliwić przekazanie flagi również jako pojedynczego znaku, można użyć `@flag.char('x')`.",
        "Optional / Default": "Opcjonalne / Domyślne",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "Sygnatura metody `execute` określa, które argumenty lub flagi są opcjonalne. Jeśli parametr jest oznaczony jako opcjonalny, nie trzeba go podawać.",
        "Dasselbe für Parameter mit einem Default-Wert:": "To samo dotyczy parametrów z wartością domyślną:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "W ten sam sposób dotyczy to również flag.",
        "Serialization / Validation": "Serializacja / walidacja",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "Wszystkie argumenty i flagi są automatycznie deserializowane na podstawie ich typów, walidowane i mogą być opatrzone dodatkowymi ograniczeniami.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "W ten sposób argumenty zdefiniowane jako liczby mają zawsze gwarancję, że będą liczbami rzeczywistymi w sterowniku, nawet jeśli interfejs wiersza poleceń jest oparty na tekście, a więc na łańcuchach. Konwersja odbywa się automatycznie dzięki funkcji <<serializacja-luźna-konwersja>>.",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Dodatkowe ograniczenia można zdefiniować za pomocą dekoratorów typów z `@deepkit/type`.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "Typ `Postive` w `id` wskazuje, że poszukiwane są tylko liczby dodatnie. Jeśli użytkownik wprowadzi liczbę ujemną, kod w `execute` nie zostanie wykonany i zostanie wyświetlony komunikat o błędzie.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "Jeśli liczba ta jest dodatnia, polecenie działa tak jak poprzednio. To dodatkowe sprawdzanie poprawności, które jest bardzo łatwe do przeprowadzenia, sprawia, że polecenie jest znacznie bardziej odporne na błędne wpisy. Więcej informacji na ten temat można znaleźć w rozdziale <<walidacja>>.",
        "Description": "Opis",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "Aby opisać flagę lub argument, można użyć `@flag.description` lub `@arg.description`.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "W widoku pomocy opis ten jest wyświetlany za flagą lub argumentem:",
        "Exit code": "Kod wyjścia",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "Domyślnym kodem wyjścia jest 0, co oznacza, że polecenie zostało wykonane pomyślnie. Aby zmienić kod wyjścia, w metodzie `exucute` należy zwrócić liczbę inną niż 0.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "Klasa polecenia jest zarządzana przez DI Container, dzięki czemu można zdefiniować zależności, które są rozwiązywane za pośrednictwem DI Container.",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "Przetwarzanie żądań HTTP jest jednym z najbardziej znanych zadań serwera. Przekształca on dane wejściowe (żądanie HTTP) w dane wyjściowe (odpowiedź HTTP) i wykonuje określone zadanie. Klient może na różne sposoby wysyłać do serwera dane za pomocą żądania HTTP, które muszą zostać odczytane i poprawnie obsłużone. Oprócz treści HTTP możliwe są również wartości zapytania HTTP lub nagłówka HTTP. To, w jaki sposób dane są faktycznie przetwarzane, zależy od serwera. To serwer określa, gdzie i w jaki sposób wartości mają być wysyłane przez klienta.",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "Priorytetem jest nie tylko prawidłowe wykonanie tego, czego oczekuje użytkownik, ale także prawidłowa konwersja (deserializacja) i walidacja danych wejściowych z żądania HTTP.",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "Rurociąg, przez który przechodzi żądanie HTTP na serwerze, może być różnorodny i złożony. Wiele prostych bibliotek HTTP przekazuje jedynie żądanie HTTP i odpowiedź HTTP dla określonej trasy i oczekuje od programisty bezpośredniego przetworzenia odpowiedzi HTTP. Interfejs API oprogramowania pośredniczącego umożliwia dowolne rozszerzanie rurociągu.",
        "_Express Beispiel_": "_przykład ekspresowy_.",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "Jest to bardzo dobre rozwiązanie dla prostych przypadków użycia, ale szybko staje się mylące, gdy aplikacja się rozrasta, ponieważ wszystkie dane wejściowe i wyjściowe muszą być serializowane lub deserializowane i walidowane ręcznie. Należy także zastanowić się, w jaki sposób obiekty i usługi, takie jak abstrakcja bazy danych, mogą być uzyskiwane z samej aplikacji. Zmusza to programistę do umieszczenia na wierzchu architektury, która odwzorowuje te obowiązkowe funkcje.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Biblioteka HTTP firmy Deepkit wykorzystuje możliwości języka TypeScript i wstrzykiwania zależności (Dependency Injection). Serializacja/deserializacja oraz sprawdzanie poprawności wszelkich wartości odbywa się automatycznie na podstawie zdefiniowanych typów. Umożliwia także definiowanie tras za pomocą funkcjonalnego interfejsu API, jak w powyższym przykładzie, lub za pomocą klas kontrolerów w celu zaspokojenia różnych potrzeb danej architektury.",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "Można go używać zarówno z istniejącym serwerem HTTP, takim jak moduł `http` Node'a, jak i z frameworkiem Deepkit. Oba warianty API mają dostęp do kontenera wstrzykiwania zależności, dzięki czemu mogą wygodnie pobierać z aplikacji takie obiekty, jak abstrakcja bazy danych i konfiguracje.",
        "_Deepkit Beispiel_": "_Przykład zestawu głębokiego_.",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "Zwróć uwagę, że `@deepkit/http` dla API kontrolera jest oparty na dekoratorach TypeScript i ta właściwość musi być odpowiednio aktywowana za pomocą `experimentalDecorators`, gdy tylko API kontrolera jest używane.",
        "Funktionale API": "Funkcjonalny interfejs API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "Funkcjonalny interfejs API jest oparty na funkcjach i można go zarejestrować za pomocą rejestru routera, który można uzyskać za pośrednictwem kontenera DI aplikacji.",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "Rejestr routerów można także uzyskać w Event Listener lub w bootstrapie, dzięki czemu można rejestrować różne trasy na podstawie modułów, konfiguracji i innych dostawców.",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "Po zastosowaniu modułów trasy funkcjonalne mogą być również dynamicznie udostępniane przez moduły.",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "Więcej informacji o modułach aplikacji można znaleźć w rozdziale <<framework-modules>>.",
        "Controller API": "API sterownika",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "API kontrolerów jest oparte na klasach i można je zarejestrować za pomocą App-API w opcji `controllers`.",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "Po zastosowaniu modułów, sterowniki mogą być również dostarczane przez moduły.",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "Aby dostarczać kontrolery dynamicznie (na przykład w zależności od opcji konfiguracyjnej), można użyć haka `process`.",
        "HTTP Server": "Serwer HTTP",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "Jeśli używany jest Deepkit Framework, serwer HTTP jest już wbudowany. Biblioteki HTTP można jednak używać także z własnym serwerem HTTP bez korzystania z frameworka Deepkit.",
        "HTTP Client": "Klient HTTP",
        "todo: fetch API, validation, und cast.": "todo: pobieranie API, sprawdzanie poprawności i rzutowanie.",
        "Route Names": "Nazwy tras",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Trasom można nadać unikatową nazwę, do której można się odwoływać podczas przekierowania. W zależności od interfejsu API sposób definiowania nazwy jest różny.",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "Dla wszystkich tras z nazwą, adres URL może być żądany przez `Router.resolveUrl()`.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "Funkcje routera, a także klasy kontrolerów i metody kontrolerów mogą definiować dowolne zależności, które są rozwiązywane przez kontener wstrzykiwania zależności. Umożliwia to na przykład wygodny dostęp do abstrakcji bazy danych lub rejestratora.",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "Na przykład, jeśli baza danych została udostępniona jako dostawca, można ją wstrzyknąć:",
        "_Funktionaler API:_": "Funkcjonalne API:_.",
        "_Controller API:_": "API kontrolera:_",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "Więcej informacji na ten temat znajduje się w rozdziale <<wstrzykiwanie zależności>>.",
        "Input": "Wejście",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "Wszystkie poniższe warianty wejść działają w ten sam sposób zarówno w interfejsie API funkcji, jak i kontrolera. Umożliwiają one odczytywanie danych z żądania HTTP w sposób bezpieczny dla typu i niezwiązany z innymi elementami.",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "Prowadzi to nie tylko do znacznego zwiększenia bezpieczeństwa, ale także do uproszczenia testów jednostkowych,",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "ponieważ, ściśle rzecz biorąc, obiekt żądania HTTP nie musi nawet istnieć, aby można było przetestować trasę.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "Wszystkie parametry są automatycznie konwertowane (deserializowane) na zdefiniowane typy TypeScript i walidowane. Odbywa się to za pomocą pakietu `@deepkit/type` i jego funkcji <<serializacji>> i <<walidacji>>.",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "Dla uproszczenia poniżej przedstawiono wszystkie przykłady z funkcjonalnym interfejsem API.",
        "Path Parameters": "Parametry ścieżki",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "Parametry ścieżki to wartości, które są pobierane z adresu URL trasy. Typ wartości zależy od typu odpowiadającego jej parametru funkcji lub metody.",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "Konwersja jest wykonywana automatycznie za pomocą funkcji <<serializacja-luźna-konwersja>>.",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "Jeśli parametr ścieżki zostanie zdefiniowany jako typ inny niż łańcuch, zostanie on poprawnie przekonwertowany.",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "Do typów można także stosować dodatkowe ograniczenia walidacji.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "Można stosować wszystkie typy walidacji z `@deepkit/type`. Więcej na ten temat można znaleźć w rozdziale <<http-validation>>.",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "Domyślnie parametry Ścieżki mają ustawione `[^/]+` jako wyrażenie regularne do dopasowywania adresów URL. RegExp do tego celu można dostosować w następujący sposób:",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "Jest to konieczne tylko w wyjątkowych przypadkach, ponieważ często typy w połączeniu z typami walidacji już same w sobie prawidłowo ograniczają możliwe wartości.",
        "Query Parameters": "Parametry zapytań",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "Parametry zapytania są wartościami z adresu URL za znakiem `?` i mogą być odczytywane za pomocą typu `HttpQuery<T>`. Nazwa parametru odpowiada nazwie parametru zapytania.",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "Parametry zapytań są również automatycznie deserializowane i walidowane.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "Można stosować wszystkie typy walidacji z `@deepkit/type`. Więcej na ten temat można znaleźć w rozdziale <<http-validation>>.",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*Ostrzeżenie*: Wartości parametrów nie podlegają ucieczce ani sanityzacji. Zwracanie ich bezpośrednio w postaci ciągu znaków w trasie jako HTML powoduje powstanie luki w zabezpieczeniach (XSS). Należy dopilnować, aby nie ufano zewnętrznym danym wejściowym i w razie potrzeby filtrować/oczyszczać/konwertować dane.",
        "Query Model": "Model zapytania",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "Przy dużej liczbie parametrów zapytania może to szybko stać się mylące. Aby przywrócić porządek, można użyć modelu (klasy lub interfejsu), który łączy wszystkie możliwe parametry zapytania.",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "Właściwości w określonym modelu mogą zawierać wszystkie typy TypeScript i typy walidacji, które obsługuje `@deepkit/type`. Zobacz rozdziały <<serializacja>> i <<walidacja>>.",
        "Body": "Ciało",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "W przypadku metod HTTP, które dopuszczają ciało HTTP, można również określić model ciała.",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "Typ zawartości ciała żądania HTTP musi być `application/x-www-form-urlencoded`, `multipart/form-data` lub `application/json`, aby Deepkit mógł automatycznie przekonwertować to na obiekty JavaScript.",
        "Header": "Nagłówek",
        "Stream": "Strumień",
        "Manual Validation Handling": "Ręczna obsługa walidacji",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "Aby ręcznie przejąć sprawdzanie poprawności modelu ciała, można użyć specjalnego typu `HttpBodyValidation<T>`. Umożliwia on odbieranie nieprawidłowych danych ciała i reagowanie na komunikaty o błędach.",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "Gdy tylko `valid()` zwraca wartość `false`, wartości w określonym modelu mogą być w błędnym stanie. Oznacza to, że walidacja nie powiodła się. Jeśli `HttpBodyValidation` nie zostanie użyty i zostanie odebrane nieprawidłowe żądanie HTTP, żądanie zostanie przerwane bezpośrednio, a kod w funkcji nigdy nie zostanie wykonany. Używaj `HttpBodyValidation` tylko wtedy, gdy na przykład komunikaty o błędach dotyczące ciała mają być przetwarzane ręcznie w tej samej trasie.",
        "File Upload": "Przesyłanie plików",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "Aby umożliwić klientowi przesyłanie plików, można użyć specjalnego typu właściwości w modelu ciała. Można użyć dowolnej liczby `UploadedFile`.",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "Domyślnie router przechowuje wszystkie przesłane pliki w folderze tymczasowym i usuwa je po wykonaniu kodu trasy. Dlatego konieczne jest odczytanie pliku znajdującego się w ścieżce określonej w `path` i zapisanie go w trwałym miejscu (na lokalnym dysku twardym, w chmurze, w bazie danych).",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Walidacja w serwerze HTTP jest obowiązkową funkcją, ponieważ prawie zawsze przetwarzane są dane, które nie są godne zaufania. Im więcej miejsc, w których dane są walidowane, tym stabilniejszy serwer. Walidacja w trasach HTTP może być wygodnie używana poprzez typy i ograniczenia walidacyjne i jest sprawdzana za pomocą wysoce zoptymalizowanego walidatora z `@deepkit/type`, dzięki czemu nie ma problemów z wydajnością w tym zakresie. Dlatego bardzo zalecane jest korzystanie z tych możliwości walidacji. Lepiej raz za dużo niż raz za mało.",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "Wszystkie dane wejściowe, takie jak parametry ścieżki, parametry zapytania i parametry ciała, są automatycznie sprawdzane pod kątem określonego typu TypeScript. Jeśli dodatkowe ograniczenia są określone przez typy `@deepkit/type`, to są one również sprawdzane.",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "Więcej informacji na ten temat można znaleźć w rozdziale <<walidacja>>.",
        "Output": "Wyjście",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "Trasa może zwracać różne struktury danych. Niektóre z nich są obsługiwane w specjalny sposób, jak np. przekierowania i szablony, a inne, np. proste obiekty, są po prostu wysyłane jako JSON.",
        "JSON": "JSON",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "Domyślnie zwykłe wartości JavaScript są zwracane do klienta jako JSON z nagłówkiem `application/json; charset=utf-8`.",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "Jeśli dla funkcji lub metody określono jednoznaczny typ zwrotu, dane są serializowane w JSON za pomocą Deepkit JSON Serializer zgodnie z tym typem.",
        "HTML": "HTML",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "Aby wysłać kod HTML, można skorzystać z dwóch możliwości. Używany jest albo obiekt `HtmlResponse` albo Template-Engine z TSX.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "Wariant silnika szablonów z TSX ma tę zaletę, że używane zmienne są automatycznie kodowane w języku HTML. Więcej informacji na ten temat można znaleźć w rozdziale <<template>>.",
        "Custom Content": "Zawartość własna",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "Oprócz HTML i JSON można również wysyłać dane tekstowe lub binarne o określonym typie zawartości. Odbywa się to za pomocą obiektu `Response`.",
        "HTTP Errors": "Błędy HTTP",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "Rzucając różne błędy HTTP, można natychmiast przerwać przetwarzanie żądania HTTP i podać stan HTTP odpowiadający błędowi.",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "Domyślnie wszystkie błędy są zwracane do klienta w formacie JSON. To zachowanie można dowolnie dostosować w systemie zdarzeń pod zdarzeniem `httpWorkflow.onControllerError`. Więcej informacji na ten temat można znaleźć w rozdziale <<http-events>>.",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "Błąd `HttpAccessDeniedError` jest przypadkiem szczególnym. Gdy tylko zostanie on rzucony, przepływ pracy HTTP (zobacz <<http-events>>) nie przeskakuje do `controllerError`, ale do `accessDenied`.",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "Niestandardowe błędy HTTP mogą być tworzone i rzucane za pomocą `createHttpError`.",
        "Zusätzliche Header": "Dodatkowe nagłówki",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "Aby zmienić nagłówek odpowiedzi HTTP, można wywołać dodatkowe metody na obiektach `Response`, `JSONResponse` i `HTMLResponse`.",
        "Redirect": "Przekierowanie",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "Aby zwrócić przekierowanie 301 lub 302 jako odpowiedź, można użyć `Redirect.toRoute` lub `Redirect.toUrl`.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "Metoda `Redirect.toRoute` używa nazwy trasy. Jak ustawić nazwę trasy, można zobaczyć w sekcji <<http-route-name>>. Jeśli trasa, do której się odwołujemy (zapytanie lub ścieżka), zawiera parametry, można je określić za pomocą drugiego argumentu:",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "Alternatywnie można przekierować na adres URL za pomocą polecenia `Redirect.toUrl`.",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "Domyślnie w obu przypadkach używane jest przekierowanie 302. Można to dostosować za pomocą argumentu `statusCode`.",
        "Scope": "Zakres",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "Wszystkie kontrolery HTTP i trasy funkcjonalne są zarządzane w ramach zakresu wstrzykiwania zależności `http`. Kontrolery HTTP są odpowiednio inicjowane dla każdego żądania HTTP. Oznacza to również, że oba mogą mieć dostęp do dostawców zarejestrowanych dla zakresu `http`. W ten sposób dodatkowo `HttpRequest` i `HttpResponse` z `@deepkit/http` mogą być użyte jako zależności. Jeśli używany jest Deepkit Framework, dostępny jest również `SessionHandler` z `@deepkit/framework`.",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "Użyteczne może być umieszczenie dostawców w zakresie `http`, na przykład w celu zainicjowania usług dla każdego żądania HTTP. Po przetworzeniu żądania HTTP, kontener DI z atrybutem `http` jest usuwany, dzięki czemu wszystkie jego instancje providerów są usuwane przez garbage collector (GC).",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "Zobacz rozdział <<dependency-injection-scopes>>, aby dowiedzieć się, jak umieszczać providery w zakresie `http`.",
        "Events": "Wydarzenia",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "Moduł HTTP jest oparty na silniku przepływu pracy, który udostępnia różne tokeny zdarzeń, które można wykorzystać do powiązania z całym procesem przetwarzania żądania HTTP.",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "Silnik przepływu pracy jest maszyną stanów skończonych, która tworzy nową instancję maszyny stanów dla każdego żądania HTTP, a następnie przeskakuje z pozycji na pozycję. Pierwsza pozycja to \"początek\", a ostatnia to \"odpowiedź\". W każdej pozycji można wykonać dodatkowy kod.",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "Każdy token zdarzenia ma swój własny typ zdarzenia z dodatkowymi informacjami.",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "Ponieważ wszystkie zdarzenia HTTP bazują na silniku przepływu pracy, jego zachowanie można modyfikować poprzez użycie określonego zdarzenia i przeskakiwanie do niego za pomocą metody `event.next()`.",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "Moduł HTTP wykorzystuje własne nasłuchiwanie zdarzeń na tych tokenach zdarzeń do przetwarzania żądań HTTP. Wszystkie te nasłuchiwacze zdarzeń mają priorytet 100, co oznacza, że gdy użytkownik nasłuchuje zdarzeń, jego nasłuchiwacz zostanie domyślnie wykonany jako pierwszy (ponieważ domyślny priorytet wynosi 0). Dodaj priorytet powyżej 100, aby uruchamiał się po listach zdarzeń modułu HTTP.",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "Na przykład załóżmy, że chcesz przechwycić zdarzenie, w którym wywoływany jest kontroler. Jeśli ma zostać wywołany konkretny kontroler, sprawdzamy, czy użytkownik ma do niego dostęp. Jeśli użytkownik ma dostęp, kontynuujemy. Jeśli jednak nie, przechodzimy do następnego elementu przepływu pracy - `accessDenied`. W takim przypadku procedura odmowy dostępu jest automatycznie przetwarzana dalej.",
        "Security": "Bezpieczeństwo",
        "Sessions": "Sesje",
        "Middleware": "Middleware",
        "Resolver": "Resolver",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "Router obsługuje sposób rozwiązywania złożonych typów parametrów. Na przykład, biorąc pod uwagę trasę taką jak `/user/:id`, ten `id` może być rozwiązany do obiektu `user` poza trasą przy użyciu resolvera. To jeszcze bardziej oddziela abstrakcję HTTP od kodu trasy, co jeszcze bardziej upraszcza testowanie i modularność.",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "Użytkownik nie musi koniecznie polegać na parametrze. Równie dobrze może ona zależeć od sesji lub nagłówka HTTP i być udostępniana tylko wtedy, gdy użytkownik jest zalogowany. W \"RouteParameterResolverContext\" dostępnych jest wiele informacji o żądaniu HTTP, dzięki czemu można w ten sposób odwzorować wiele przypadków użycia.",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "W zasadzie możliwe jest również posiadanie złożonych typów parametrów dostarczanych przez kontener Dependency Injection z zakresu `http`, ponieważ są one również dostępne w funkcji lub metodzie trasy. Ma to jednak tę wadę, że nie można używać asynchronicznych wywołań funkcji, ponieważ kontener DI jest przez cały czas synchroniczny.",
        "RPC": "RPC",
        "Controller": "Kontroler",
        "Server": "Serwer",
        "Client": "Klient",
        "Authentication": "Uwierzytelnianie",
        "Transport Protocol": "Protokół transportowy",
        "WebSockets": "WebSockets",
        "TCP": "TCP",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Connection": "Połączenie",
        "Read Replica": "Przeczytaj replikę",
        "Primitives": "Prymitywna",
        "Primary Key": "Klucz podstawowy",
        "Auto Increment": "Automatyczna inkrementacja",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Opcjonalne / Nullable",
        "Embedded Types": "Typy wbudowane",
        "Default Values": "Wartości domyślne",
        "Default Expressions": "Domyślne wyrażenia",
        "Complex Types": "Rodzaje złożone",
        "Exclude": "Z wyłączeniem .",
        "Database Specific Column Types": "Typy kolumn specyficzne dla bazy danych",
        "Session / Unit Of Work": "Sesja / jednostka pracy",
        "Identity Map": "Mapa Tożsamości",
        "Change Detection": "Wykrywanie zmian",
        "Request/Response": "Wniosek/odpowiedź",
        "Query": "Zapytanie",
        "Find": "Znajdź stronę",
        "Filter": "Filtr",
        "Equal": "Equal",
        "Greater / Smaller": "Większy / Mniejszy",
        "RegExp": "RegExp",
        "Grouping AND/OR": "Grupowanie AND/OR",
        "In": "Na stronie",
        "Order": "Zamówienie",
        "Pagination": "Paginacja",
        "Aggregation": "Agregacja",
        "Join": "Dołącz do",
        "Returning": "Powrót",
        "Patch": "Łata",
        "Delete": "Usuń",
        "Lift": "Lift",
        "Repository": "Repozytorium",
        "Relations": "Relacje",
        "One To Many": "Jeden do wielu",
        "Many To Many": "Wiele do wielu",
        "One To One": "Jeden do jednego",
        "Constraints": "Ograniczenia",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "Przy usuwaniu/aktualizacji: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Inheritance": "Dziedziczenie",
        "Table Per Class": "Stół na klasę",
        "Single Table Inheritance": "Dziedziczenie pojedynczej tabeli",
        "Index": "Indeks",
        "Case Sensitivity": "Czułość na wielkość liter",
        "Character Sets": "Zestawy znaków",
        "Collations": "Kolacje",
        "Batching": "Dozowanie",
        "Caching": "Buforowanie",
        "Multitenancy": "Multitenancy",
        "Query Events": "Zdarzenia związane z zapytaniem",
        "Unit Of Work Events": "Wydarzenia w jednostce pracy",
        "Transactions": "Transakcje",
        "Isolations": "Izolacja",
        "Locking": "Blokowanie",
        "Optimistic Locking": "Optymistyczne blokowanie",
        "Pessimistic Locking": "Blokada pesymistyczna",
        "Custom Types": "Typy niestandardowe",
        "Logging": "Rejestrowanie",
        "Migration": "Migracja",
        "Seeding": "Siewnik",
        "Raw Database Access": "Nieprzetworzony dostęp do bazy danych",
        "SQL": "SQL",
        "App Configuration": "Konfiguracja aplikacji",
        "Composite Primary Key": "Złożony klucz podstawowy",
        "Plugins": "Wtyczki",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Key/Value": "Klucz/wartość",
        "Publish / Subscribe": "Opublikuj / Subskrybuj",
        "Template": "Szablon",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "Silnik szablonów oparty na TSX (JSX) po stronie serwera, który może generować HTML w sposób bezpieczny dla typów.",
        "Components": "Elementy",
        "Function Components": "Komponenty funkcji",
        "Class Components": "Komponenty klasy",
        "Dynamic HTML": "Dynamiczny HTML",
        "Optimization": "Optymalizacja",
        "Framework": "Ramy",
        "Modules": "Moduły",
        "Configuration": "Konfiguracja",
        "Application Server": "Serwer aplikacji",
        "Public Directory": "Katalog publiczny",
        "File Structure": "Struktura pliku",
        "Logger": "Rejestrator",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Przepływ pracy",
        "Testing": "Testowanie",
        "Debugger": "Debugger",
        "Module": "Moduły",
        "Profiler": "Profiler",
        "Deployment": "Wdrażanie",
        "Compiling": "Kompilacja",
        "Packaging": "Opakowania",
        "Docker": "Docker"
    }
}
