{
    "english": {
        "TypeScript ist Javascript das skaliert. Eine Sprache, die designt ist, komplexen Code zu schreiben. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Das führt oft dazu, dass TypeScript-Code nach dem Kompilieren wie normaler JavaScript-Code aussieht. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern während dem Entwickeln (spätestens jedoch bei dem Kompilieren) viel schneller und einfacher als würde das mit reinem JavaScript möglich sein und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript is Javascript that scales. A language designed to write complex code. It allows writing JavaScript with types that are checked and removed at compile time. This often results in TypeScript code looking like normal JavaScript code after compilation. This, among other things, is exactly what has made TypeScript so popular: It allows finding bugs during development (but at the latest during compilation) much faster and easier than would be possible with pure JavaScript, working with JavaScript rather than against it.",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "Deepkit is TypeScript that scales. A framework written in TypeScript for TypeScript, designed to develop very complex software in TypeScript. It brings many design patterns known from the Enterprise to TypeScript and introduces completely new features that are only possible with TypeScript's new type system to increase development speed especially in teams. Small applications can also benefit from this new approach, as Deepkit comes with many libraries for very common use cases that can be used individually or in combination. The framework itself is designed to be as agile as possible and as complex as necessary, not only to get initial results quickly, but also to maintain development speed over the long term.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries nicht nur untereinander einwandfrei funktionieren, sondern auch, dass die vorhandene Komplexität des Projektes effizient in Code gegossen werden kann. Auch ist es sehr schwer Ansprechpartner, gerade im Enterprise-Bereich, zu finden, wenn das Projekt auf tausende third-party Libraries basiert. Teilweise sind Libraries recht schnell nicht mehr richtig gepflegt und man hat entsprechend das Nachsehen, wenn der Fall mal eintritt, dass ein Bug gefunden oder ein Feature entwickelt werden soll.": "JavaScript is now the largest developer community worldwide and provides the developer with a correspondingly large selection of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer so that these libraries not only work properly with each other, but also so that the existing complexity of the project can be efficiently cast into code. It is also very difficult to find contacts, especially in the enterprise sector, if the project is based on thousands of third-party libraries. Sometimes libraries are no longer properly maintained very quickly and you are left with nothing if a bug is found or a feature needs to be developed.",
        "Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "The provision of core functions, which almost every project needs, in nicely abstracted libraries combined in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are just a few very well-known and successful examples.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten gegossen sind, um so bequem, untereinander harmonierend, und bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "These frameworks often offer the developer widespread and decades of proven concepts, which are cast in libraries or components, in order to be able to be used so comfortably, among themselves harmonizing, and meeting demand. The offered functionalities are not diced, but based on sometimes decades-old concepts, which have proven themselves by the fight in the competition with alternative ideas.",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript has seen massive progress over the years, so that more and more design patterns from the enterprise environment can now be applied. Design patterns that can be found in more and more libraries, frameworks, and tools. However, JavaScript and also TypeScript have the problem that in order to efficiently apply many proven enterprise patterns, decisive functions are missing in the language itself. This does not mean that these design patterns cannot be applied in general, but that they are less efficient than in other current languages.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (de-/serializer), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, die sie brauchen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript completely removes its type information at compile time, once TypeScript is converted to JavaScript, so no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (de-/serializer), data is validated, meta-information is added to objects, or interface information is needed. In these and many other use cases, type information at runtime can be very useful because it provides the libraries with the information they need. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript's type system, forcing the developer to write types in a new way that has nothing to do with TypeScript's syntax. The result is that TypeScript's powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit has developed a type compiler that leaves type information in place, allowing dynamic types to be computed at runtime and existing type information to be read at runtime. With this paradigm shift, completely new ways of working are possible, providing the information needed for the aforementioned use cases, radically simplifying the development of complex software, and giving the code more expressiveness. It is now possible for the first time to leverage the full power and expressiveness of TypeScript at runtime.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikations-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "Based on this paradigm shift, Deepkit has developed a number of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP Router, RPC Framework, Logger, Template System, Event System and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. Finally, one of the key features of TypeScript is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale application architecture with appropriate enterprise patterns.",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit consists of two large areas: One is the Deepkit Libraries and the Deepkit Framework. The Deepkit Libraries are a whole family of standalone TypeScript libraries (NPM packages) that are good at one topic and are optimized, well tested, and designed to complement each other optimally. A project can use individual Deepkit libraries, or the entire Deepkit framework, which brings together all the capabilities of the libraries and complements them with additional tools such as the debugger. All together, it allows the developer to build complex, fast, and production-ready applications.",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit supports a wide range of use cases. From simple command-line tools (CLI programs) to web applications and micro-services to desktop or mobile applications. The code is designed to run in any known JavaScript engine (browser as well as NodeJS) and integrates beautifully with other frameworks such as Angular, React, and Vue.",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "The claim behind Deepkit Framework is to apply clean code, SOLID principles, and enterprise design patterns to not only offer correspondingly high code quality, but allow the user to apply them as well. Deepkit also tries to promote these same principles in its documentation and examples, but does not force the developer to follow them themselves.",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "One of the most difficult problems in software development is to maintain a high development speed even after months or years, especially when the code and the team grow. There are many frameworks that promise to get you started quickly and allow you to cobble together more complex applications on your own in a very short time. However, these usually have the common problem that the development speed decreases drastically the older the project or the larger the team becomes. It is not uncommon that even after a few months and only a handful of developers, the development speed drops to 1% of the original speed.",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "To counteract this phenomenon it is necessary to apply established design patterns and to use the right framework and libraries in advance. Enterprise design patterns have established themselves for the reason that they scale excellently even with larger applications and large teams. Correctly applied, they develop their capabilities especially when a project is to be developed over a longer period of time (several months to years).",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "Design patterns have their advantages in theory, but in practice almost every pattern also has its disadvantages. These disadvantages are different depending on the language and framework, because the language and the framework itself determines how ergonomically a pattern can be applied. Just because a certain pattern can be used in a language, it does not mean that it automatically makes development better and faster.",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel kann wie bereits oben ausgeführt Typescript-Dekoratoren mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "Some languages are better suited than others for applying certain patterns. With JavaScript or even TypeScript itself, various design patterns are often usable in the core, but there are limitations that massively affect the user experience and thus speed. For example, as explained above, Typescript decors with all their idiosyncrasies may become necessary if a dependency injection framework specifies and is based on them.",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit's runtime type system ensures that in the most ergonomic way and with as little boilerplate as possible, these design patterns can be applied, unlocking their power so that high development speed is maintained not only initially, but also in the long term.",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "One of the biggest advantages of TypeScript is that it makes complex code easier to write in many use cases. This includes frontend, backend, CLI tools, mobile and desktop apps, and much more. When a project spans these use cases and relies almost exclusively on TypeScript, it is called Isomorphic TypeScript. Using TypeScript in as much code as possible can massively increase development speed. The following advantages are then suddenly available:",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit Framework and its runtime type system are designed to exploit these and more advantages of Isomorphic TypeScript to the utmost, so that its maximum powers are revealed.",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "Old approaches like the dual stack (frontend and backend in different languages) can't keep up with this by far, as the context switch between the languages alone already costs enormous energy and time. All the other advantages that have already been explained even make it an unfair comparison. An isomorphic tech stack like TypeScript, properly applied, is many times faster in development time on a fundamental level than any combination of a dual stack for backend/frontend like Java/JavaScript, PHP/JavaScript, or even JavaScript/JavaScript. Since faster development speed also means less time needed for the same features, it also means that Isomorphic TypeScript saves cash. Besides all the benefits already presented, this is the killer argument to use Isomorphic TypeScript in all the next especially commercial projects.",
        "pageBreak:": "pageBreak:",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Dekoratoren zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "Making type information available in TypeScript at runtime changes a lot. It allows new ways of working that were previously only possible in a roundabout way or not at all. Declaring types and schemas has become a big part of modern development processes. For example, GraphQL, validators, ORMs, and encoders such as ProtoBuf, and many more rely on having schema information available at runtime to provide fundamental functionality in the first place. These tools and libraries sometimes require the developer to learn completely new languages that have been developed very specifically for the use case. For example, ProtoBuf and GraphQL have their own declaration language, also validators are often based on their own schema APIs or even JSON schema, which is also an independent way to define structures. Some of them require code generators to be executed whenever a change is made, in order to provide the schema information to the runtime as well. Another well-known pattern is to use experimental TypeScript decorators to provide meta-information to classes at runtime.",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "But is all this necessary? TypeScript provides a very powerful language to describe even very complex structures. In fact, TypeScript is now touring-complete, which roughly means that theoretically any kind of program can be mapped into TypeScript. Of course, this has its practical limitations, but the important point is that TypeScript is able to completely replace any declaration formats such as GraphQL, ProtoBuf, JSON Schema, and many others. Combined with a type system at runtime, it is possible to cover all the described tools and their use cases in TypeScript itself without any code generator. But why is there not yet a solution that allows exactly this?",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "Historically, TypeScript has undergone a massive transformation over the past few years. It has been completely rewritten various times, received basic features, and undergone quite a few iterations and breaking changes. However, TypeScript has now reached a product market fit that greatly slows the rate at which fundamental innovations and breaking changes happen. TypeScript has proven itself and shown what a highly charming type system for a highly dynamic language like JavaScript should look like. The market has gratefully embraced this push and ushered in a new era in JavaScript development.",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "This is exactly the right time to build tools on top of the language itself at a fundamental level, making the above possible. Deepkit wants to be the impetus to bring decades-old design patterns from the enterprise of languages like Java and PHP not just fundamentally to TypeScript, but in a new and better way that works with JavaScript, not against it. Through type information at runtime, these are now for the first time not only possible in principle, but allow for whole new much simpler design patterns that are not possible with languages like Java and PHP. TypeScript itself has laid the foundation here to make the developer's life considerably easier with completely new approaches in strong combination with the tried and tested.",
        "High-Performance": "High-Performance",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Runtime Types": "Runtime Types",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "Reading type information at runtime is the capability Deepkit builds on in its foundation. The API of the Deepkit libraries are largely focused on using as much TypeScript type information as possible to be as efficient as possible. Type system at runtime means that type information is readable at runtime and dynamic types are computable. This means, for example, that for classes all properties and for functions all parameters and return types can be read.",
        "Nehmen wir als Beispiel diese Funktion:": "Let's take this function as an example:",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "In JavaScript itself, several pieces of information can be read at runtime. For example the name of the function (if not changed with a minimizer):",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "On the other hand the number of parameters can be read out:",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "With a bit more code it is also possible to read out the names of the parameters. However, this cannot be done without a rudimentary JavaScript parser or RegExp on log.toString(), so that's about it. Since TypeScript translates the above function into JavaScript as follows:",
        "sind die Informationen, dass message vom Typ string und der Return-Typ vom Type void ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "the information that message is of type string and the return type is of type void is no longer available. This information has been irrevocably destroyed by TypeScript.",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "However, with a type system at runtime, this information can survive, so you can programmatically read the types of message and the return type.",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit does just that. It hooks into the compilation of TypeScript and ensures that all type information is built into the generated JavaScript. Functions like typeOf() (not to be confused with the operator typeof, with a lowercase o) then allow the developer to access it. Libraries can therefore be developed based on this type information, allowing the developer to use already written TypeScript types for a whole range of application possibilities.",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "Two packages are required to install Deepkit's runtime type system. The type compiler in `@deepkit/type-compiler` and the runtime in `@deepkit/type`. The type compiler can be installed in `package.json` _devDependencies_, because it is only needed at build time.",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Dekoratoren verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "Runtime type information is not generated by default. It must be set `\"reflection\": true` in `tsconfig.json` to enable it in all files in the same folder of this file or in all subfolders. If decorators are to be used, `\"experimentalDecorators\": true` must be enabled in `tsconfig.json`. This is not strictly necessary to work with `@deepkit/type`, but necessary for certain functions of other deepkit libraries and in `@deepkit/framework`.",
        "_Datei: tsconfig.json_": "_File: tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in` node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript itself does not allow you to configure the type compiler via an `tsconfig.json`. It is necessary to either use the TypeScript compiler API directly or a build system like Webpack with _ts-loader_. To save this inconvenient path for Deepkit users, the Deepkit type compiler automatically installs itself in ` node_modules/typescript` once `@deepkit/type-compiler` is installed (this is done via NPM install hooks).",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes _tsc_, Angular, webpack, _ts-node_, and some other tools automatically work with the Deepkit type compiler.",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgenden Kommando nachgeholt werden:": "If the type compiler could not be successfully installed automatically (for example, because NPM install hooks are disabled), this can be done manually with the following command:",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "Note that `deepkit-type-install` must be run if the local typescript version has been updated (for example, if the typescript version in package.json has changed and `npm install` is run).",
        "Einführung": "Introduction",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "If the type compiler is to be used in a Webpack build, this can be done with the `ts-loader` package (or any other typescript loader that supports transformer registration).",
        "_Datei: webpack.config.js_": "_File: webpack.config.js_",
        "Typen-Dekoratoren": "Type decorators",
        "Typen-Dekoratoren sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um meist zur Laufzeit das Verhalten festzulegen. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden.  Die Datenbank Library kann diese Information nutzen, um die korrekten SQL Queries zu erstellen.": "Type decorators are normal TypeScript types that contain meta-information, mostly to specify behavior at runtime. For example, a class property can be marked as primary key, reference, or index.  The database library can use this information to create the correct SQL queries.",
        "Es können auch Validator-Einschränkungen wie zum Beispiel MaxLength, Maximum, oder Positive an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist.": "Validator constraints such as MaxLength, Maximum, or Positive can also be added to any type. Also, the serializer can be told how to serialize or deserialize a particular value.",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Dekoratoren, die alle direkt aus @deepkit/type benutzt werden können. Sie sind designt, nicht aus einer bestimmten Library zu kommen, um so Typen nicht an eine Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppelt. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Dekoratoren genutzt werden.": "Deepkit comes with a whole set of type decorators, all of which can be used directly from @deepkit/type. They are designed not to come from a specific library, so types are not tied to a library such as Deepkit RPC or Deepkit Database. This allows easier reuse of types, even in the frontend, although database type decorators are used, for example.",
        "Enhanced Types": "Enhanced Types",
        "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .": "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .",
        "Meta": "Meta",
        "MapName, Group, Data, Entity, InlineRuntimeType.": "MapName, Group, Data, Entity, InlineRuntimeType.",
        "Serializer": "Serializer",
        "Excluded, Embedded.": "Excluded, Embedded.",
        "Database": "Database",
        "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Reflection classes are discussed below. The function `typeOf` returns type objects, which are very simple object literals. It always contains a `kind` which is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "There are a number of possible type objects that can be returned. The simplest of these are `never`, `any`, `unknown`, `void, null,` and `undefined`, which are represented as follows:",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "For example, number 0 is the first entry of the `ReflectionKind` enum, in this case `never`, number 1 is the second entry, here `any`, and so on. Accordingly, primitive types such as `string`, `number`, `boolean` are represented as follows:",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "These rather simple types have no further information attached to the type object, since they were passed directly as type arguments to `typeOf`. However, if types are passed via type aliases, additional information can be found at the type object.",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "In this case, the name of the type alias `title` is also present. If a type alias is a generic, the types passed will also be available at the type object.",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "If the type passed is the result of an index access operator, the container and index type are available:",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "Interfaces and object literals are both output as Reflection.objectLiteral and contain the properties and methods in the `types` array.",
        "Index Signatures sind ebenfalls in dem `types` array.": "Index Signatures are also in the `types` array.",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "Classes are similar to object literals and also have their properties and methods under a `types` array in addition to `classType` which is a reference to the class itself.",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "Note that the type has been changed from Reflection.propertySignature to Reflection.property and Reflection.methodSignature to Reflection.method. Since properties and methods on classes have additional attributes, this information can also be retrieved. The latter additionally include `visibility`, `abstract`, and `default`.",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "Type objects of classes contain only the properties and methods of the class itself and not of super-classes. This is contrary to type objects of interfaces/object-literals, which have all property signatures and method signatures of all parents resolved into `types`. To resolve the property and method of super-classes, either ReflectionClass and its `ReflectionClass.getProperties()` (see following sections) or `resolveTypeMembers()` from `@deepkit/type` can be used.",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "There is a whole plethora of type objects. For example, for literal, template literals, promise, enum, union, array, tuple, and many more. To find out which ones all exist and what information is available, it is recommended to import `type` from `@deepkit/type`. It is a `union` with all possible subtypes like TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, and many more. The exact structure can be found there.",
        "Type Cache": "Type Cache",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "Type objects are cached for type aliases, functions, and classes as soon as no generic argument is passed. This means that a call to `typeOf<MyClass>()` always returns the same object.",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "However, as soon as a generic type is used, new objects are always created, even if the type passed is always the same. This is because an infinite number of combinations are theoretically possible, and so a cache would effectively be a memory leak.",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "However, once a type is instantiated into a recursive type multiple times, it is cached. However, the duration of the cache is limited only to the moment the type is computed and is non-existent thereafter. Also, although the Type object is cached, a new reference is returned and is not the exact same object.",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "All non-root Type objects have a parent property, which usually points to the enclosing parent. This is valuable for example to find out if a Type is part of a union or not.",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": " Ref 1 points to the actual union Type object.",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "In the case of cached Type objects, as exemplified above, the `parent` properties are not always the real parents. For example, for a class that is used multiple times, although immediate types in `types` (TypePropertySignature and TypeMethodSignature) point to the correct TypeClass, the `type` of these signature types point to the signature types of the TypeClass of the cached entry. This is important to know so as not to infinitely read the parent structure, but only the immediate parent. The fact that the parent does not have infinite precision is due to performance reasons.",
        "JIT cache": "JIT cache",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "In the further course some functions and features are described, which are often based on the type objects. To implement some of them in a performant way, a JIT cache (just in time) per type object is needed. This can be provided via `getJitContainer(type)`. This function returns a simple object on which arbitrary data can be stored. As long as no reference is held to the object, it will automatically be deleted by the GC as soon as the Type object itself is also no longer referenced.",
        "Reflection-Klassen": "Reflection classes",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "In addition to the `typeOf&lt;&gt;()` function, there are various reflection classes that provide an OOP alternative to Type objects. The reflection classes are only available for classes, interface/object literals and functions and their direct sub-types (properties, methods, parameters). All deeper types must be read again with the Type objects.",
        "Typeninformation empfangen": "Receiving type information",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "In order to provide functions that operate on types yourself, it can be useful to offer to pass a type to the user manually. For example, in a validation function, it might be useful to provide the type to be requested as the first type argument and the data to be validated as the first function argument.",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "In order for this function to receive the type `string`, it must communicate this to the type compiler.",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType` with the reference to the first type argument `T` signals the type compiler that any call to `validate` should put the type second (since `type` is declared second). To then read out the information at runtime, the `resolveReceiveType` function is used.",
        "Es ist nützlich, das Ergebnis der selben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typenkompiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type` now either a type object is stored or an error is thrown, if for example no type argument was passed, Deepkit's type compiler was not installed correctly, or the emitting of type information is not activated (see section Installation above).",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "To learn in detail how Deepkit encodes and reads the type information in JavaScript, this chapter is intended. It explains how the types are converted to bytecode, emitted in the JavaScript, and then interpreted at runtime.",
        "Typen-Compiler": "Type compiler",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "The type compiler (in @deepkit/type-compiler) is responsible for reading the defined types in the TypeScript files and compiling them into a bytecode. This bytecode has everything needed to execute the types in runtime.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "At the time of this writing, the type compiler is a so-called TypeScript transformer. This transformer is a plugin for the TypeScript compiler itself and converts one TypeScript AST into another TypeScript AST. In this process, Deepkit's type compiler reads the AST, produces the associated bytecode, and inserts it into the AST.",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript itself does not allow you to configure this plugin aka transformer via a tsconfig.json. It is either necessary to use the TypeScript compiler API directly, or a build system like Webpack with `ts-loader`. To avoid this inconvenience for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modules/typescript` when `@deepkit/type-compiler` is installed. This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes tsc, Angular, webpack, ts-node, and some other tools work automatically with Deepkit's type compiler.",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "If automatic running of NPM install scripts is not enabled and thus the locally installed typescript is not modified, this process must be run manually if you want to. Alternatively, the types compiler can be used manually in a build tool such as webpack. See the Installation section above.",
        "Bytecode Encoding": "Bytecode Encoding",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "The bytecode is a sequence of commands for a virtual machine and is encoded in the JavaScript itself as an array of references and string (the actual bytecode).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlessatz über 81 Befehle gross.": "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as a `ReflectionOp` enum. At the time of this writing, the command set is over 81 commands in size.",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "A sequence of commands is encoded as a string to save memory. Thus, a type `string[]` is conceptualized as a bytecode program `[string, array]`, which has bytes `[5, 37]` and is encoded using the following algorithm:",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "Accordingly, a 5 becomes a `&amp;` character and a 37 becomes a `F` character. Together they become `&amp;F` and are emitted in Javascript as `['&amp;F']`.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__&#8486;\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "To prevent naming conflicts, each type is given a \"__&#8486;\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode emits the JavaScript. Classes and functions also receive a bytecode directly as a property.",
        "Virtuelle Maschine": "Virtual machine",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "A runtime virtual machine (in `@deepkit/type` the Processor class) is responsible for decoding and executing the encoded bytecode. It always returns a type object, see the Reflection section above.",
        "Validation": "Validation",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation is the process of checking data for correctness. Correctness is given if the type is the correct one and additional defined constraints are met. Deepkit generally distinguishes between type validation and the validation of additional constraints.",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "Validation is used whenever data comes from a source that is considered unsafe. Uncertain means that no guaranteed assumptions can be made about the types or contents of the data, and thus the data could have literally any value at runtime.",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "For example, data from user input is generally considered insecure. Data from an HTTP request (query parameter, body), CLI arguments, or a read-in file must be validated. If a variable is declared as a number, there must also be a number in it, otherwise the program may crash or a security hole may occur.",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "In a controller of an HTTP route, for example, the top priority is to check every user input (query parameter, body). Especially in the TypeScript environment, it is important not to use type casts, as they are fundamentally insecure.",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "Validation is an essential part of every application and should be used better once too much than once too little. Deepkit provides many validation options and has a high-performance implementation, so in the vast majority of cases there is no need to worry about execution time. Use as much validation as possible, once more if in doubt, to be on the safe side.",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "Many components of Deepkit like the HTTP router, the RPC abstraction, but also the database abstraction itself have validation built in and are executed automatically, so in many cases it is not necessary to do this manually.",
        "Benutzung": "Usage",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "The basic function of the validator is to check a value for its type. For example, whether a value is a string. This is not about what the string contains, just its type. There are many types in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, and many more. Because of Typescript's powerful type system, a large variety of different types are available.",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "In JavaScript itself, primitive types can be parsed with the `typeof` operator. For more complex types like interfaces, mapped types, or generic set/map this is not so easy anymore and a validator library like `@deepkit/type` is needed. Deepkit is the only solution that allows to validate all TypesScript types directly without any detours.",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "The type of `username` is string. If you want a validator to check if the variable `username` is a string, this can be easily done with JavaScript itself.",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "The function `isString` can thus be seen as a type validator. In JavaScript itself, however, it becomes more difficult when numbers are to be checked. There are special features like NaN (\"Not a Number\") when an invalid string is converted into a number.",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "The operator `typeof` returns Number, although it is the value NaN (\"Not a Number\"), which literally says that it does not want to be a number. From here on, special additional checks like `isNaN()` have to be done and it quickly becomes obvious to use external libraries like Deepkit which automatically take these peculiarities into account.",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "In Deepkit a type validation can be undertaken either by the function `validate`, `is`, or `assert`. The function `is` is a so-called type guard and `assert` is a type assertion. Both will be explained in the next section.",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "The function `validate` returns an array of found errors and on success an empty array. Each entry in this array describes the exact error code and the error message as well as the path as soon as more complex types like objects or arrays are validated.",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "The usage of all three functions is roughly the same. Thus as first type argument the type is indicated and/or referenced and as first function argument the data is passed.",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "If more complex types such as classes or interfaces are used, the array can also contain several entries.",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "The validator also supports deep recursive types. Paths are then separated with a dot.",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "Use the advantages that TypeScript offers you. For example, more complex types like a `User` can be reused in multiple places without having to declare it again and again. For example, if a `user` is to be validated without its `id`, TypeScript utitilies can be used to quickly and efficiently create derived subtypes. Very much in the spirit of DRY (Don't Repeat Yourself).",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit is the only major framework that has the ability to access TypeScripts types in this way at runtime. If you want to use types in frontend and backend, types can be swapped out to a separate file and thus imported anywhere. Use this option to your advantage to keep code efficient and clean.",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "A type cast (contrary to type guard) in TypeScript is not a construct at runtime, but is only handled in the type system itself. It is not a safe way to assign a type to unknown data.",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "The code `as string` is not safe in this case. The variable `data` could have literally any value, for example `{username: 123}`, or even `{}`, and would result in `username` not being a string, but something completely different and therefore the code `username.startsWith('@')` will result in an error, so in the worst case the program will crash. To guarantee at runtime that `data` here has a property `username` with type String, type-guards must be used.",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "Type-guards are functions that give TypeScript a hint about which type the passed data is guaranteed to have at runtime. Armed with this knowledge, TypeScript then narrows the type as the code progresses.  For example, `any` can be made into a string, or any other type in a safe way.",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "So if there is data of which the type is not known (`any` or `unknown`), a type guard helps to narrow it down more precisely based on the data itself. However, the type guard is only as safe as its implementation. If you make a mistake, this can have serious consequences, because fundamental assumptions suddenly turn out to be untrue.",
        "Type-Guard": "Type-Guard",
        "Ein Type-Guard auf den obige genutzten Typen User könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obig erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht korrekt ist.": "A Type-Guard on the above used type user could look in simplest form as follows. It is to be noted that the special features with NaN explained above are not a component here and thus this Type-Guard is not correct.",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "A type guard always returns a Boolean and is usually used directly in an If operation.",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "Writing a separate function for each type-guard, especially for more complex types, and then adjusting it every time a type changes is extremely tedious, error-prone, and not efficient. Therefore, Deepkit provides the function `is`, which automatically provides a Type-Guard for any TypeScript type. This then also automatically takes into account special features such as the above-mentioned problem with NaN. The function `is` does the same as `validate`, but instead of an array of errors it simply returns a boolean.",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "A more common pattern is to return an error directly when validation fails, so that subsequent code is not executed. This can be used in various places without changing the complete flow of the code.",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "Alternatively, a TypeScript type assertion can be used. The function `assert` automatically throws an error if the given data does not validate to a type correctly. The special signature of the function, which distinguishes TypeScript type assertions, helps TypeScript to automatically refine (\"narrow\") the passed variable.",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "Again, take advantage of the benefits that TypeScript offers you. Types can be reused or customized using various TypeScript functions.",
        "Einschränkungen": "Constraints",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "In addition to type checking, other arbitrary constraints can be added to a type. The validation of these additional content constraints is done automatically after the types themselves have been validated. This is done in all validation functions like `validate`, `is`, and `assert`. A restriction can be, for example, that a string must have a certain minimum or maximum length.",
        "Diese Einschränkungen werden über die Typen-Dekorationen an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Dekoratoren können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "These restrictions are added to the actual types via the type decorations. There is a whole variety of decorations that can be used. Custom decorators can be defined and used as desired if the need is extended.",
        "Mit `&` können beliebig viele Typen-Dekoratoren an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "With `&amp;` any number of type decorators can be added to the actual type. The result, here `username`, can then be used in all validation functions but also in other types.",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "The function `validate` gives useful error messages coming from the constraints.",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "This information can be displayed for example wonderfully also at a form automatically and be translated by means of the `code`. Due to the existing path for objects and arrays, fields in a form can filter out and display the appropriate error.",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "An often useful use case is also to define an email with a RegExp constraint. Once the type is defined, it can be used anywhere.",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "Any number of constraints can be added.",
        "Constraint Types": "Constraint Types",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "Validation using a custom validation function. See next section Custom Validator for more information.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Defines a regular expression as validation pattern. Usually used for email validation or more complex content validation.",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "Validation for alpha characters (a-Z).",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "Validation for alpha and numeric characters.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Validation for ASCII characters.",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Validation for string representing a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Validation of numbers that are a multiple of given number.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "Validation for min/max length for arrays or strings.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "Validation for an array item or sub string being included/excluded",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Validation for a value being minimum or maximum given number. Same as `&gt;=` and `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "Same as minimum/maximum but excludes the value itself. Same as `&gt;` and `&lt;`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date)...",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string &amp; Email`.",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Ensures that the number is an integer in the correct range. Is automatically a `number`, so no need to do `number &amp; integer`.",
        "See Special types: integer/floats for more information": "See Special types: integer/floats for more information",
        "Benutzerdefinierte Validator": "Custom Validator",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "If the built-in validators are not sufficient, custom validator functions can be created and used via the `Validate` decorator.",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "Note that your custom validator function will be executed after all built-in type validators have been called. If a validator fails, all subsequent validators for the current type will be omitted. Only one failure is possible per type.",
        "Generic Validator": "Generic Validator",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "The type object is available in the validator function, which can be used to get more information about the type using the validator. There is also a way to define an arbitrary validator option that must be passed to the validate type, making the validator configurable. With this information and its parent references, powerful generic validators can be created.",
        "Serialisation": "Serialization",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "Serialization is the process of converting data types into a format suitable for transport or storage, for example. Deserialization is the process of undoing this. This is done losslessly, meaning that data can be converted to and from a serialization target without losing data type information or the data itself.",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet.": "In JavaScript, serialization is usually done between JavaScript objects and JSON. JSON supports only string, number, boolean, objects, and arrays. JavaScript, on the other hand, supports many other types such as BigInt, ArrayBuffer, typed arrays, Date, custom class instances, and many more. Now, to transmit JavaScript data to a server using JSON, you need a serialization process (on the client) and a deserialization process (on the server), or vice versa if the server sends data to the client as JSON.",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "This serialization process is absolutely necessary for non-trivial data, since JSON loses its information even for basic types like a date. A `new date` is finally serialized as a string in JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "As can be seen, the result of JSON.stringify is a JSON string. If you deserialize it again with JSON.parse, you will not get a `date` object, but a string.",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "Although there are several workarounds to teach JSON.parse to deserialize Date objects, they are error-prone and not very performant. To enable type-safe serialization and deserialization for this case and many other types, a serialization process is necessary.",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "There are four main functions available: `serialize`, `cast`/`deserialize` and `validatedDeserialize`. Under the hood of these functions, the globally available JSON serializer of `@deepkit/type` is used by default, but a custom serialization target can also be used.",
        "Zu beachten ist, dass obwohl Serializer auch Daten validieren, um sicherzustellen, dass diese auch umgewandelt werden können, diese Validierung nicht dieselbe ist wie in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Note that although serializers also validate data to ensure that it can be converted, this validation is not the same as in the &lt;&gt; section<validation>. Only the `cast` function also calls the full validation process after successful deserialization, and throws an error if the data is not valid.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see chapter &lt;&gt; for details<validation>.",
        "Alle Funktionen aus den Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "All functions from the serialization and validation throw a `ValidationError` from `@deepkit/type` on errors.",
        "Deserialisierung": "Deserialization",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "The `deserialize` function converts the passed data to the appropriate specified type using the JSON serializer by default. The JSON serializer expects a JSON object, i.e.: string, number, boolean, object, or array. This is usually obtained from a JSON.parse call.",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "If the correct data type is already passed (for example a Date object for `created`), then this is taken as it is.",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "Not only a class but any TypeScript type can be specified as the first type argument. So even primitives or very complex types can be passed:",
        "Weiche Typenkonvertierung": "Soft type conversion",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserialisierer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "In the deserialization process a soft type conversion is implemented. This means that String and Number can be accepted for string types or a Number can be accepted for a string type and converted automatically. This is useful, for example, when data is accepted via a URL and passed to the deserializer. Since the URL is always a string, Deepkit Type will still attempt to resolve the types for Number and Boolean.",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serialiser eingebaut:": "The following soft type conversions are built into the JSON serializer:",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "Soft conversion can also be disabled:",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "It will then not attempt to convert invalid data and instead throw an error message.",
        "Serialisierung": "Serialization",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "The function `serialize` converts the passed data per default with the JSON serializer into a JSON object, i.e.: string, number, boolean, object, or array. The result of this can then be safely converted to a JSON using JSON.stringify.",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Todo": "Todo",
        "Dependency Injection": "Dependency Injection",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten": "Dependency Injection (DI) is a design pattern where classes and functions _receive_ their dependencies",
        "_empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\")": ". It follows the principle of Inversion of Control (IoC)",
        "und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität,": "and helps to better separate especially complex code to significantly improve testability, modularity,",
        "und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum": "and clarity. There are still other Design Patterns like for",
        "Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als": "example the Service Locator Pattern, in order to apply the principle of IoC, however DI established itself as",
        "dominantes Pattern vor allem in Enterprise-Software etabliert.": "dominant Pattern particularly in Enterprise software.",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "In order to illustrate the principle of IoC following an example:",
        "Die Klasse UserRepository hat dabei als Abhängigkeit einen HttpClient. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "The class UserRepository has a HttpClient as dependence. This dependency in itself is nothing remarkable, but it is problematic that UserRepository creates the HttpClient itself. This is obvious at first glance, but it has its drawbacks: What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?",
        "Inversion of Control": "Inversion of Control",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "In the idea of Inversion of Control (IoC) is the following alternative variant, which sets the HttpClient as an explicit dependency in the constructor (also known as constructor injection).",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "Now, UserRepository is no longer responsible for creating the HttpClient, but UserRepository's user is. This is Inversion of Control (IoC). The control has been reversed or inverted. Specifically, this code applies dependency injection, because dependencies are received (injected) and no longer created or requested. Dependency Injection is only one variant of IoC.",
        "Service Locator": "Service Locator",
        "Neben DI ist auch ein Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "Besides DI, a Service Locator (SL) is also a possibility to apply the IoC principle. This is commonly considered the counterpart to Dependency Injection, since it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a service locator pattern.",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "The function `locator.getHttpClient` can have any name. Alternatives would be function calls like `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` or a container call like `container.get(HttpClient)`. An import of a global is a slightly different variant of a service locator, using the module system itself as the locator:",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "All of these variants have in common that they explicitly request the HttpClient dependency. This request can happen not only to properties as a default value, but also somewhere in the middle of the code. Since in the middle of the code means that it is not part of a type interface, the use of the HttpClient is hidden. Depending on the variant of how the HttpClient is requested, it can sometimes be very difficult or completely impossible to replace it with another implementation. Especially in the area of unit tests and for the sake of clarity, difficulties can arise here, so that the service locator is now classified as an anti-pattern in certain situations.",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "With Dependency Injection nothing is requested, but it is explicitly provided by the user or received by the code. As can be seen in the example of Inversion of Control, the Dependency Injection pattern has already been applied there. Specifically, constructor injection can be seen there, since the dependency is declared in the constructor. So UserRepository must now be used as follows.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes mal neu erstellt oder jedes mal der selbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether HttpClient should be created each time or the same one should be used each time is now decided by the user of the class and no longer by the class itself. It is no longer requested (from the point of view of the class) as in the case of the service locator or created completely by the user in the initial example. This inverting of the flow has various advantages:",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "But an obvious disadvantage can also be seen directly: Do I really have to create or manage all dependencies like the HttpClient myself? Yes and No. Yes, there are many cases where it is perfectly legitimate to manage the dependencies yourself. The hallmark of a good API is that dependencies don't get out of hand, and that even then they are pleasant to use. For many applications or complex libraries, this may well be the case. To provide a very complex low-level API with many dependencies in a simplified way to the user, Facades are wonderfully suitable.",
        "Dependency Injection Container": "Dependency Injection Container",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "A dependency injection container (also called DI container or IoC container) brings Deepkit in `@deepkit/injector` or already ready integrated via app modules in the Deepkit framework. The above code would look like this using a low-level API from the `@deepkit/injector` package.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "The `injector` object in this case is the dependency injection container. Instead of using `new UserRepository`, the container returns an instance of UserRepository using `get(UserRepository)`. To statically initialize the container, a list of providers is passed to the `InjectorContext.forProviders` function (in this case, simply the classes).",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "Since DI is all about providing dependencies, the container is provided with the dependencies, hence the technical term \"provider\". There are several types of providers: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Together, they allow very flexible architectures to be mapped with a DI container.",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "All dependencies between the providers are automatically resolved and as soon as an `injector.get()` call occurs, the objects and dependencies are created, cached, and correctly either passed as a constructor argument (constructor injection), set as a property (property injection), or passed to a method call (method injection).",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "In order to exchange the HttpClient with another one, another provider (here the ValueProvider) can be defined for HttpClient:",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": ". As soon as UserRepository is requested via `injector.get(UserRepository)`, it receives the AnotherHttpClient object. Alternatively, a ClassProvider can be used here very well, so that all dependencies of AnotherHttpClient are also managed by the DI container.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "At this point it is worth mentioning that Deepkit's DI Container only works with runtime types of Deepkit. This means that any code containing classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter<runtime-types>&lt;&gt;.",
        "Dependency Inversion": "Dependency Inversion",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "The example of UserRepository under Inversion of Control shows that UserRepository depends on a lower level HTTP library. In addition, a concrete implementation (class) is declared as a dependency instead of an abstraction (interface). At first glance, this may seem to be in line with the object-oriented paradigms, but it can lead to problems, especially in complex and large architectures.",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "An alternative variant would be to convert the HttpClient dependency into an abstraction (interface) and thus not import code from an HTTP library into UserRepository.",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "This is called Dependency Inversion Principle. UserRepository no longer has a dependency directly on an HTTP library and is instead based on an abstraction (interface). It thus solves two fundamental goals in this principle:",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "Merging the two implementations (UserRepository with an HTTP library) can now be done via the DI container.",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "Since Deepkit's DI container is capable of resolving abstract dependencies (interfaces) such as HttpClientInterface in this case, UserRepository automatically receives the implementation of HttpClient since HttpClient implemented the interface HttpClientInterface. This is done either by HttpClient specifically implementing HttpClientInterface (`class HttpClient implements HttpClientInterface`), or by HttpClient's API simply being compatible with HttpClientInterface.",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "As soon as HttpClient modifies its API (for example, removes the `get` method) and is thus no longer compatible with HttpClientInterface, the DI container throws an error (\"the HttpClientInterface dependency was not provided\").",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "Here the user, who wants to bring both implementations together, is obliged to find a solution. As an example, an adapter class could then be registered here that implements HttpClientInterface and correctly forwards the method calls to HttpClient.",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip sein Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "Here it is to be noted that although in theory the Dependency Inversion principle has its advantages, so it has in practice also substantial disadvantages. Not only does it lead to more code (since more interfaces have to be written), but it also leads to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-use factor, which should be thought through before it is applied.",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "Design patterns should not be used blindly for any code, no matter how simple. However, if the prerequisites such as a complex architecture, large applications, or a scaling team are given, Dependency Inversion and other design patterns only unfold their true strength.",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/injector` can be installed itself or the Deepkit framework which already uses the library under the hood.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Once the library is installed, the API can be used directly from it.",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "To use Dependency Injection now, there are three ways.",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "If `@deepkit/injector` is to be used without the Deepkit framework, the first two options are recommended.",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "The Injector API has already been introduced in the introduction to Dependency Injection. It is characterized by a very simple usage by means of a single class `InjectorContext`, which creates a single DI container and is particularly suitable for simpler applications without modules.",
        "Module API": "Module API",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hiararchie und schön separierte Architektur aufzubauen.": "A slightly more complex API is the `InjectorModule` class, which allows to dump the providers in different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import each other, export providers to build a hierarchy and nicely separated architecture.",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "This API should be used if the application is more complex and not using the Deepkit framework.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "The `injector` object in this case is the dependency injection container. Providers can be split into different modules and then by means of module imports these can be imported again in different places. This creates a natural hierarchy that reflects the hierarchy of the application or architecture.",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "The InjectorContext should always be given the top module in the hierarchy, also called root module or app module. The InjectorContext then only has an intermediary task: calls to `injector.get()` are simply forwarded to the root module. However, it is also possible to get providers from non-root modules by passing the module as a second argument.",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "All non-root modules are encapsulated by default, so all providers in that module are only available to itself. If a provider is to be available to other modules, this provider must be exported. By exporting, the provider moves to the parent module of the hierarchy and can thus be used.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden.": "To export all providers by default to the top level, the root module, the option 'forRoot' can be used.",
        "App API": "App API",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, so dass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Once the Deepkit framework is used, modules are defined with the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. In addition, it is possible to work with powerful hooks as well as define configuration loaders to map even more dynamic architectures.",
        "Providers": "Providers",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "In the Dependency Injection container there are several possibilities to provide dependencies. The simplest variant is simply the specification of a class. This is also known as short ClassProvider.",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "This represents a special Provider, since only the class is specified. All other providers must be specified as object literals.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes mal neu ausgeführt werden.": "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This will cause classes to be recreated each time or factories to be executed each time.",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "Beside the short ClassProvider there is also the regular ClassProvider, which is an object literal instead of a class.",
        "Dies ist Äquivalent zu diesen beiden:": "This is equivalent to these two:",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "It can be used to exchange a provider with another class.",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "In this example, the class `OtherUserRepository` is now also managed in the DI container and all its dependencies are automatically resolved.",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "Static values can be provided with this provider.",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "Since not only class instances can be provided as dependencies, any value can be specified as `useValue`. A symbol or a primitive (string, number, boolean) could also be used as a provider token.",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "Primitive provider tokens must be declared with the Inject type as a dependency.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängikeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "With the combination of an inject alias and primitive provider tokens, dependencies can also be provided from packages that do not contain runtime type information.",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "And then declared on the user side as follows:",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "A redirect to an already defined provider can be defined.",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfigurations-Optionen zugreifbar.": "A function can be used to provide a value for the provider. This function can also contain parameters, which in turn are provided by the DI container. Thus other dependencies or configuration options are accessible.",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "In addition to classes and primitives, abstractions (interfaces) can also be provided. This is done using the `provide` function and is particularly useful when the value to be provided does not contain type information.",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "If several providers have implemented the interface connection, the last provider is used.",
        "Als Argument für provide() sind alle anderen Provider möglich.": "All other providers are possible as arguments to provide().",
        "Constructor/Property Injection": "Constructor/Property Injection",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "In most cases, constructor injection is used. All dependencies are specified as constructor arguments and are automatically injected by the DI container.",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "Optional dependencies should be marked as such, otherwise an error could be thrown if no provider can be found.",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "An alternative to constructor injection is property injection. This is usually used when the dependency is optional or the constructor is otherwise too full. The properties are automatically assigned once the instance is created (and thus the constructor has been executed).",
        "Konfiguration": "Configuration",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "The dependency injection container also allows configuration options to be injected. This configuration injection can be received via constructor injection or property injection.",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "The Module API supports the definition of a configuration definition, which is a regular class. By providing such a class with properties, each property acts as a configuration option. Because of the way classes can be defined in TypeScript, this allows defining a type and default values per property.",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "The configuration options `domain` and `debug` can now be conveniently used type-safe in providers.",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "The values of the options themselves can be set via `configure()`.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem \"!\" versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Options that do not have a default value, but are necessary anyway, can be marked with a \"! This forces the user of the module to provide the value, otherwise an error will occur.",
        "Injection": "Injection",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "Configuration options can be safely and easily injected through the DI container like other dependencies, as shown earlier. The simplest method is to reference a single option using the index access operator:",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "Configuration options can be referenced not only individually, but also as a group. For this, the TypeScript utility type `Partial` is used:",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "To get all configuration options, the configuration class can also be referenced directly:",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "However, it is recommended to reference only the configuration options that are actually used. This not only simplifies unit tests, but also makes it easier to see what is actually needed from the code.",
        "Scopes": "Scopes",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "By default, all providers of the DI container are singletons and are therefore instantiated only once. This means that in the example of UserRepository there is always only one instance of UserRepository during the entire runtime. At no time a second instance is created, unless the user does this manually with the \"new\" keyword.",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "Now, there are various use cases where a provider should only be instantiated for a short time or only during a certain event. Such an event could be for example a HTTP request or a RPC call. This would then mean that a new instance is created each time an event occurs and after this instance is no longer used it is automatically removed (by the garbage collector).",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "An HTTP request is a classic example of a scope. For example, providers such as a session, a user object, or other request-related providers can be registered to this scope. To create a scope, simply choose an arbitrary scope name and then specify it with the providers.",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "Once a scope is specified, that provider cannot be obtained directly through the DI container, so the following call will fail:",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedesmal geschehen sobald ein HTTP-Request reinkommt:": "Instead, a scoped DI container must be created. This would happen every time a HTTP request comes in:",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "Providers that are also registered in this scope can now be requested on this scoped DI container, as well as all providers that do not have a scope defined.",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "Since all providers are singleton by default, each call to `get(UserSession)` will always return the same instance per scoped container. If you create multiple scoped containers, multiple UserSessions will also be created.",
        "Setup Calls": "Setup calls",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "Setup calls allow to manipulate the result of a provider. This is useful for example to use another dependency injection variant, the method injection.",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "Setup calls can only be used with the module API or the app API and are registered on top of the module.",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "The method `setupProvider` returns a proxy object of UserRepository on which its methods can be called. It should be noted that these method calls are merely placed in a queue and are not executed at this time. Accordingly, no return value is returned.",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "In addition to method calls, properties can also be set.",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "This assignment is also only placed in a queue.",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "The calls and/or the assignments in the queue are then executed on the actual result of the Provider, as soon as this is created. That is with a ClassProvider these are applied to the class instance, as soon as the instance is created, with a FactoryProvider on the result of the Factory, and with a ValueProvider on the Provider.",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "To reference not only static values, but also other providers, the function `injectorReference` can be used. This returns a reference to a provider, which is also requested by the DI container when the setup calls are executed.",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces*",
        "Es können auch Interfaces Setup-Calls zugewiesen werden.": "Setup calls can also be assigned to interfaces.",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Command-line Interface (CLI) programs are programs that interact via the terminal in the form of text input and text output. The advantage to interacting with the application in this manner is that only a terminal needs to exist either locally or via an SSH connection.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "A CLI application in Deepkit has full access to the DI container and thus can access all providers and configuration options.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "The CLI application's arguments and options are controlled by method parameters via TypeScript types and are automatically serialized and validated.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI is one of three entry points to a Deepkit Framework application. In the Deepkit Framework, the application is always launched via a CLI program, which is itself written in TypeScript by the user. Therefore, there is no Deepkit specific global CLI tool to launch a Deepkit application. This is how you launch the HTTP/RPC server, perform migrations, or run your own commands. This is all done through the same entry point, the same file. Once the Deepkit framework is used by importing `FrameworkModule` from `@deepkit/framework`, the application gets additional commands for the application server, migrations, and more.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Dekoratoren, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "The CLI framework allows you to easily register your own commands based on simple classes. In fact, it is based on `@deepkit/app`, a small package designed just for this purpose and can be used standalone without the Deepkit framework. In this package you can find decorators that are needed to decorate the CLI controller class.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "Controllers are managed or instantiated by the Dependency Injection container and can therefore use other providers. See the &lt;&gt; chapter<dependency-injection>for more details.",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, @deepkit/app can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Note that `@deepkit/app` is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators`.",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "To create a command for your application, you need to create a CLI controller. This is a simple class that has a method `exeecute` and is equipped with information about the command.",
        "_Datei: app.ts_": "_File: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "In the decorator `@cli.controller` the unique name of the CLI application is defined as the first argument. Further options like a description can be optionally added in the object at the second position.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "This code is already a complete CLI application and can be started like this:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "You can see that a \"test\" command is available. To run this, the name must be passed as argument:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "It is also possible to make the file executable using `chmod +x app.ts`, so that the command `./app.ts` is already sufficient to start it. Note that a so-called",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "shebang is then necessary. Shebang means the character combination `#!` at the beginning of a script program. In the example above this is already present: `&#35;!/usr/bin/env ts-node-script` and uses the script mode of `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "In this way, any number of commands can be created and registered. The unique name specified in `@cli.controller` should be well chosen and allows grouping of commands with the `:` character (e.g. `user:create`, `user:remove`, etc).",
        "Argumente": "Arguments",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "To add arguments, new parameters are added to the `execute` method and decorated with the `@arg` decorator.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "If you execute this command now without specifying a name, an error will be issued:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "Using `--help` will give you more information about the required arguments:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Once the name is passed as an argument, the `execute` method in TestCommand will be executed and the name will be passed correctly.",
        "Flags": "Flags",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags are another way to pass values to your command. Most of the time they are optional, but they do not have to be. Parameters decorated with `@flag name` can be passed via `--name value` or `--name=value`.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "In the help view you can see in the \"OPTIONS\" that a `--id` flag is necessary. If this is specified correctly, the command will receive this value.",
        "Boolean Flags": "Boolean Flags",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flags have the advantage that they can also be used as a worthless flag, for example to activate a certain behavior. As soon as a parameter is marked as an optional boolean, this behavior is activated.",
        "Multiple Flags": "Multiple Flags",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "To pass multiple values to the same flag, a flag can be marked as an array.",
        "Single Character Flags": "Single Character Flags",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "To allow a flag to be passed as a single character as well, `@flag.char('x')` can be used.",
        "Optional / Default": "Optional / Default",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "The signature of the `execute` method defines which argument or flags are optional. If the parameter is marked as optional, it does not have to be specified.",
        "The signature of the method `execute` defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "The signature of the method `execute` defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.",
        "Dasselbe für Parameter mit einem Default-Wert:": "The same for parameters with a default value:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "This also applies to flags in the same way.",
        "Serialization / Validation": "Serialization / Validation",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "All arguments and flags are automatically deserialized based on their types, validated and can be provided with additional constraints.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "For example, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the &lt;&gt; feature<serialisation-loosely-convertion>.",
        "Zusätzliche Einschränkungen können mit den Typen-Dekoratoren aus `@deepkit/type` definiert werden.": "Additional constraints can be defined with the type decorators from `@deepkit/type`.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "The type `Postive` at `id` indicates that only positive numbers are wanted. If the user now passes a negative number, the code in `execute` will not be executed at all and an error message will be presented.",
        "Description": "Description",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "To describe a flag or argument, `@flag.description` or `@arg.description` can be used.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "In the help view this description appears after the flag or argument:",
        "Exit code": "Exit code",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "The exit code is 0 by default, which means that the command was executed successfully. To change the exit code, a number other than 0 should be returned in the `exucute` method.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "The class of the command is managed by the DI container, so dependencies can be defined and resolved through the DI container.",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "Processing HTTP requests is one of the most well-known tasks for a server. It converts an input (HTTP request) into an output (HTTP response) and performs a specific task. A client can send data to the server via an HTTP request in a variety of ways, which must be read and handled correctly. In addition to the HTTP body, HTTP query or HTTP header values are also possible. How data is actually processed depends on the server. It is the server that defines where and how the values are to be sent by the client.",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "The top priority is not only to correctly execute what the user expects, but also to correctly convert (deserialize) and validate any input from the HTTP request.",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "The pipeline through which an HTTP request passes on the server can be diverse and complex. Many simple HTTP libraries simply pass the HTTP request and HTTP response for a given route, and expect the developer to process the HTTP response directly. A middleware API allows the pipeline to be extended at will.",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte bzw Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den User damit eine Architektur selbst obendrauf zu setzen, die einem diese zwingenden Funktionalitäten abnimmt.": "This is very well tailored for simple use cases, but quickly becomes confusing when the application grows, since all inputs and outputs must be manually serialized or deserialized and validated. Also must be considered like objects and/or services as for example a data base abstraction from the application can be received. It forces the user to put an architecture on top of it, which takes away these mandatory functionalities.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection: Serialisierung bzw Deserialisierung und Validierung von jeglichen Werten passiert automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer gewählten Architektur abzudecken.": "Deepkit's HTTP library leverages the power of TypeScript and Dependency Injection: serialization/deserialization and validation of any values happens automatically based on the defined types. It also allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of a chosen architecture.",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "It can be used either with an existing HTTP server like Node's `http` module or with the Deepkit framework. Both API variants have access to the dependency injection container and can thus conveniently retrieve objects such as a database abstraction and configurations from the application.",
        "_Deepkit Beispiel_": "_Deepkit Example_",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "Note that `@deepkit/http` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.",
        "Funktionale API": "Functional API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "The functional API is based on functions and can be registered via the Router Registry, which can be obtained via the DI container of the app.",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "The router registry can also be obtained in Event Listener or in the bootstrap, so based on modules, configurations and other providers, various routes are registered.",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "Once modules are used, functional routes can also be dynamically provided by modules.",
        "Controller API": "Controller API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "The controller API is based on classes and can be registered via the App API under the 'controllers' option.",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "Once modules are used, controllers can also be provided by modules.",
        "HTTP Server": "HTTP Server",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "If Deepkit Framework is used, an HTTP server is already built in there. However, the HTTP library can be used with its own HTTP server even without using the Deepkit framework.",
        "HTTP Client": "HTTP Client",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name which can be referenced when forwarding. Depending on the API, the way a name is defined differs.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "The router functions as well as the controller classes and controller methods can define arbitrary dependencies that are resolved by the dependency injection container. For example, it is possible to conveniently get a database abstraction or logger.",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "For example, if a database was provided as a provider, it can be injected:",
        "_Funktionaler API:_": "_Functional API:_",
        "_Controller API:_": "_Controller API:_",
        "Input": "Input",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "All of the following input variations function the same for both the functional and controller API. They allow to read data from an HTTP request in a type-safe and decoupled way.",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "This not only leads to significantly increased security, but also simplifies unit testing,",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "since, strictly speaking, not even an HTTP request object needs to exist to test the route.",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "For simplicity, all examples using the functional API are shown below.",
        "Path Parameters": "Path Parameters",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "Path parameters are values extracted from the URL of the route. The type of the value depends on the type at the associated parameter of the function or method.",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "The conversion is done automatically with the &lt;&gt; feature<serialisation-loosely-convertion>.",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "If a path parameter is defined as a type other than string, it will be converted correctly.",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "Additional validation constraints can also be applied to the type.",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "The path parameters have `[^/]+` set as regular expression by default for URL matching. The RegExp for this can be adjusted as follows:",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "This is only necessary in exceptional cases, since often the types in combination with validation types themselves already correctly restrict possible values.",
        "Query Parameters": "Query Parameters",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "Query parameters are also automatically deserialized and validated.",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*Warning*: Parameter values are not escaped/sanitized. Their direct return in a string in a route as HTML opens a security hole (XSS). Make sure never to trust external input and filter/sanitize/convert data where necessary.",
        "Query Model": "Query Model",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "With a lot of query parameters it can get confusing. To bring order back in here, a model (class or interface) can be used, which summarizes all possible query parameters.",
        "Body": "Body",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "For HTTP methods that allow an HTTP body, a body model can also be specified.",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "The body content type from the HTTP request must be either `application/x-www-form-urlencoded`, `multipart/form-data` or `application/json` for Deepkit to automatically convert this to JavaScript objects.",
        "Manual Validation Handling": "Manual Validation Handling",
        "Sobald valid() den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "As soon as valid() returns `false`, the values in the given model may be in an erroneous state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually processed in the same route.",
        "File Upload": "File Upload",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "A special property type on the body model can be used to allow the client to upload files. Any number of `UploadedFile` can be used.",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "By default, Router stores all uploaded files in a temp folder and removes them once the code in the route has been executed. It is therefore necessary to read the file in the specified path in `path` and save it to a permanent location (local disk, cloud storage, database).",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet werden, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Validation in an HTTP server is a mandatory functionality, since almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "All inputs such as path parameters, query parameters, and body parameters are automatically validated to the specified TypeScript type. If additional constraints are specified via types from `@deepkit/type`, these are also checked.",
        "Output": "Output",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "A route can return various data structures. Some of them are handled in a special way, such as redirects and templates, and others, such as simple objects, are simply sent as JSON.",
        "JSON": "JSON",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "By default, normal JavaScript values are returned to the client as JSON with the header `application/json; charset=utf-8`.",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "If an explicit return type is specified with the function or method, according to this type the data will be serialized to JSON using the Deepkit JSON Serializer.",
        "HTML": "HTML",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "There are two ways to send HTML. Either the object `HtmlResponse` or Template-Engine with TSX is used.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See the chapter<template>&lt;&gt;.",
        "Custom Content": "Custom Content",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "Besides HTML and JSON it is also possible to send text or binary data with a specific content type. This is done via the object `Response`",
        "Zusätzliche Header": "Additional headers",
        "Um den Header einer Antwort zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "To change the header of a response, additional methods can be called on the objects `Response`, `JSONResponse`, and `HTMLResponse`.",
        "Redirect": "Redirect",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "To return a 301 or 302 redirect as a response, `Redirect.toRoute` or `Redirect.toUrl` can be used.",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "Alternatively, a URL can be redirected to with `Redirect.toUrl`.",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "By default, both use a 302 redirect. This can be customized via the `statusCode` argument.",
        "Scope": "Scope",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "All HTTP controllers and functional routes are managed within the `http` dependency injection scope. HTTP controllers are instantiated accordingly for each HTTP request. This also means that both can access providers registered for the `http` scope. So additionally `HttpRequest` and `HttpResponse` from `@deepkit/http` are usable as dependencies. If Deepkit Framework is used, `SessionHandler` from `@deepkit/framework` is also available.",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "It can be useful to place providers in the `http` scope, for example to instantiate services for each HTTP request. Once the HTTP request has been processed, the `http` scoped DI container is deleted, thus cleaning up all its provider instances from the garbage collector (GC).",
        "Events": "Events",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "The HTTP module is based on a workflow engine that provides various event tokens that can be used to hook into the entire process of processing an HTTP request.",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "The workflow engine is a finite state machine that creates a new state machine instance for each HTTP request and then jumps from position to position. The first position is the `start` and the last one the `response`. Additional code can be executed in each position.",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "Each event token has its own event type with additional information.",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "Since all HTTP events are based on the workflow engine, its behavior can be modified by using the specified event and jumping there with the `event.next()` method.",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "The HTTP module uses its own event listeners on these event tokens to implement HTTP request processing. All of these event listeners have a priority of 100, which means that when you listen for an event, your listener will be executed first by default (since the default priority is 0). Add a priority greater than 100 to run after the HTTP module's event listeners.",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "For example, suppose you want to catch the event where a controller is invoked. When a particular controller is to be invoked, we check if the user has access to it. If the user has access, we continue. But if not, we jump to the next workflow item `accessDenied`. There the procedure of an Access-Denied will be processed automatically.",
        "Security": "Security",
        "Middleware": "Middleware",
        "Resolver": "Resolver",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "The router supports a way to resolve complex parameter types. For example, given a route such as `/user/:id`, this `id` can be resolved to a `user` object outside the route using a resolver. This further decouples the HTTP abstraction and route code, further simplifying testing and modularity.",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "The user does not necessarily have to depend on a parameter here. It could just as well depend on a session or an HTTP header, and only be provided when the user is logged in. In `RouteParameterResolverContext` a lot of information about the HTTP request is available, so many use cases can be mapped this way.",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "In principle, it is also possible to have complex parameter types provided via the Dependency Injection container from the `http` scope, since these are also available in the route function or method. However, this has the disadvantage that no asynchronous function calls can be used, since the DI container is synchronous throughout.",
        "RPC": "RPC",
        "Server": "Server",
        "Client": "Client",
        "Peer To Peer": "Peer To Peer",
        "Connection": "Connection",
        "Entity": "Entity",
        "Session": "Session",
        "Query": "Query",
        "Repository": "Repository",
        "Relations": "Relations",
        "Inheritance": "Inheritance",
        "Index": "Index",
        "Case Sensitivity": "Case Sensitivity",
        "Character Sets": "Character Sets",
        "Collations": "Collations",
        "Batching": "Batching",
        "Caching": "Caching",
        "Multitenancy": "Multitenancy",
        "Transactions": "Transactions",
        "Locking": "Locking",
        "Migration": "Migration",
        "Raw Database Access": "Raw Database Access",
        "Composite Primary Key": "Composite Primary Key",
        "Broker": "Broker",
        "Server/Client": "Server/Client",
        "Key/Value": "Key/Value",
        "Pub/Sub": "Pub/Sub",
        "Template": "Template",
        "Eine TSX basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "A TSX based template engine that can be used to generate HTML in a type-safe way.",
        "Framework": "Framework",
        "Modules": "Modules",
        "Configuration": "Configuration",
        "Application Server": "Application Server",
        "Public Directory": "Public Directory",
        "Logger": "Logger",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Workflow",
        "Testing": "Testing",
        "Debugger": "Debugger",
        "Module": "Modules",
        "Profiler": "Profiler",
        "Deployment": "Deployment",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht das selbe Type-Objekt.": "`MyType<string>` is cached as long as `Object` is computed. The PropertySignature of `a` and `b` thus have the same `type` from the cache, but are not the same Type object.",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "This often seen code represents a bug that can lead to program crash or security vulnerability, since a Type cast `as number` was used that does not provide any collateral at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in the <<serialization>> chapter.",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "In the related chapters (<<cli>>, <<http>>, <<rpc>>, <<database>>) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and do not use `any` to make these validations work well and safely automatically. This can save you a whole lot of manual work to keep the code clean and safe.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type supports custom serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the <<serialization-custom-serialiser>> section.",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "For more complex applications, on the other hand, it is not necessary to manage all dependencies yourself, because that is exactly what a so-called dependency injection container is for. This not only creates all objects automatically, but also \"injects\" the dependencies automatically, so that a manual \"new\" call is no longer necessary. There are various types of injection, such as constructor injection, method injection, or property injection. So even complicated constructions with many dependencies are easy to manage.",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "All types of providers are listed and explained in the <<dependency-injection-providers>> section.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "The `injector` object in this case is the dependency injection container. The `InjectorContext.forProviders` function takes an array of providers in this case. See the <<dependency-injection-providers>> section to learn what values can be passed.",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "The <<framework-modules>> chapter describes this in more detail.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Also, all serialization and validation types from the previous <<validation>> and <<serialization>> chapters can be used to specify in great detail what type and content restrictions an option must have.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "Applications working with the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See the chapter <<cli>>, <<http>>, or <<rpc>> respectively.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "On a positive number, this then works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong input. See the <<validation>> chapter for more information.",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "See the <<framework-modules>> chapter to learn more about app modules.",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "See the <<dependency-injection>> chapter for more information.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its <<serialization>> and <<validation>> features.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "All validation types from `@deepkit/type` can be applied. For more on this, see the <<http-validation>> chapter.",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "Query parameters are values from the URL after the `?` character and can be read with the `HttpQuery<T>` type. The name of the parameter corresponds to the name of the query parameter.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "All validation types from `@deepkit/type` can be applied. See the <<http-validation>> chapter for more details.",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "The properties in the given model can include all TypeScript types and validation types that `@deepkit/type` supports. See the <<serialization>> and <<validation>> chapters for this.",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "To manually validate the body model, a special type `HttpBodyValidation<T>` can be used. It allows to receive invalid body data as well and to react very specifically to error messages.",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "See the <<validation>> chapter for more information on this.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "The `Redirect.toRoute` method uses the route name here. How to set a route name can be seen in the <<http-route-name>> section. If this referenced route (query or path) contains parameters, they can be specified via the second argument:",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "See the <<dependency-injection-scopes>> section to learn how providers can be placed in the `http` scope.",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript is JavaScript that scales. A language designed to implement complex use cases. It allows JavaScript to be written with types that are checked and removed at compile time. This resulting type safety allows for easier writing and maintenance of complex applications. This, among other things, is what has made TypeScript so popular: It allows finding errors in code, especially on a large scale, much faster and easier than would be possible with pure JavaScript - and works with JavaScript rather than against it.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript is now the largest developer community in the world and provides the developer with a correspondingly large choice of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies, API and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer in order for these libraries to work properly with each other at all. The provision of core functions, which are needed by virtually every project, in nicely abstracted libraries brought together in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are only some very well-known and successful examples in addition.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "These frameworks offer the developer often far common and decades proven concepts, which are converted into libraries or components, in order to be able to be used so comfortably among themselves harmonizing demand-fairly. The offered functionalities and design patterns are thereby not cubed, but based on sometimes over decades old concepts, which proved themselves by the fight in the competition with alternative ideas.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript removes its type information completely during the compilation, as soon as TypeScript is converted into JavaScript, so that no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (converted/serialized), data is validated, meta-information is added to objects, or interface information is required. In these and many other use cases, type information can be very useful at runtime because it provides libraries with the information needed to efficiently provide functionality. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript's type system, forcing the developer to write types in a new way that has nothing to do with TypeScript's syntax. The result is that TypeScript's powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "Based on this paradigm shift, Deepkit has developed a whole set of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP router, RPC framework, Logger, Template system, Event system and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. One of the key features of TypeScript, after all, is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale the application architecture with appropriate enterprise patterns.",
        "Type Compiler": "Type Compiler",
        "Validate&lt;typeof MyValidator&gt;": "Validate&lt;typeof MyValidator&gt;",
        "Pattern&lt;typeof MyRegexp&gt;": "Pattern&lt;typeof MyRegexp&gt;",
        "Decimal&lt;number, Number&gt;": "Decimal&lt;number, Number&gt;",
        "Integer": "Integer",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "Dependency Injection (DI) is a design pattern where classes and functions _receive_ their dependencies. It follows the principle of Inversion of Control (IoC) and helps to better separate especially complex code to significantly improve testability, modularity, and clarity. Although there are other design patterns, such as the service locator pattern, to apply the principle of IoC, DI has established itself as the dominant pattern, especially in enterprise software.",
        "Inversion Of Control": "Inversion Of Control",
        "Exit Code": "Exit Code",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "If the type compiler could not be successfully installed automatically (for example because NPM install hooks are disabled), this can be done manually with the following command:",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "`MyType<string>` is cached as long as `Object` is computed. As a result, the PropertySignature of `a` and `b` have the same `type` from the cache, but are not the same Type object.",
        "JIT Cache": "JIT Cache",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type`, either a type object is now stored or an error is thrown if, for example, no type argument was passed, Deepkit's type compiler was not properly installed, or emitting type information is not enabled (see the Installation section above for more on this).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as a `ReflectionOp` enum. At the time of this writing, the command set is over 81 commands in size.",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "The UserRepository class has an HttpClient as a dependency in this. This dependency in itself is nothing remarkable, however it is problematic that UserRepository creates the HttpClient itself. This is obvious at first glance, but it has its drawbacks: What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "In addition to DI, Service Locator (SL) is another way to apply the IoC principle. This is commonly thought of as the counterpart to Dependency Injection, since it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a Service Locator pattern.",
        "File Structure": "File Structure",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Setup calls can also be assigned to an interface.",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Validation in an HTTP server is a mandatory functionality, because almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.",
        "Compiling": "Compiling",
        "Packaging": "Packaging",
        "Docker": "Docker",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "Code can be shared between departments (frontend, backend, microservice, etc).",
        "Models, Typen und Interfaces": "Models, types and interfaces",
        "Business logic": "Business logic",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "A unified audit system of a single package manager.",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "Reuse of known third-party libraries in all departments.",
        "Wissensteilung innerhalb der Teams.": "Knowledge sharing within teams.",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "Recruitment simplifies to one group (and the biggest one too: JavaScript developers).",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*: Number or Bigint accept String, Number, and BigInt, using `parseFloat` or `BigInt(x)` in case of a necessary conversion.",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*: Boolean accepts Number and String. 0, '0', 'false' is interpreted as `false`. 1, '1', 'true' is interpreted as `true`.",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*string*: String accepts Number, String, Boolean, and many more. All non-string values are automatically converted with `string(x)`.",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "The code is easier to understand as all dependencies are explicitly visible.",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "The code is easier to test as all dependencies are unique and can be easily modified if needed.",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "The code is more modular as dependencies can be easily swapped.",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "It promotes the separation of concerns principle, as UserRepository is no longer responsible for creating very complex dependencies themselves when in doubt.",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "High-level modules should not import anything from low-level modules.",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "Implementations should be based on abstractions (interfaces).",
        "Injector API (Low Level)": "Injector API (low level)",
        "App API (Deepkit Framework)": "App API (deepkit framework)",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obig erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht korrekt ist.": "A type guard on the above used type `User` could look in simplest form as follows. Note that the above explained special features with NaN are not part here and therefore this type guard is not correct.",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Primitives": "Primitives",
        "Primary Key": "Primary Key",
        "Auto Increment": "Auto Increment",
        "UUID": "UUID",
        "Embedded Types": "Embedded Types",
        "Default Values": "Default Values",
        "Default Expressions": "Default Expressions",
        "Complex Types": "Complex Types",
        "Database Specific Column Types": "Database Specific Column Types",
        "Session / Unit Of Work": "Session / Unit Of Work",
        "Identity Map": "Identity Map",
        "Find": "Find",
        "Join": "Join",
        "Patch": "Patch",
        "Delete": "Delete",
        "Lift": "Lift",
        "One To Many": "One To Many",
        "Many To Many": "Many To Many",
        "One To One": "One To One",
        "Table Per Class": "Table Per Class",
        "Single Table Inheritance": "Single Table Inheritance",
        "Query Events": "Query Events",
        "Unit Of Work Events": "Unit Of Work Events",
        "Isolations": "Isolations",
        "Naming Strategy": "Naming Strategy",
        "Optimistic Locking": "Optimistic Locking",
        "Pessimistic Locking": "Pessimistic Locking",
        "Custom Types": "Custom Types",
        "Logging": "Logging",
        "SQL": "SQL",
        "App Configuration": "App Configuration",
        "Sessions": "Sessions",
        "Authentication": "Authentication",
        "Read Replica": "Read Replica",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Optional / Nullable",
        "Exclude": "Exclude",
        "Request/Response": "Request/Response",
        "Pagination": "Pagination",
        "Constraints": "Constraints",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Seeding": "Seeding",
        "Plugins": "Plugins",
        "Soft-Delete": "Soft-Delete",
        "Transport Protocol": "Transport Protocol",
        "WebSockets": "WebSockets",
        "TCP": "TCP",
        "Publish / Subscribe": "Publish / Subscribe",
        "JSX / TSX": "JSX / TSX",
        "Filter": "Filter",
        "Equal": "Equal",
        "Greater / Smaller": "Greater / Smaller",
        "RegExp": "RegExp",
        "Grouping AND/OR": "Grouping AND/OR",
        "In": "In",
        "Order": "Order",
        "Aggregation": "Aggregation",
        "Returning": "Returning",
        "Change Detection": "Change Detection",
        "Components": "Components",
        "Function Components": "Function Components",
        "Class Components": "Class Components",
        "Dynamic HTML": "Dynamic HTML",
        "Optimization": "Optimization",
        "Header": "Header",
        "Stream": "Stream",
        "Validation Reporting": "Validation Reporting",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "The functions `is`, `assert` and `validates` return a boolean as result. To get exact information about failed validation rules, the `validate` function can be used. It returns an empty array if everything was validated successfully. In case of errors the array contains one or more entries with the following structure:",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "The function receives as first type argument an arbitrary TypeScript type and as first argument the data to validate.",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "Complex types such as interfaces, classes, or generics can also be used here.",
        "Controller": "Controller",
        "Error Reporting": "Error Reporting",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "the information that `message` is of type string and the return type is of type `void` is no longer available. This information has been irrevocably destroyed by TypeScript.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "At the time of this writing, the Type compiler is a so-called TypeScript transformer. This transformer is a plugin for the TypeScript compiler itself and converts a TypeScript AST (Abstract Syntax Tree) into another TypeScript AST. Deepkit's type compiler reads the AST in this process, produces the associated bytecode, and inserts it into the AST.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "To prevent naming conflicts, each type is given a \"__Ω\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode emits the JavaScript. Classes and functions also get a bytecode directly as a property.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether to recreate HttpClient each time in the process, or use the same one each time, is now decided by the user of the class, rather than by the class itself. It is no longer requested (from the class's point of view) as in the case of the service locator, or created entirely by itself in the initial example. This inverting of the flow has various advantages:",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "Here it is to be noted that although in theory the Dependency Inversion principle has its advantages, so it has in practice also substantial disadvantages. For example, it leads not only to more code (since more interfaces must be written), but also to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-usage factor, which should be thought through before using it.",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "A slightly more complex API is the `InjectorModule` class, which allows the providers to be swapped out into different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import each other, export providers to build a hierarchy and nicely separated architecture.",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Once the Deepkit framework is used, modules are defined using the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. Additionally, it is possible to work with powerful hooks as well as define configuration loaders to map even more dynamic architectures.",
        "The <<framework-modules>> chapter describes this in more detail.": "The <<framework-modules>> chapter describes this in more detail.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This results in classes being recreated each time or factories being executed each time.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "With the combination of an inject alias and primitive provider tokens, dependencies can also be provided from packages that do not contain runtime type information.",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "A function can be used to provide a value for the provider. This function may also include parameters that are in turn provided by the DI container. This allows other dependencies or configuration options to be accessed.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Options that do not have a default value, but are still necessary, can be provided with a `!`. This forces the user of the module to provide the value, otherwise it will result in an error.",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "Instead, a scoped DI container must be created. This would happen every time an HTTP request comes in:",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "To dynamically (depending on the configuration option for example) provide controllers, the `process` hook can be used.",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "Once `valid()` returns `false`, the values in the given model may be in an erroneous state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually evaluated in the same route.",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "A server-side TSX (JSX) based template engine that can be used to generate HTML in a type-safe manner.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "To export all providers by default to the top level, the root module, the option `forRoot` can be used. This allows all providers to be used by all other modules.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since CLI programs in Deepkit are based on runtime types, it is necessary to have @deepkit/type already installed correctly. See <<runtime-types-installation>>.",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "This is very well tailored for simple use cases, but quickly becomes confusing as the application grows, since all input and output must be manually serialized or deserialized and validated. Also, consideration must be given to how objects and services such as a database abstraction can be obtained from the application itself. It forces the developer to put an architecture on top of it that maps these mandatory functionalities.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Deepkit's HTTP library leverages the power of TypeScript and Dependency Injection. Serialization/deserialization and validation of any values happen automatically based on the defined types. Also, it allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of an architecture."
    },
    "chinese": {
        "Einführung": "介绍",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "0/>TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。它可以在开发过程中（但最迟在编译过程中）比纯JavaScript更快、更容易地发现错误，并与JavaScript一起工作，而不是反对它。一个用TypeScript编写的框架，旨在用TypeScript开发非常复杂的软件。它将许多从企业中已知的设计模式带到了TypeScript，并引入了只有TypeScript的新类型系统才能实现的全新功能，以提高开发速度，尤其是在团队中。小型应用程序也可以从这种新方法中受益，因为Deepkit为非常常见的使用情况配备了许多库，可以单独或组合使用。该框架本身被设计成尽可能的敏捷，并在必要的情况下尽可能的复杂，这不仅是为了快速获得初步的结果，也是为了长期保持开发速度。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries nicht nur untereinander einwandfrei funktionieren, sondern auch, dass die vorhandene Komplexität des Projektes effizient in Code gegossen werden kann. Auch ist es sehr schwer Ansprechpartner, gerade im Enterprise-Bereich, zu finden, wenn das Projekt auf tausende third-party Libraries basiert. Teilweise sind Libraries recht schnell nicht mehr richtig gepflegt und man hat entsprechend das Nachsehen, wenn der Fall mal eintritt, dass ein Bug gefunden oder ein Feature entwickelt werden soll.": "JavaScript现在是世界上最大的开发者社区，为开发者提供了相应的许多库和工具的选择，以满足项目的需求。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念和代码质量差别很大，以至于开发人员必须引入大量的胶水代码和额外的抽象，以便这些库不仅能相互正常工作，而且还能将项目的现有复杂性有效地投射到代码中。如果项目是基于数以千计的第三方图书馆，也很难找到联系人，特别是在企业部门。在某些情况下，库不再得到适当的维护，如果发现一个错误或需要开发一个功能，你将一无所获。",
        "Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "近几十年来，制造商或社区将几乎每个项目都需要的核心功能提供给精美的抽象库，并将其汇集到一个框架中，这一点已被反复证明。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten gegossen sind, um so bequem, untereinander harmonierend, und bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念被投在库或组件中，以便它们可以方便地使用，相互协调，并根据需要使用。所提供的功能不是切块的，而是基于有时是几十年前的概念，并且在与其他想法的竞争中证明了自己。",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript在这些年里取得了巨大的进步，因此与此同时，越来越多来自企业环境的设计模式可以被应用。在越来越多的库、框架和工具中可以找到的设计模式。然而，JavaScript和TypeScript有一个问题，即为了有效地应用许多已被证实的企业模式，语言本身缺少决定性的功能。这并不意味着这些设计模式不能被普遍应用，而是说它们的效率不如当前的其他语言。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (de-/serializer), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, die sie brauchen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译时完全删除了它的类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中和运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据被转换（de/serialised）、数据被验证、元信息被添加到对象中，或者在运行时需要接口信息的地方，这个值会被反映出来。在这些和其他许多用例中，运行时的类型信息可能非常有用，因为它为库提供了它们所需要的信息。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里无法再显示出它的优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit开发了一种类型编译器，将类型信息留在原地，允许在运行时计算动态类型，并在运行时读取现有类型信息。随着这种模式的转变，全新的工作方式成为可能，为上述用例提供了所需的信息，从根本上简化了复杂软件的开发，并赋予代码更多的表现力。第一次有可能在运行时使用TypeScript的全部功能和表现力。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikations-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种模式的转变，Deepkit开发了一整套用于几乎所有程序中都能找到的用例库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发人员需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit由两个主要领域组成。首先是Deepkit库和Deepkit框架。Deepkit库是一整个独立的TypeScript库（NPM包）家族，它们擅长一个主题，并经过优化、测试，旨在以最佳方式相互补充。一个项目可以使用单独的Deepkit库，也可以使用整个Deepkit框架，后者汇集了这些库的所有功能，并以调试器等附加工具对其进行补充。总之，它使开发人员能够建立复杂、快速和可生产的应用程序。",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit支持一系列的使用案例。从简单的命令行工具（CLI程序）到网络应用和微服务再到桌面或移动应用。这些代码被设计成可以在任何已知的JavaScript引擎（浏览器以及NodeJS）中运行，并与Angular、React和Vue等其他框架完美整合。",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "Deepkit Framework背后的主张是应用干净的代码、SOLID原则和企业设计模式，不仅提供高质量的代码，而且让用户也能应用它们。另外，Deepkit试图在其文档和示例中推广这些相同的原则，但并不强迫开发者自己遵循这些原则。",
        "High-Performance": "高性能",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "软件开发中最困难的问题之一是在数月或数年后仍能保持较高的开发速度，特别是随着代码和团队的成长。有许多框架承诺快速启动，用它们可以在很短的时间内组装出更复杂的应用程序。然而，他们通常有一个共同的问题，即项目越老或团队越大，开发速度就会急剧下降。即使在几个月后，只有少数几个开发人员，开发速度也会崩溃，以至于下降到原来速度的1%，这种情况并不罕见。",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "为了抵制这种现象，有必要应用既定的设计模式，并提前使用正确的框架和库。企业设计模式已经确立了自己的地位，因为它们即使在较大的应用程序和大型团队中也能出色地扩展。正确地应用，它们会发展出自己的能力，特别是当一个项目要在较长的时间内（几个月到几年）开发时。",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "设计模式在理论上有其优点，但在实践中，几乎每一种模式也有其缺点。这些缺点根据语言和框架的不同而表现得不同，因为语言和框架本身决定了一个模式的应用是否符合人体工程学。仅仅因为某种模式可以应用于某种语言，并不意味着它可以自动地使开发变得更好、更快。",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel kann wie bereits oben ausgeführt Typescript-Dekoratoren mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "有些语言比其他语言更适合应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在其核心中使用，但有一些限制，大量损害用户体验，从而影响速度。例如，如上所述，如果一个依赖注入框架指定了这个框架并以其为基础，那么Typescript装饰器及其所有的特异性就可能成为必要。",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit的运行时类型系统确保以最符合人体工程学的方式和尽可能少的模板来应用这些设计模式，释放它们的力量，以便不仅在最初，而且在长期保持高开发速度。",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "TypeScript的最大优势之一是在许多用例中可以更好地编写复杂代码。这包括前端、后端、CLI工具、移动和桌面应用程序，以及更多。当一个项目跨越了这些用例并几乎完全依赖TypeScript时，它被称为Isomorphic TypeScript。在尽可能多的代码中使用TypeScript可以极大地提高开发速度。",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit框架及其运行时类型系统旨在最大限度地利用Isomorphic TypeScript的这些以及更多的优势，从而使其最大的力量凸显出来。",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "双栈（不同语言的前端和后端）等老方法已经远远跟不上了，因为仅语言之间的上下文切换就已经花费了巨大的精力和时间。所有其他已经解释过的优点甚至使它成为一个不公平的比较。像TypeScript这样的同构技术栈，如果应用得当，在基本层面上比任何后端/前端的双栈组合（如Java/JavaScript、PHP/JavaScript，甚至JavaScript/JavaScript）的开发时间快很多倍。由于更高的开发速度也意味着同样的功能需要更少的时间，这也意味着Isomorphic TypeScript可以节省资金。除了已经介绍的所有好处，这也是在所有下一步尤其是商业项目中使用Isomorphic TypeScript的杀手锏。",
        "pageBreak:": "pageBreak:",
        "Runtime Types": "运行时类型",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Dekoratoren zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "在TypeScript中提供运行时的类型信息变化很大。它允许采用新的工作方式，而这在以前只能以迂回的方式或根本不可能实现。声明类型和模式已经成为现代开发过程中的一个重要部分。GraphQL、验证器、ORM、ProtoBuf等编码器以及其他许多东西都依赖于在运行时有模式信息可用，以提供基本功能。这些工具和库有时需要开发人员学习全新的语言，这些语言是专门为使用情况开发的。例如，ProtoBuf和GraphQL有自己的声明语言，验证器通常基于自己的模式API，甚至是JSON模式，这也是一种独立的定义结构的方式。其中一些需要在每次更改时运行代码生成器，以便将模式信息也提供给运行时。另一个著名的模式是使用实验性的TypeScript装饰器，在运行时向类提供元信息。",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "但这一切有必要吗？TypeScript提供了一个非常强大的语言来描述甚至非常复杂的结构。事实上，TypeScript现在是游刃有余的，这大致意味着理论上任何种类的程序都可以映射到TypeScript中。当然，这有其实际的局限性，但重要的一点是，TypeScript能够完全取代任何声明格式，如GraphQL、ProtoBuf、JSON Schema和许多其他格式。在运行时与类型系统相结合，有可能涵盖所有描述的工具和它们在TypeScript本身的使用情况，而不需要任何代码生成器。但是，为什么仍然没有确切的解决方案呢？",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "从历史上看，TypeScript在最近几年经历了巨大的变化。它已经被完全重写了好几次，获得了基本的功能，并经历了一系列的迭代和突破性变化。然而，与此同时，TypeScript已经达到了产品市场的契合度，大大减缓了基本创新和突破性变化发生的速度。TypeScript已经证明了自己，并展示了像JavaScript这样的高度动态语言的高度迷人的类型系统应该是什么样子。市场感激地接受了这一推动，并迎来了用JavaScript开发的新时代。",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "此时正是在语言本身的基础上建立工具的好时机，使上述情况成为可能。Deepkit希望成为推动力，将几十年来来自Java和PHP等语言企业的成熟设计模式不仅从根本上引入TypeScript，而且以一种新的、更好的方式与JavaScript一起工作，而不是反对它。通过运行时的类型信息，这些现在第一次不仅在原则上是可能的，而且允许全新的更简单的设计模式，这在Java和PHP等语言中是不可能的。",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "在运行时读取类型信息是Deepkit建立其基础的能力，TypeScript本身已经在这里奠定了基础，通过全新的方法与经过测试的方法有力地结合，大大简化了开发人员的生活。Deepkit库的API主要集中在使用尽可能多的TypeScript类型信息，以达到尽可能的高效。运行时的类型系统意味着类型信息在运行时是可读的，动态类型是可计算的。这意味着，例如，对于类的所有属性和对于函数的所有参数和返回类型都可以被读出。",
        "Nehmen wir als Beispiel diese Funktion:": "以这个函数为例：",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "在JavaScript本身，有几个信息可以在运行时被读出。例如，函数的名称（如果没有用最小化器修改）：",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "另一方面，可以读出参数的数量：",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "只要多写一点代码，也可以读出参数的名称。然而，如果没有一个简陋的JavaScript解析器或对log.toString()的正则表达法，这是不可能做到的，所以就这样了。由于TypeScript将上述函数翻译成JavaScript，如下：",
        "sind die Informationen, dass message vom Typ string und der Return-Typ vom Type void ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "消息是字符串类型，返回类型是void类型的信息已不再可用。",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "安装Deepkit的运行时类型系统需要两个包。`@deepkit/type-compiler`中的类型编译器和`@deepkit/type`中的必要运行时间。类型编译器可以安装在`package.json`_devDependencies_中，因为它只在构建时需要。",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Dekoratoren verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "运行时类型信息默认不生成。必须在`tsconfig.json`文件中设置`\"反射\": true`，以便在该文件同一文件夹的所有文件或所有子文件夹中启用。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。这对于使用`@deepkit/type`来说并不是严格必要的，但对于其他deepkit库和`@deepkit/framework`中的某些功能来说是必要的。",
        "_Datei: tsconfig.json_": "_文件：tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in` node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript本身并不允许你通过`tsconfig.json`来配置类型编译器。有必要直接使用TypeScript编译器API或像Webpack这样带有_ts-loader_的构建系统。为了避免Deepkit用户走这条不方便的路，一旦`@deepkit/type-compiler`被安装，Deepkit类型编译器就会自动安装在`node_modules/typescript`中（这是通过NPM安装钩子完成的）。",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "这使得所有访问本地安装的TypeScript（`node_modules/typescript`中的）的构建工具都能自动启用类型编译器。这使得_tsc_、Angular、webpack、_ts-node_和其他一些工具能够自动与deepkit类型编译器一起工作。",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgenden Kommando nachgeholt werden:": "如果类型编译器不能成功地自动安装（例如，由于NPM安装钩子被禁用），这可以通过以下命令手动完成：",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "注意，如果本地的typecript版本已经更新（例如，如果软件包中的typecript版本。",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "如果要在webpack构建中使用类型编译器，可以使用`ts-loader`包（或任何其他支持transformer注册的类型脚本加载器）来完成。）",
        "_Datei: webpack.config.js_": "_文件：webpack.config.js_",
        "Typen-Dekoratoren": "Type-decorators",
        "Typen-Dekoratoren sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um meist zur Laufzeit das Verhalten festzulegen. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden.  Die Datenbank Library kann diese Information nutzen, um die korrekten SQL Queries zu erstellen.": "Type-decorators是普通的TypeScript类型，包含元信息，主要用于在运行时指定行为。例如，一个类属性可以被标记为主键、引用或索引。  数据库库可以使用这些信息来创建正确的SQL查询。",
        "Es können auch Validator-Einschränkungen wie zum Beispiel MaxLength, Maximum, oder Positive an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist.": "Validator约束，如MaxLength、Maximum或Positive，也可以被添加到任何类型。我们也可以告诉序列化器如何序列化或反序列化一个特定的值。",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Dekoratoren, die alle direkt aus @deepkit/type benutzt werden können. Sie sind designt, nicht aus einer bestimmten Library zu kommen, um so Typen nicht an eine Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppelt. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Dekoratoren genutzt werden.": "Deepkit附带了一系列的类型装饰器，所有这些都可以直接从@deepkit/type中使用。它们被设计成不来自于某个特定的库，所以类型不必与Deepkit RPC或Deepkit Database这样的库耦合。这使得类型的重用更加容易，甚至在前端也是如此，尽管数据库类型装饰器被使用，例如。",
        "Enhanced Types": "Enhanced Types",
        "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .": "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .",
        "Meta": "Meta",
        "MapName, Group, Data, Entity, InlineRuntimeType.": "MapName, Group, Data, Entity, InlineRuntimeType。",
        "Serializer": "Serializer",
        "Excluded, Embedded.": "Excluded, Embedded.",
        "Database": "Database",
        "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "为了直接处理类型信息本身，这里有两个基本变种。类型对象和反思类。下面将讨论反思类。函数`typeOf`返回类型对象，它是非常简单的对象字面。它总是包含一个`kind'，这是一个数字，通过枚举`ReflectionKind'获得其含义。`ReflectionKind`在包`@deepkit/type`中定义如下：",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "有许多可能的类型对象可以被返回。其中最简单的是`never`、`any`、`unknown`、`void、null`和`undefined`，其表示方法如下：",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "例如，数字0是`ReflectionKind`枚举的第一个条目，在这里是`never`，数字1是第二个条目，这里是`any`，以此类推。因此，原始类型如`string`、`number`、`boolean`被表示为：",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "这些相当简单的类型在类型对象处没有进一步的信息，因为它们被直接作为类型参数传递给`typeOf`。然而，如果类型是通过类型别名传递的，额外的信息可以在类型对象中找到。",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "在这种情况下，类型别名`title`的名字也会出现。如果一个类型别名是一个泛型，那么传递的类型也将在类型对象处可用。",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "如果传递的类型是一个索引访问操作的结果，那么容器和索引类型将出现：",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "接口和对象字面都作为Reflection.objectLiteral输出，并包含`types`数组中的属性和方法。",
        "Index Signatures sind ebenfalls in dem `types` array.": "索引签名也在 \"types \"数组中。",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "类类似于对象字面，除了 \"classType \"是对类本身的引用外，它们的属性和方法也在 \"types \"数组中。",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "注意，类型已经从Reflection.propertySignature变为Reflection.property，Reflection.methodSignature变为Reflection.method。由于类上的属性和方法有额外的属性，这些信息也可以被检索到。后者还包括`visibility`、`abstract`和`default`。",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "类的类型对象只包括类本身的属性和方法，不包括超类的属性和方法。这与接口/对象文字的类型对象相反，后者将所有父类的所有属性签名和方法签名解析为 \"类型\"。要解决超类的属性和方法，可以使用ReflectionClass及其`ReflectionClass.getProperties()`（见下面的章节）或`@deepkit/type`的`resolveTypeMembers()`。",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "有一大堆类型对象。例如，对于字面意思、模板字面意思、承诺、枚举、联合、数组、元组等等。要想知道哪些类型都存在，有哪些信息，建议从`@deepkit/type`中导入`type`。它是一个具有所有可能的子类型的 \"union\"，如TypeAny、TypeUnknonwn、TypeVoid、TypeString、TypeNumber、TypeObjectLiteral、TypeArray、TypeClass，以及更多。确切的结构可以在那里找到。",
        "Type Cache": "类型缓存",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "一旦没有传递通用参数，类型对象就会被缓存到类型别名、函数和类。具体来说，这意味着对`typeOf<MyClass>()`的调用将总是返回相同的对象。",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "但是只要使用Generic类型，新的对象将总是被创建，即使传递的类型总是相同。这是因为理论上有无限多的组合是可能的，所以缓存实际上是一种内存泄漏。",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "然而，只要一个类型被多次实例化为递归类型，它就会被缓存起来。然而，缓存的持续时间只限于计算类型的时刻，此后就不存在了。另外，虽然Type对象被缓存了，但返回的是一个新的引用，并不是完全相同的对象。",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht das selbe Type-Objekt.": "`MyType<string>`被缓存了，只要`Object`被计算了。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "所有非根Type对象都有一个父属性，它通常指向包围的父。",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "`Ref 1`指向实际的联合类型对象。",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "在缓存类型对象的情况下，如上所述，`parent`属性并不总是真正的父对象。所以，例如，对于一个多次使用的类，虽然`types`中的即时类型（TypePropertySignature和TypeMethodSignature）指向正确的TypeClass，但这些签名类型的`type`指向缓存条目的TypeClass的签名类型。知道这一点很重要，这样就不会无限地读取父结构，而只读取直接的父结构。父类没有无限精度是由于性能的原因。",
        "JIT cache": "JIT缓存",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "在进一步的课程中，描述了一些经常基于Type对象的函数和特性。为了以一种高性能的方式实现其中的一些内容，需要对每个类型对象进行JIT缓存（just in time）。这可以通过`getJitContainer(type)`提供。这个函数返回一个简单的对象，上面可以存储任何数据。只要不保留对该对象的引用，只要Type对象本身也不再被引用，它就会通过GC自动删除自己。",
        "Reflection-Klassen": "反射类",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "除了`typeOf<>()`函数，还有各种反射类，它们提供了Type对象的OOP替代品。反射类只适用于类、界面/对象字面和函数以及它们的直接子类型（属性、方法、参数）。所有更深层次的类型必须再次用Type对象来读取。",
        "Typeninformation empfangen": "接收类型信息",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "为了提供自己对类型进行操作的函数，提供给用户手动传递一个类型可能是有用的。例如，在一个验证函数中，提供要请求的类型作为第一个类型参数和要验证的数据作为第一个函数参数可能是有用的。",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "为了让这个函数接收类型`string`，它必须告诉类型编译器这一点。",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType`与第一个类型参数`T`的引用给类型编译器发出信号，任何对`validate`的调用应该把类型放在第二位（因为`type`被声明在第二位）。为了在运行时读出信息，使用了`resolveReceiveType`函数。",
        "Es ist nützlich, das Ergebnis der selben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typenkompiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "将结果分配给同一个变量是很有用的，这样就不会不必要地创建一个新变量。在`type`中，要么现在就存储一个类型对象，要么就抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有启用类型信息的发射（见上面的安装部分）。",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "为了详细了解Deepkit如何编码和读取JavaScript中的类型信息，本章旨在介绍。",
        "Typen-Compiler": "类型编译器",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "类型编译器（在@deepkit/type-compiler中）负责读取TypeScript文件中定义的类型并将其编译为字节码。这个字节码拥有在运行时执行类型所需的一切。",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "在本书出版时，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，可以将一个TypeScript AST转化为另一个TypeScript AST。Deepkit的类型编译器在这个过程中读取AST，产生相关的字节码，并将其插入AST中。",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript本身不允许你通过tsconfig.json来配置这个插件，又称转化器。要么直接使用TypeScript编译器API，要么使用Webpack这样的构建系统与`ts-loader`。为了避免 Deepkit 用户的这种不便，在安装 `@deepkit/type-compiler` 时，Deepkit 类型编译器会自动安装在 `node_modules/typescript` 中。这使得所有访问本地安装的TypeScript（即`node_modules/typescript`中的那个）的构建工具都能自动启用类型编译器。这使得tsc、Angular、webpack、ts-node和其他一些工具能够自动与Deepkit的类型编译器一起工作。",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "如果没有启用NPM安装脚本的自动运行，因此本地安装的类型脚本不会被修改，如果你想，这个过程必须手动运行。另外，类型编译器也可以在webpack等构建工具中手动使用。",
        "Bytecode Encoding": "字节码编码",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "字节码是虚拟机的命令序列，在JavaScript中被编码为引用数组和字符串（实际的字节码）。",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlessatz über 81 Befehle gross.": "现有的命令本身是一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`枚举。在写这篇文章的时候，命令集的大小超过了81条。",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "一连串的命令被编码为一个字符串，以节省内存。因此，一个类型`string[]`被概念化为一个字节码Program`[string, array]`，它有字节`[5, 37]`，并使用以下算法进行编码：",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "据此，5成为`&`字符，37成为`F`字符。",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__&#8486;\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "为了防止命名冲突，每个类型都有一个\"__&#8486; \"作为前缀，这些都成为\"&F\"，并在Javascript中以\"['&F']\"的形式发出。对于每个明确定义的、被导出的或被导出的类型所使用的类型，一个字节码会发射出JavaScript。类和函数也可以直接接收字节码作为属性。",
        "Virtuelle Maschine": "虚拟机",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "运行时虚拟机（在`@deepkit/type`类的处理器中）负责解码和执行编码的字节码。它总是返回一个类型对象，见上面的Reflection部分。",
        "Validation": "验证",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation是检查数据正确性的过程。如果类型是正确的，并且满足了其他定义的限制，那么正确性就得到了。Deepkit通常区分类型验证和附加约束的验证。",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "只要数据来自被认为不安全的来源，就会使用验证。不确定意味着不能对数据的类型或内容做出有保障的假设，因此数据在运行时可能具有字面上的任何价值。",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "因此来自用户输入的数据通常不被认为是安全的。来自HTTP请求（查询参数、正文）、CLI参数或读入文件的数据必须被验证。如果一个变量被声明为数字，其中也必须有一个数字，否则程序会崩溃或出现安全漏洞。",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "例如，在一个HTTP路由的控制器中，首要任务是检查每个用户的输入（查询参数，正文）。特别是在TypeScript环境中，不要使用类型转换，因为它们从根本上是不安全的。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个类型转换`作为数字`，在运行时没有提供任何安全。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "在相关章节（<<cli>>, <<http>>, <<rpc>>, <<database>>）中，我们详细解释了什么时候验证会自动进行。确保你知道在什么地方必须定义限制或类型，不要使用`any`，这样这些验证就能很好地自动安全工作。这可以为你节省大量的手工工作，以保持代码的干净和安全。",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "验证器的基本功能是检查一个值的类型。例如，一个值是否是一个字符串。这不是关于字符串包含什么，只是它的类型。在Typescript中有很多类型：字符串、数字、布尔值、大数、对象、类、接口、泛型、映射类型等等。通过Typescript强大的类型系统，可以提供大量不同的类型。",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "在JavaScript本身，原始类型可以用`typeof`操作符进行解析。对于更复杂的类型，如接口、映射类型或通用集合/映射，这就不再那么容易了，因此需要一个验证器库，如`@deepkit/type`。Deepkit是唯一允许直接验证所有TypesScript类型而不走弯路的解决方案。",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "`username`的类型是字符串。如果验证器要检查变量`username`是否是一个字符串，这可以很容易地用JavaScript本身完成。",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "因此，函数`isString`可以被看作是一个类型验证器。然而，在JavaScript本身，当需要检查数字时，就会变得更加困难。有一些特殊的功能，比如当一个无效的字符串被转换为数字时，NaN（\"不是数字\"）。",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "运算符`typeof`返回Number，尽管它的值是NaN（\"不是数字\"），字面意思是说它不想成为一个数字。从这里开始，必须进行特殊的额外检查，如`isNaN()`，而且很快就会发现使用外部库，如Deepkit，它会自动考虑到这些特殊性。",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "在Deepkit中，类型验证可以通过`validate`、`is`或`assert`函数进行。函数`is`是一个所谓的类型保护，`assert`是一个类型断言。",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "函数`validate`返回一个发现错误的数组，如果成功则返回一个空数组。这个数组中的每个条目都描述了确切的错误代码和错误信息以及路径，只要更复杂的类型，如对象或数组得到验证。",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "这三个函数的使用大致相同。类型被指定或引用为第一个类型参数，数据作为第一个函数参数被传递。",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "当处理更复杂的类型如类或接口时，数组也可以包含几个条目。",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "验证器也支持深度递归类型。路径然后用一个点隔开。",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "利用TypeScript为你提供的好处。因此，更复杂的类型，如 \"用户\"，可以在多个地方重复使用，而不必一次又一次地声明。例如，如果一个 \"用户 \"要在没有 \"id \"的情况下被验证，TypeScript的工具可以被用来快速有效地创建派生的子类型。为了保持DRY（Don't Repeat Yourself）。",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit是唯一能够在运行时以这种方式访问TypeScripts类型的主要框架。如果你想在前端和后端使用类型，可以将类型外包给一个单独的文件，从而在任何地方都可以导入。",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "TypeScript中的类型转换（与类型保护相反）在运行时不是一个构造，而只是在类型系统本身中处理。",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "代码 \"as string \"在此并不安全，它是为未知数据分配类型的一种方式。变量`data`实际上可以有任何值，例如`{username: 123}`，甚至`{}`，这将导致`username`不是一个字符串，而是完全不同的东西，因此代码`username.startingWith('@')`将导致一个错误，所以在最坏的情况下，程序会崩溃。为了保证在运行时`data`有一个类型为String的属性`username`，必须使用类型保护。",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "类型保护是给TypeScript一个提示，告诉它在运行时保证传递的数据有什么类型。掌握了这些知识，TypeScript就会随着代码的进展完善（\"缩小\"）该类型。  例如，`any`可以以安全的方式变成字符串或其他类型。",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "因此，如果有数据的类型不知道（`any`或`unknown`），类型保护有助于根据数据本身更精确地缩小范围。然而，类型保护只有在其实施时才是安全的。如果你犯了一个错误，这可能会产生严重的后果，因为基本的假设突然变成了不真实的。",
        "Type-Guard": "类型防护",
        "Ein Type-Guard auf den obige genutzten Typen User könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obig erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht korrekt ist.": "上面使用的类型用户的类型防护，其最简单的形式是这样。请注意，上面用NaN解释的特殊功能不属于这个范围，因此这个类型保护器是不正确的。",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "类型保护器总是返回一个布尔值，通常直接用于If操作。",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "为每个类型保护器编写一个单独的函数，特别是对于更复杂的类型，然后在每次类型改变时调整它是非常繁琐的，容易出错，而且没有效率。因此，Deepkit提供了函数`is`，它为任何TypeScript类型自动提供了一个类型保护器。这就自动考虑到了一些特殊的特点，比如上面提到的NaN的问题。函数`is`的作用与`validate`相同，但它不是返回一个错误数组，而是简单地返回一个布尔值。",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "经常可以发现的一种模式是，如果验证失败，直接返回一个错误，这样就不会执行后续的代码。这可以在不同的地方使用，而不改变代码的完整流程。",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "另外，还可以使用TypeScript类型断言。如果给定的数据不能正确验证为一个类型，函数`assert`会自动抛出一个错误。函数的特殊签名，区别于TypeScript的类型断言，有助于TypeScript自动细化（'缩小'）传递的变量。",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "再次，利用TypeScript为他们提供的好处。类型可以被各种TypeScript函数重用或定制。",
        "Einschränkungen": "约束",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "除了检查类型，其他任意的约束可以被添加到一个类型。这些额外的内容约束的检查是在类型本身被检查后自动完成的。这是在所有验证函数中进行的，如`validate`、`is`和`assert`。一个限制可以是，例如，一个字符串必须有一定的最小或最大长度。",
        "Diese Einschränkungen werden über die Typen-Dekorationen an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Dekoratoren können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "这些限制是通过类型装饰添加到实际的类型中。有一整套可以使用的装饰品。如果需要扩展，可以随意定义和使用自己的装饰器。",
        "Mit `&` können beliebig viele Typen-Dekoratoren an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "用`&`可以在实际的类型上添加任意数量的类型装饰器。结果，这里是`username'，然后可以在所有的验证函数中使用，但也可以在其他类型中使用。",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "函数`validate'给出了有用的错误信息，这些信息来自于限制。",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "例如，这些信息也可以奇妙地自动显示在表单上，并通过`code'翻译。使用对象和数组的现有路径，表单中的字段可以过滤出并显示适当的错误。",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "一个经常有用的用例也是用一个正则约束来定义一个电子邮件。一旦定义了类型，就可以在任何地方使用。",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "可以添加任何数量的约束。",
        "Constraint Types": "约束类型",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "使用自定义验证函数进行验证。",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "定义一个正则表达式作为验证模式，更多信息见下一节自定义验证器。通常用于电子邮件验证或更复杂的内容验证。",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "验证字母字符（a-Z）。",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "验证字母和数字字符。",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "验证ASCII字符。",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "验证代表十进制数字的字符串，如0.1，.3，1.1，1.00003，4.0等。",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "验证数字是给定数字的倍数。",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "验证数组或字符串的最小/最大长度。",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "验证一个数组项或子字符串被包括/排除",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "验证一个值是最小或最大的给定数字。与`>=`和`&lt;=`相同。",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "与最小/最大值相同，但不包括值本身。",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date).",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "通过`/^\\S+@\\S+$/`对电子邮件进行简单的regexp验证。",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "确保数字是正确范围内的整数，所以不需要做 \"string & Email\"。是自动的 \"数字\"，所以不需要做 \"数字和整数\"。",
        "See Special types: integer/floats for more information": "更多信息见特殊类型：整数/浮点",
        "Benutzerdefinierte Validator": "自定义验证器",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "如果内置的验证器不够用，可以通过`Validate`装饰器创建和使用自定义验证器函数。",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "请注意，你的自定义验证器函数是在所有内置类型验证被调用后执行。如果一个验证器失败了，当前类型的所有后续验证器都被省略。每个类型只可能有一次失败。",
        "Generic Validator": "通用验证器",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "在验证器函数中，类型对象是可用的，可以使用验证器来获得更多关于类型的信息。也有一种方法可以定义任何必须传递给验证类型的验证器选项，使验证器可配置。有了这些信息及其父级引用，就可以创建强大的通用验证器。",
        "Serialisation": "序列化",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "序列化是将数据类型转换为适合传输或存储的格式的过程，例如。反序列化是撤销这一过程。这是无损完成的，这意味着数据可以在不丢失数据类型信息或数据本身的情况下转换为序列化目标。",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet.": "在JavaScript中，序列化通常在JavaScript对象和JSON之间完成。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），反之亦然，如果服务器将数据作为JSON发送到客户端。",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "这个序列化过程对于非琐碎的数据是绝对必要的，因为JSON甚至对于像日期这样的基本类型都会丢失其信息。一个 \"新日期 \"最终被序列化为JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "中的字符串，可以看出，JSON.stringify的结果是一个JSON字符串。如果再次用JSON.parse反序列化，结果不是一个`日期'对象，而是一个字符串。",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "尽管有各种变通方法来教JSON.parse反序列化日期对象，但它们容易出错，而且性能很差。为了使这种情况和许多其他类型的类型安全的序列化和反序列化，需要一个序列化过程。",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "有四个主要功能。`serialize`, `cast`/`deserialize`和`validatedDeserialize`。在这些函数的引擎盖下，默认使用`@deepkit/type`的全局可用的JSON序列化器，但也可以使用自定义的序列化目标。",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type支持自定义的序列化目标，但已经配备了一个强大的JSON序列化目标，可以将数据序列化为JSON对象，然后可以使用JSON.stringify正确、安全地转换为JSON。通过`@deepkit/bson`，BSON也可以作为一个序列化目标。如何创建一个自定义的序列化目标（例如为数据库驱动），可以在<<序列化-自定义序列化器>>一节中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten validieren, um sicherzustellen, dass diese auch umgewandelt werden können, diese Validierung nicht dieselbe ist wie in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "注意，尽管序列化器也会验证数据以确保其可以被转换，但这种验证与<<验证>>一章中的验证是不同的。只有`cast`函数在成功反序列化后还会调用完整的验证过程，如果数据无效就会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "另外，`validatedDeserialize`也可以用来在反序列化后进行验证。另一种方法是手动调用`validate'或`validates'函数来处理来自`deserialize'函数的反序列化数据，详见<<validation>>章节。",
        "Alle Funktionen aus den Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "所有来自序列化和验证的函数在出错时都会从`@deepkit/type`中抛出一个`ValidationError`。",
        "Deserialisierung": "反序列化",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "`deserialize`函数默认使用JSON序列化器将传递的数据转换为适当的指定类型。JSON序列化器希望得到一个JSON对象，即字符串、数字、布尔值、对象或数组。",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "如果已经传递了正确的数据类型（例如，在`created'的情况下是一个Date对象），那么这将被视为是。",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "不仅是一个类，而且任何TypeScript类型都可以被指定为第一个类型参数。因此，即使是基元或非常复杂的类型也可以被传递：",
        "Weiche Typenkonvertierung": "软类型转换",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserialisierer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "软类型转换是在反序列化过程中实现。这意味着String和Number的字符串类型或Number的字符串类型可以被接受并自动转换。这很有用，例如，当数据通过一个URL被接受并传递给反序列化器时。由于URL总是一个字符串，Deepkit Type仍然会尝试解决Number和Boolean的类型。",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serialiser eingebaut:": "JSON序列化器中内置了以下软类型转换：",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "也可以禁用软转换：",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "如果数据是无效的，它将不会尝试转换，而是抛出一个错误消息。",
        "Serialisierung": "序列化",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "函数`serialize`根据默认情况用JSON序列化器将传递的数据转换为JSON对象，即：字符串、数字、布尔值、对象或数组。然后可以使用JSON.stringify将其结果安全地转换为JSON。",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Todo": "Todo",
        "Dependency Injection": "依赖注入",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten": "Dependency Injection（DI）是一种设计模式，类和函数接受其依赖性",
        "_empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\")": "_。它遵循控制反转（IoC）",
        "und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität,": "的原则，有助于更好地分离复杂的代码，以显著提高可测试性、模块化",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "为了说明IoC的原则，这里有一个例子：",
        "Die Klasse UserRepository hat dabei als Abhängigkeit einen HttpClient. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "UserRepository类有一个HttpClient作为依赖关系。这个依赖关系本身并不显眼，但UserRepository自己创建了HttpClient，这就有问题了。乍一看，这似乎很明显，但它有其缺点。如果我们想替换掉HttpClient怎么办？如果我们想在单元测试中测试UserRepository，而不允许真正的HTTP请求出去呢？我们怎么知道这个类根本就在使用HttpClient呢？",
        "Inversion of Control": "控制反转",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "在控制反转（IoC）的思想中，有以下的替代变体，它将HttpClient设置为构造函数中的显式依赖（也称为构造函数注入）。",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "现在UserRepository不再负责创建HttpClient，但UserRepository的用户负责。这就是反转控制（IoC）。控制权已被逆转或颠倒。具体来说，这段代码使用了依赖注入，因为依赖被接收（注入），不再创建或请求。依赖注入只是应用IoC的一种方式。",
        "Service Locator": "服务定位器",
        "Neben DI ist auch ein Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "除了DI之外，服务定位器（SL）是应用IoC原则的另一种方式。这通常被认为是与依赖性注入相对应的，因为它请求依赖性而不是接受它们。如果HttpClient在上述代码中被请求如下，就会说到服务定位器模式。",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "函数`locator.getHttpClient`可以有一个完全任意的名字。替代品是函数调用，如`useContext(HttpClient)`、`getHttpClient()`、`await import(\"client\")`，或容器调用，如`container.get(HttpClient)`。全局的导入是服务定位器的一个稍微不同的变体，使用模块系统本身作为定位器：",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "所有这些变体的共同点是它们明确请求依赖HttpClient。这种要求不仅可能发生在作为默认值的属性上，也可能发生在代码中间的某个地方。因为在代码的中间意味着它不是类型接口的一部分，所以HttpClient的使用是隐藏的。根据HttpClient被请求的方式的不同，有时候用另一种实现来替换它是非常困难的，或者是完全不可能的。特别是在单元测试领域，为了清晰起见，这里会出现困难，所以现在服务定位器在某些情况下被归类为反模式。",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "在依赖注入中，没有任何东西被请求，但它是由用户明确提供或由代码接收。从控制反转的例子中可以看出，依赖注入模式已经在那里得到了应用。具体来说，在这里可以看到构造函数注入，因为依赖关系是在构造函数中声明的。所以UserRepository现在必须如下使用。",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes mal neu erstellt oder jedes mal der selbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "想要使用UserRepository的代码也必须提供（注入）所有的依赖。每次是否要重新创建HttpClient，或者每次是否要使用同一个HttpClient，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被要求（从类的角度），或者在最初的例子中，完全由类本身创建。这种倒置的流程有各种优点：",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "但也可以直接认识到一个明显的缺点。我真的要自己创建或管理像HttpClient这样的所有依赖性吗？是的，有很多情况下，自己管理依赖关系是完全合法的。一个好的API的特点是，依赖性不会失控，即使如此，它们仍然是令人愉快的使用。对于许多应用程序或复杂的库，这很可能是一种情况。",
        "Dependency Injection Container": "依赖注入容器",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "另一方面，对于更复杂的应用程序，没有必要自己管理所有的依赖，因为这正是所谓的依赖注入容器的作用。这不仅自动创建了所有的对象，而且还自动 \"注入 \"了依赖关系，这样就不再需要手动调用 \"新建 \"了。有各种类型的注入，如构造函数注入、方法注入或属性注入。",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "依赖注入容器（也称为DI容器或IoC容器）在`@deepkit/injector`中随Deepkit一起提供，或者已经通过Deepkit框架中的应用模块集成。使用`@deepkit/injector`包中的低级API，上面的代码会是这样的。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "本例中的`injector`对象是依赖注入容器。容器没有使用`new UserRepository`，而是使用`get(UserRepository)`返回UserRepository的实例。为了静态地初始化容器，一个提供者的列表被传递给函数`InjectorContext.forProviders`（在这种情况下只是简单的类）。",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "由于DI是关于提供依赖关系的，容器被提供了依赖关系，因此技术术语为 \"提供者\"。有各种类型的提供者：ClassProvider、ValueProvider、ExistingProvider、FactoryProvider。",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "提供者之间的所有依赖关系都被自动解决，一旦发生`injector.get()`调用，对象和依赖关系就会被创建、缓存，并正确地作为构造函数参数传递（构造函数注入）、设置为属性（属性注入）或传递给方法调用（方法注入）。",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "为了与另一个HttpClient交换，可以为HttpClient定义另一个提供者（这里是ValueProvider）：",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "一旦UserRepository通过`injector.get(UserRepository)`被请求，它就会收到另一个HttpClient对象。",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "所有类型的提供者都在<<dependency-injection-providers>>部分列出并解释。",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "在这一点上值得一提的是，Deepkit的DI容器只适用于Deepkit的运行时类型。这意味着任何包含类、类型、接口和函数的代码都必须经过Deepkit类型编译器的编译，以便在运行时获得类型信息。参见<<runtime-types>>一章。",
        "Dependency Inversion": "依赖反转",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "控制反转下的UserRepository的例子显示，UserRepository依赖于一个较低的层次，即一个HTTP库。此外，一个具体的实现（类）而不是抽象的（接口）被声明为依赖关系。乍一看，这似乎符合面向对象的范式，但它可能会导致问题，特别是在复杂和大型的架构中。",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "两个实现（UserRepository与HTTP库）的合并现在可以通过DI容器完成。",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "由于Deepkit的DI容器能够解决抽象的依赖关系（接口），例如在这种情况下，UserRepository自动获得HttpClient的实现，因为HttpClient已经实现了接口HttpClientInterface。这可以通过HttpClient专门实现HttpClientInterface（`class HttpClient implements HttpClientInterface`），或者通过HttpClient的API仅仅与HttpClientInterface兼容来实现。",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "一旦HttpClient改变了它的API（例如，删除了`get'方法），从而不再与HttpClientInterface兼容，DI容器就会抛出一个错误（\"没有提供HttpClientInterface的依赖性\"）。",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "在这里，想要将两种实现结合起来的用户不得不找到一种解决方案。作为一个例子，可以在这里注册一个适配器类，它实现了HttpClientInterface并正确地将方法调用转发给HttpClient。",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip sein Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "这里应该注意的是，尽管在理论上，依赖反转原则有其优点，但在实践中，它也有相当的缺点。例如，这不仅会导致更多的代码（因为必须编写更多的接口），而且还会导致更多的复杂性（因为现在每个实现都有一个接口来处理每个依赖关系）。只有当应用达到一定规模，并且还需要这种灵活性时，这种代价才是值得的。像每一个设计模式和原则一样，这个模式也有它的成本使用因素，在应用之前应该考虑清楚。",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "设计模式不应该盲目地用于每一个代码，无论多么简单。然而，如果有复杂的架构、大型应用程序或扩展团队等先决条件，依赖反转和其他设计模式才会展开其真正的力量。",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "由于Deepkit中的依赖注入是基于运行时类型的，因此有必要将`@deepkit/type`已经正确安装。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果已经成功完成，`@deepkit/injector`可以自行安装，或者安装已经使用该库的Deepkit框架的引擎。",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "一旦库被安装，可以直接使用其中的API。",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "现在要使用依赖注入，有三种可能性。",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "如果`@deepkit/injector`要在没有Deepkit框架的情况下使用，推荐使用前两种变体。",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "在依赖注入的介绍中已经介绍了Injector API。它的特点是使用非常简单，通过单一的`InjectorContext`类来创建一个DI容器，特别适合于没有模块的简单应用。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "本例中的`injector`对象是依赖注入容器。在这种情况下，函数`InjectorContext.forProviders`接收一个提供者的数组。",
        "Module API": "模块API",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hiararchie und schön separierte Architektur aufzubauen.": "一个稍微复杂的API是 \"InjectorModule \"类，它允许在不同的模块中交换提供者，以便为每个模块创建多个封装的DI容器。这也允许每个模块使用配置类，这使得自动向提供者提供经过验证的配置值更加容易。模块之间可以相互导入，并导出提供者，以建立一个层次分明、分离良好的架构。",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "如果应用程序比较复杂，并且没有使用Deepkit框架，就应该使用这个API。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "这种情况下的`injector`对象是依赖注入容器。提供者可以被分割成不同的模块，然后可以用模块导入的方式将它们重新导入到不同的地方。这创建了一个自然的层次结构，映射了应用程序或架构的层次结构。",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "InjectorContext应该总是被赋予层次结构中的顶级模块，也称为根模块或应用模块。然后InjectorContext只有一个中间任务：对`injector.get()`的调用被简单地转发给根模块。然而，非根模块的提供者也可以通过传递模块作为第二个参数来获得。",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "所有非根模块都被默认封装，因此这个模块中的所有提供者只对它自己有效。如果一个提供者要对其他模块可用，这个提供者必须被导出。",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden.": "要想把所有的提供者默认导出到顶层，即根模块，可以使用选项`forRoot`。",
        "App API": "App API",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, so dass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "只要使用Deepkit框架，就可以用`@deepkit/app`的API定义模块。这是基于模块API的，所以那里的能力也是可用的。此外，还可以使用强大的钩子和定义配置加载器来映射更多的动态架构。",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "<framework-modules>一章对此有更详细的描述。",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "在依赖注入容器中，有几种方法来提供依赖。最简单的变体是简单地指定一个类。这也被称为短的ClassProvider。",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "这代表一个特殊的提供者，因为只指定了类。",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes mal neu ausgeführt werden.": "默认情况下，所有的提供者都被标记为单子，因此在任何时候都只有一个实例存在。要在每次提供的时候创建一个新的实例，可以使用`transient`选项。这将导致每次都要重新创建类，或者每次都要执行工厂。",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "除了简短的ClassProvider，还有普通的ClassProvider，它是一个对象字面，而不是一个类。",
        "Dies ist Äquivalent zu diesen beiden:": "这相当于这两个：",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "它可以用来将一个提供者与另一个类交换。",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "在这个例子中，`OtherUserRepository'类现在也在DI容器中被管理，它的所有依赖关系都被自动解决。",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "静态值可以用这个提供者提供。",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "因为不仅是类实例可以作为依赖关系提供，任何值都可以被指定为`useValue'。符号或基元（字符串、数字、布尔）也可以作为提供者标记。",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "基元提供者标记必须作为依赖关系与注入类型一起声明。",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängikeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "通过注入别名和基元提供者标记的结合，也可以从不包含运行时类型信息的包中提供依赖关系。",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "然后在用户端声明如下：",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "可以定义一个已经定义的提供者的重定向。",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfigurations-Optionen zugreifbar.": "可以用一个函数来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "除了类和基元之外，还可以提供抽象（接口）。这是用`provide`函数完成的，当要提供的值不包含任何类型信息时特别有用。",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "如果几个提供者实现了接口连接，则使用最后一个提供者。",
        "Als Argument für provide() sind alle anderen Provider möglich.": "所有其他提供者都可以作为provide()的参数。",
        "Constructor/Property Injection": "构造器/属性注入",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "在大多数情况下，使用构造器注入。所有的依赖被指定为构造函数参数，并由DI容器自动注入。",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "可选的依赖应该被标记为这样，否则如果找不到提供者，可能会引发错误。",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "构造函数注入的一个替代方法是属性注入。这通常是在依赖关系是可选的或者构造函数太满的情况下使用。一旦实例被创建（也就是构造函数被执行），这些属性就会被自动分配。",
        "Konfiguration": "配置",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "依赖注入容器也允许注入配置选项。这种配置注入可以通过构造函数注入或属性注入来接收。",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "模块API支持定义配置定义，它是一个普通的类。通过为这样的类提供属性，每个属性都作为一个配置选项。",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "配置选项`domain`和`debug`现在可以方便地以类型安全的方式在提供者中使用。",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "选项本身的值可以通过`configure()`来设置。",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem \"!\" versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "没有默认值但仍然需要的选项可以用\"！\"来标记。这迫使模块的用户提供该值，否则将导致错误。",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "同时，前几章的所有序列化和验证类型<<validation>>和<<serialisation>>可以用来非常详细地指定一个选项必须有哪些类型和内容限制。",
        "Injection": "注入",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "配置选项可以像其他依赖关系一样通过DI容器安全而容易地注入，如前所示。最简单的方法是使用索引访问操作符来引用单个选项：",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "配置选项不仅可以单独引用，还可以作为一个组来引用。为此，使用了TypeScript实用类型`Partial`：",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "为了获得所有的配置选项，也可以直接引用配置类：",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "然而，建议只引用实际使用的配置选项。这不仅简化了单元测试，也使我们更容易从代码中看到实际需要的东西。",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "默认情况下，DI容器的所有提供者是一个单子，因此只被实例化一次。这意味着在UserRepository的例子中，在整个运行时间内，始终只有一个UserRepository的实例。在任何时候都不会创建第二个实例，除非用户用 \"new \"关键字手动创建。",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "然而，在各种使用情况下，一个提供者应该只在短时间内或只在某一事件中被实例化。这样的事件可以是，例如，一个HTTP请求或一个RPC调用。这就意味着每次事件发生时都会创建一个新的实例，在这个实例不再被使用后，它会被自动删除（由垃圾收集器）。",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "一个HTTP请求是一个典型的作用域的例子。例如，诸如会话、用户对象或其他与请求有关的提供者可以被注册到这个范围。要创建一个作用域，只需选择一个任意的作用域名称，然后用提供者来指定它。",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "一旦指定了一个作用域，就不能再直接通过DI容器获得该提供者，所以下面的调用失败了：",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedesmal geschehen sobald ein HTTP-Request reinkommt:": "相反，必须创建一个作用域的DI容器。这将在每次HTTP请求进来时发生：",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "在这个范围内的DI容器上，现在也可以请求也在这个范围内注册的提供者，以及所有没有定义范围的提供者。",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "由于所有的提供者默认是单子，每次调用`get(UserSession)`将总是返回每个范围内容器的相同实例。如果你创建了多个作用域的容器，也将创建多个UserSessions。",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "与Deepkit框架一起工作的应用程序默认有一个`http`、一个`rpc`和一个`cli`作用域。请分别参阅<<cli>>、<<http>>或<<rpc>>一章。",
        "Setup Calls": "设置调用",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "设置调用允许你操纵一个提供者的结果。这很有用，例如，使用另一种依赖注入的变体，方法注入。",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "设置调用只能分别用于模块API或应用API，并在模块之上注册。",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "`setupProvider`方法返回一个UserRepository的代理对象，其方法可以被调用。应该注意的是，这些方法调用只是被放在一个队列中，此时并没有被执行。相应地，也没有返回值。",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "除了方法调用，还可以设置属性。",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "这种赋值也只放在队列中。",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "队列中的调用或赋值，一旦被创建，就在提供者的实际结果上执行。也就是说，在ClassProvider的情况下，一旦实例被创建，它们就被应用到类实例上，在FactoryProvider的情况下，它们被应用到工厂的结果上，而在ValueProvider的情况下，它们被应用到提供者上。",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "为了不仅引用静态值，也引用其他提供者，可以使用函数`injectorReference`。这将返回一个对提供者的引用，这也是DI容器在执行设置调用时的请求。",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Interfaces也可以被分配设置调用。",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "命令行接口（CLI）程序是通过终端以文本输入和文本输出形式进行交互的程序。",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Deepkit中的CLI应用程序可以完全访问DI容器，因此可以访问所有提供者和配置选项。",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Dekoratoren, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI框架允许你根据简单的类来轻松注册自己的命令。事实上，它是以`@deepkit/app`为基础的，这是一个专门用于此目的的小包，也可以独立使用，不需要Deepkit框架。在这个包中，你将找到装饰CLI控制器类所需的装饰器。",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "控制器是由依赖注入容器管理或实例化的，因此可以使用其他提供者。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit中的CLI程序是基于运行时类型的，因此必须已经正确安装@deepkit/type。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果成功完成，可以安装@deepkit/app或Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "注意，`@deepkit/app`是基于TypeScript装饰器的，该功能必须通过`experimentalDecorators`相应启用。",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "为了给你的应用程序创建一个命令，你需要创建一个CLI控制器。这是一个简单的类，它有一个方法`exeecute`，并配备了关于命令的信息。",
        "_Datei: app.ts_": "_文件：app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "在装饰器`@cli.controller`中，CLI应用程序的唯一名称被定义为第一个参数。进一步的选项，如描述，可以选择在对象中的第二个位置添加。",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "这段代码已经是一个完整的CLI应用程序，可以像这样启动：",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "你可以看到，一个 \"测试 \"命令可用。要运行这个，必须将名称作为参数传入：",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "也可以用`chmod +x app.ts`使文件可执行，这样`./app.ts`命令已经足以启动它。应该注意的是，这时需要一个所谓的",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "shebang。Shebang指的是脚本程序开始时的字符组合`#！`。在上面的例子中，已经出现了：`&#35;!/usr/bin/env ts-node-script`，并且使用了`ts-node`的脚本模式。",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "通过这种方式，可以创建和注册任何数量的命令。在`@cli.controller`中给出的唯一名称应该选择得当，并允许用`:`字符对命令进行分组（例如，`user:create`，`user:remove`，等等）。",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "为了添加参数，新参数被添加到`execute`方法中，并用`@arg`装饰器进行装饰。",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "如果你现在执行这个命令而没有指定一个名字，将会产生一个错误：",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "使用`--help`会给你更多关于所需参数的信息：",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "一旦名字被作为参数传递，TestCommand中的`execute`方法将被执行，名字将被正确传递。",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags是另一种向命令传递数值的方式。通常这些是可选的，但不一定是。用`@flag name`装饰的参数可以通过`--name value`或`--name=value`传递。",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "在帮助视图中，你现在可以在 \"OPTIONS \"中看到一个`--id`标志是必要的。如果指定正确，命令就会收到这个值。",
        "Boolean Flags": "布尔标志",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "标志的优点是，它们也可以作为无值标志使用，例如，激活某种行为。只要一个参数被标记为可选的布尔值，这个行为就会被激活。",
        "Multiple Flags": "多个标志",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "为了向同一个标志传递多个值，可以将一个标志标记为一个数组。",
        "Single Character Flags": "单字符标志",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "为了让标志也能以单字符形式传递，可以使用`@flag.char('x')`。",
        "Optional / Default": "可选/默认",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "`execute`方法的签名定义了哪些参数或标志是可选的。如果参数被标记为可选，则不需要指定。",
        "The signature of the method `execute` defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "方法`执行'的签名定义了哪些参数或标志是可选的。如果该参数在类型系统中是可选的，那么用户就不必提供它。",
        "Dasselbe für Parameter mit einem Default-Wert:": "有默认值的参数也是如此：",
        "Dies gilt auch für Flags in derselben Art und Weise.": "这也以同样的方式适用于标志。",
        "Serialization / Validation": "序列化/验证",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "所有的参数和标志都会根据它们的类型自动反序列化，进行验证，并且可以提供额外的限制。",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "所以定义为数字的参数在控制器中总是被保证为实数，尽管命令行界面是基于文本的，因此是字符串。",
        "Zusätzliche Einschränkungen können mit den Typen-Dekoratoren aus `@deepkit/type` definiert werden.": "额外的限制可以通过`@deepkit/type`的类型装饰器来定义。",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "`id`的`Postive`类型表示只需要正数。如果用户现在传递一个负数，`执行'中的代码根本不被执行，并出现一个错误信息。",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "如果数字是正数，这时又像以前一样工作。这种额外的验证是非常容易做到的，它使命令对错误的条目更加强大。",
        "Description": "描述",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "为了描述一个标志或参数，可以使用`@flag.description`或`@arg.description`。",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "在帮助视图中，这个描述出现在标志或参数的后面：",
        "Exit code": "退出代码",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "退出代码默认为0，这意味着命令被成功执行。要改变退出代码，应该在`exucute`方法中返回一个非0的数字。",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "命令的类由DI容器管理，所以可以定义依赖关系，通过DI容器解决。",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "处理HTTP查询有时是服务器最著名的任务。它将输入（HTTP请求）转换为输出（HTTP响应），并执行一项特定的任务。客户端可以通过HTTP请求以各种方式向服务器发送数据，这些数据必须被正确读取和处理。除了HTTP主体外，HTTP查询或HTTP头值也是可能的。数据如何被实际处理取决于服务器。",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "这里的首要任务不仅是正确执行用户期望的内容，而且要正确转换（反序列化）和验证来自HTTP请求的任何输入。",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "HTTP请求在服务器上通过的管道可能是多样化和复杂的。许多简单的HTTP库只是简单地传递给定路由的HTTP请求和HTTP响应，并期望开发者直接处理HTTP响应。一个中间件API允许管道根据需要进行扩展。",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte bzw Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den User damit eine Architektur selbst obendrauf zu setzen, die einem diese zwingenden Funktionalitäten abnimmt.": "这对简单的用例来说是非常合适的，但随着应用的增长，很快就会变得混乱，因为所有的输入和输出都必须手动进行序列化或反序列化并进行验证。还有必要考虑如何从应用程序本身获得对象或服务，如数据库抽象。",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection: Serialisierung bzw Deserialisierung und Validierung von jeglichen Werten passiert automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer gewählten Architektur abzudecken.": "Deepkit的HTTP库使用了TypeScript和依赖注入的力量：序列化或反序列化以及任何数值的验证都是根据定义的类型自动进行的。",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "它还允许你通过一个功能性的API来定义路由，就像上面的例子一样，或者通过控制器类来覆盖所选架构的不同需求。这两种API变体都可以访问依赖性注入容器，因此可以方便地从应用程序中获得数据库抽象和配置等对象。",
        "_Deepkit Beispiel_": "_Deepkit 示例_",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，必须用`experimentalDecorators`相应启用该功能。",
        "Funktionale API": "功能API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "功能API是基于函数的，可以通过路由器注册表注册，可以通过应用程序的DI容器获得。",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "路由器注册表也可以在事件监听器或引导中获得，这样就可以根据模块、配置和其他提供者注册各种路由。",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "一旦使用了模块，功能路由也可以由模块动态提供。",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "参见<<framework-modules>>一章，了解更多关于App Modules的信息。",
        "Controller API": "控制器API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "控制器API基于类，可以通过App API在`controllers`选项下注册。",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "一旦使用了模块，控制器也可以由模块提供。",
        "HTTP Server": "HTTP服务器",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "如果使用Deepkit Framework，已经内置了一个HTTP服务器。然而，HTTP库也可以在不使用Deepkit框架的情况下使用自己的HTTP服务器。",
        "HTTP Client": "HTTP客户端",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name that can be referenced in a redirect.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "路由器函数以及控制器类和控制器方法可以定义任意的依赖关系，由依赖注入容器来解决。",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "例如，如果一个数据库作为提供者被提供，它可以被注入：",
        "_Funktionaler API:_": "_功能型API:_",
        "_Controller API:_": "_控制器API:_",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "更多信息见<<依赖-注入>>一章。",
        "Input": "输入",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "以下所有的输入变化对功能型和控制器API的功能都是一样的。",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "这不仅大大提高了安全性，而且还简化了单元测试，",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "因为严格来说，为了测试路由，甚至不需要存在一个HTTP请求对象。",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "所有参数都被自动转换（反序列化）为定义的TypeScript类型并进行验证。这是通过`@deepkit/type`包及其<<序列化>>和<<验证>>功能完成的。",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "为了简单起见，下面展示了所有带有功能API的例子。",
        "Path Parameters": "路径参数",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "路径参数是从路由的URL中提取的值。",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "转换是使用<<serialisation-loosely-conversion>>功能自动完成的。",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "如果一个路径参数被定义为字符串以外的类型，它将被正确转换。",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "额外的验证约束也可以应用于该类型。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>一章。",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "路径参数在URL匹配时默认设置为`[^/]+`正则表达式。这方面的正则表达式可以调整如下：",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "这只有在特殊情况下才需要，因为通常情况下，与验证类型本身相结合的类型已经正确地限制了可能的值。",
        "Query Parameters": "查询参数",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "查询参数是URL中`?`字符后面的值，可以用`HttpQuery<T>`类型读取。",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "查询参数的名称与查询参数的名称相对应。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>章节。",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*警告*。参数值没有被转义/消毒。在路由中直接以字符串的形式将它们作为HTML返回，会打开一个安全漏洞（XSS）。确保从不信任外部输入，并在必要时过滤/净化/转换数据。",
        "Query Model": "查询模型",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "由于有很多查询参数，很快就会变得混乱。",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "指定模型中的属性可以包含所有TypeScript类型和`@deepkit/type'支持的验证类型，只有在例如要在同一个路由中手动评估关于body的错误信息时才使用`HttpBodyValidation`。参见<<序列化>>和<<验证>>两章。",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "对于允许HTTP主体的HTTP方法，也可以指定一个主体模型。",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "来自HTTP请求的body内容类型必须是`application/x-www-form-urlencoded`、`multipart/form-data`或`application/json`，以便Deepkit自动将其转换为JavaScript对象。",
        "Manual Validation Handling": "手动验证处理",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "为了手动处理body模型的验证，可以使用一个特殊类型`HttpBodyValidation<T>`。它允许接收无效的主体数据，并对错误信息作出非常具体的反应。",
        "Sobald valid() den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "一旦valid()返回值`false`，指定模型中的值可能处于错误的状态。这意味着验证失败。如果没有使用`HttpBodyValidation`，并且收到了一个不正确的HTTP请求，该请求将被直接中止，函数中的代码将永远不会被执行。",
        "File Upload": "文件上传",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "主体模型上的一个特殊的属性类型可以用来允许客户端上传文件。可以使用任何数量的`UploadedFile`。",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "默认情况下，路由器将所有上传的文件存储在一个临时文件夹中，一旦路由中的代码被执行，就将其删除。因此，有必要读取`path`中指定路径的文件，并将其保存到一个永久的位置（本地硬盘、云存储、数据库）。",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet werden, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "HTTP服务器中的验证是一个强制性的功能，因为它几乎总是涉及到不能信任的数据工作。数据验证的地方越多，服务器就越稳定。HTTP路由中的验证可以方便地通过类型和验证约束来使用，并通过来自`@deepkit/type`的高度优化的验证器进行检查，因此在这方面不存在性能问题。因此，强烈建议使用这些验证能力。",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "所有的输入，如路径参数、查询参数和主体参数都会自动验证为指定的TypeScript类型。如果通过`@deepkit/type`的类型指定了额外的约束，这些约束也会被检查。",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "关于这方面的更多信息，请看<<validation>>章节。",
        "Output": "输出",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "路由可以返回各种数据结构。其中一些是以特殊的方式处理的，如重定向和模板，而其他的，如简单的对象，只是作为JSON发送。",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "默认情况下，正常的JavaScript值会以JSON形式返回给客户端，标题为`application/json; charset=utf-8`。",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "如果在函数或方法中指定了明确的返回类型，那么数据将根据该类型被Deepkit JSON序列化器序列化为JSON。",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "要发送HTML，有两种可能。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "带TSX的Template-Engine变体的优点是使用的变量会自动进行HTML转义。见<<template>>一章。",
        "Custom Content": "自定义内容",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "除了HTML和JSON，还可以发送具有特定内容类型的文本或二进制数据。这是通过对象`Response`",
        "Zusätzliche Header": "Additional Header",
        "Um den Header einer Antwort zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "来改变响应的头，可以在对象`Response`、`JSONResponse`和`HTMLResponse`上调用其他方法。",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "要返回301或302重定向作为响应，可以使用`Redirect.toRoute`或`Redirect.toUrl`。",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "这里的`Redirect.toRoute`方法使用路由的名称。如何设置路由名称可以在<<http-route-name>>部分看到。如果这个被引用的路由（查询或路径）包含参数，这些参数可以通过第二个参数指定：",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "或者，用`Redirect.toUrl`重定向到一个URL。",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "默认情况下，两者都使用302重定向。",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "所有的HTTP控制器和功能路由都在`http`依赖性注入范围内管理。HTTP控制器为每个HTTP请求进行相应的实例化。这也意味着两者都可以访问为`http`范围注册的提供者。因此，另外来自`@deepkit/http`的`HttpRequest`和`HttpResponse`可以作为依赖关系使用。如果使用Deepkit Framework，`@deepkit/framework'中的`SessionHandler'也是可用的。",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "在`http'范围内放置提供者可能相当有用，例如为每个HTTP请求重新实例化服务。一旦HTTP请求被处理，`http`作用域的DI容器就会被删除，从而从垃圾收集器（GC）中清理掉所有的提供者实例。",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见<<依赖-注入-作用域>>一章，了解如何在`http`作用域中放置提供者。",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "HTTP模块基于一个工作流引擎，它提供了各种事件标记，可以用来钩住处理HTTP请求的整个过程。",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "工作流引擎是一个有限状态机，为每个HTTP请求创建一个新的状态机实例，然后从一个位置跳到另一个位置。第一个位置是 \"开始\"，最后一个是 \"回应\"。",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "每个事件标记都有自己的事件类型，并有额外的信息。",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "由于所有的HTTP事件都是基于工作流引擎的，它的行为可以通过使用指定的事件并通过`event.next()`方法跳转到那里来修改。",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "HTTP模块在这些事件标记上使用自己的事件监听器来实现HTTP请求的处理。所有这些事件监听器的优先级都是100，这意味着当你监听一个事件时，你的监听器将被默认首先执行（因为默认优先级是0）。",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "例如，假设你想捕捉一个控制器被调用的事件，那么你可以在HTTP模块的事件监听者之后添加一个高于100的优先级。如果一个特定的控制器要被调用，我们要检查用户是否有权限访问它。如果用户有权限，我们继续。但如果不是，我们就跳到下一个工作流程项目`accessDenied`。在那里，访问拒绝的程序会被自动进一步处理。",
        "Middleware": "中间件",
        "Resolver": "解析器",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "路由器支持一种解析复杂参数类型的方法。例如，给定一个路由，如`/user/:id`，这个`id`可以通过一个解析器解析到路由之外的`user`对象。这进一步解耦了HTTP抽象和路由代码，进一步简化了测试和模块化。",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "用户不一定要在这里依赖一个参数。它也可以依赖于会话或HTTP头，并且只在用户登录后提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，所以很多用例都可以通过这种方式进行映射。",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "原则上，也可以通过依赖注入容器从`http`范围提供复杂的参数类型，因为这些也可以在路由函数或方法中使用。然而，这有一个缺点，就是不能使用异步函数调用，因为DI容器自始至终都是同步的。",
        "RPC": "RPC",
        "Connection": "连接",
        "Entity": "实体",
        "Session": "会话",
        "Query": "查询",
        "Repository": "存储",
        "Relations": "关系",
        "Inheritance": "继承",
        "Index": "索引",
        "Case Sensitivity": "大小写敏感度",
        "Character Sets": "字符集",
        "Key/Value": "Key/Value",
        "Pub/Sub": "Pub/Sub",
        "Eine TSX basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "一个基于TSX的模板引擎，可以以一种类型安全的方式生成HTML。",
        "TypeScript ist Javascript das skaliert. Eine Sprache, die designt ist, komplexen Code zu schreiben. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Das führt oft dazu, dass TypeScript-Code nach dem Kompilieren wie normaler JavaScript-Code aussieht. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern während dem Entwickeln (spätestens jedoch bei dem Kompilieren) viel schneller und einfacher als würde das mit reinem JavaScript möglich sein und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许编写带有类型的JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "验证是任何应用程序的重要组成部分，使用一次太频繁比一次太少好。Deepkit提供了许多验证选项，并有一个高性能的实现，所以在绝大多数情况下，不需要担心执行时间。",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "CLI应用程序的参数和选项由方法参数通过TypeScript类型控制，并自动进行序列化和验证。",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI是Deepkit Framework应用程序的三个入口点之一。在Deepkit框架中，应用程序总是通过CLI程序启动，该程序本身是由用户用TypeScript编写的。因此，没有针对Deepkit的全局CLI工具来启动Deepkit应用程序。这是你启动HTTP/RPC服务器、执行迁移或运行你自己的命令的方式。这都是通过同一个入口点，同一个文件完成的。一旦通过从`@deepkit/framework`中导入`FrameworkModule`来使用Deepkit框架，应用程序就会得到应用服务器、迁移等的额外命令。",
        ":stem[\\documentclass[UTF8]{ctexart}]": ":stem[/documentclass[UTF8]{ctexart}]",
        "Benutzung": "使用",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "依赖注入（DI）是一种设计模式，其中类和函数_receive_ their dependencies。它遵循反转控制（IoC）的原则，有助于更好地分离复杂的代码，以提高可测试性、模块化和清晰度。尽管还有其他设计模式，如服务定位器模式，来应用IoC的原则，但DI已经确立了自己的主导模式，特别是在企业软件中。",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的JavaScript。一种旨在实现复杂用例的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这种类型的安全允许更容易编写和维护复杂的应用程序。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript现在是世界上最大的开发者社区，它为开发者提供了相应的大量选择，包括许多库和工具，以满足项目的需要。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念、API和代码质量差别很大，以至于开发人员必须引入大量的粘性代码和额外的抽象，以使这些库能够相互正常工作。近几十年来，制造商或社区将几乎每个项目都需要的核心功能放在漂亮的抽象化的库中，并将其汇集到一个框架中，这已经一次又一次地证明了自己。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念以库或组件的形式实现，这样就可以根据需要方便地相互协调使用。所提供的功能和设计模式不是立方体，而是基于有时是几十年前的概念，并在与其他想法的竞争中证明了自己。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译过程中完全删除了其类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中或运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据在运行时被转换/序列化、数据被验证、元信息被添加到对象或需要接口信息的情况下，这个值会被反映出来。在这些和其他许多用例中，类型信息在运行时可能非常有用，因为它为库提供了必要的信息以有效地提供功能。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，并迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里不能再发挥其优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种范式的转变，Deepkit为几乎所有程序中都能找到的用例开发了一整套库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发者需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Type Compiler": "类型编译器",
        "Typeninformation Empfangen": "接收类型信息",
        "Validate&lt;typeof MyValidator&gt;": "Validate&lt;typeof MyValidator&gt;",
        "Pattern&lt;typeof MyRegexp&gt;": "Pattern&lt;typeof MyRegexp&gt;",
        "Decimal&lt;number, Number&gt;": "Decimal&lt;number, Number&gt;"
    }
}