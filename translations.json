{
    "english": {
        "Runtime Types": "Runtime Types",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "Making type information available at runtime in TypeScript changes a lot. It allows new ways of working that were previously only possible in a roundabout way, or not at all. Declaring types and schemas has become a big part of modern development processes. For example, GraphQL, validators, ORMs, and encoders such as ProtoBuf, and many more rely on having schema information available at runtime to provide fundamental functionality in the first place. These tools and libraries sometimes require the developer to learn completely new languages that have been developed very specifically for the use case. For example, ProtoBuf and GraphQL have their own declaration language, also validators are often based on their own schema APIs or even JSON schema, which is also an independent way to define structures. Some of them require code generators to be executed whenever a change is made, in order to provide the schema information to the runtime as well. Another well-known pattern is to use experimental TypeScript decorators to provide meta-information to classes at runtime.",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "But is all this necessary? TypeScript offers a very powerful language to describe even very complex structures. In fact, TypeScript is now touring-complete, which roughly means that theoretically any kind of program can be mapped into TypeScript. Of course, this has its practical limitations, but the important point is that TypeScript is able to completely replace any declaration formats such as GraphQL, ProtoBuf, JSON Schema, and many others. Combined with a type system at runtime, it is possible to cover all the described tools and their use cases in TypeScript itself without any code generator. But why is there not yet a solution that allows exactly this?",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "Historically, TypeScript has undergone a massive transformation over the past few years. It has been completely rewritten several times, received basic features, and undergone a number of iterations and breaking changes. However, TypeScript has now reached a product market fit that greatly slows the rate at which fundamental innovations and breaking changes happen. TypeScript has proven itself and shown what a highly charming type system for a highly dynamic language like JavaScript should look like. The market has gratefully embraced this push and ushered in a new era in JavaScript development.",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "This is exactly the time to build tools on top of the language itself at a fundamental level to make the above possible. Deepkit wants to be the impetus to bring over decades of proven design patterns from the enterprise of languages like Java and PHP not only fundamental to TypeScript, but in a new and better way that works with JavaScript rather than against it. Through type information at runtime, these are now for the first time not only possible in principle, but allow for whole new much simpler design patterns that are not possible with languages like Java and PHP. TypeScript itself has laid the foundation here to make the developer's life considerably easier with completely new approaches in strong combination with the tried and tested.",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zur Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "Reading type information at runtime is the capability on which Deepkit builds its foundation. The API of the Deepkit libraries are largely focused on using as much TypeScript type information as possible to be as efficient as possible. Type system at runtime means that type information is readable at runtime and dynamic types are computable. This means, for example, that for classes all properties and for functions all parameters and return types can be read.",
        "Nehmen wir als Beispiel diese Funktion:": "Let's take this function as an example:",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "In JavaScript itself, several pieces of information can be read at runtime. For example, the name of the function (unless modified with a minimizer):",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "On the other hand, the number of parameters can be read out:",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "With a bit more code it is also possible to read out the names of the parameters. However, this is not easily done without a rudimentary JavaScript parser or RegExp on log.toString(), so that's about it from here. Since TypeScript translates the above function into JavaScript as follows:",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "the information that `message` is of type string and the return type is of type `void` is no longer available. This information has been irrevocably destroyed by TypeScript.",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "However, with a type system at runtime, this information can survive so that one can programmatically read the types of message and the return type.",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit does just that. It hooks into the compilation of TypeScript and ensures that all type information is built into the generated JavaScript. Functions like typeOf() (not to be confused with the operator typeof, with a lowercase o) then allow the developer to access it. Libraries can therefore be developed based on this type information, allowing the developer to use already written TypeScript types for a whole range of application possibilities.",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "To install Deepkit's runtime type system two packages are needed. The type compiler in `@deepkit/type-compiler` and the runtime in `@deepkit/type`. The type compiler can be installed in `package.json` _devDependencies_, because it is only needed at build time.",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "Runtime type information is not generated by default. It must be set `\"reflection\": true` in the `tsconfig.json` file to enable it in all files in the same folder of this file or in all subfolders. If decorators are to be used, `\"experimentalDecorators\": true` must be enabled in `tsconfig.json`. This is not strictly necessary to work with `@deepkit/type`, but necessary for certain functions of other deepkit libraries and in `@deepkit/framework`.",
        "_Datei: tsconfig.json_": "_file: tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript itself does not allow to configure the type compiler via a `tsconfig.json`. It is necessary to either use the TypeScript compiler API directly or a build system like Webpack with _ts-loader_. To avoid this inconvenience for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modules/typescript` when `@deepkit/type-compiler` is installed (this is done via NPM install hooks).",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes _tsc_, Angular, webpack, _ts-node_, and some other tools automatically work with the Deepkit type compiler.",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "If the type compiler could not be successfully installed automatically (for example because NPM install hooks are disabled), this can be done manually with the following command:",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "Note that `deepkit-type-install` must be run if the local typescript version has been updated (for example, if the typescript version in package.json has changed and `npm install` is run).",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "If you want to use the type compiler in a webpack build, you can do so with the `ts-loader` package (or any other typescript loader that supports transformer registration).",
        "_Datei: webpack.config.js_": "_file: webpack.config.js_",
        "Typen-Decorators": "Type Decorators",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "Type decorators are normal TypeScript types that contain meta-information to change the behavior of various functions at runtime. Deepkit already provides some type decorators that cover some use cases. For example, a class property can be marked as primary key, reference, or index. The database library can use this information at runtime to create the correct SQL queries without prior code generation.",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Validator constraints such as `MaxLength`, `Maximum`, or `Positive` can also be added to any type. It is also possible to tell the serializer how to serialize or deserialize a particular value. In addition, it is possible to create completely custom type decorators and read them at runtime, in order to use the type system at runtime in a very individual way.",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit comes with a whole set of type decorators, all of which can be used directly from `@deepkit/type`. They are designed not to come from multiple libraries, so as not to tie code directly to a particular library such as Deepkit RPC or Deepkit Database. This allows easier reuse of types, even in the frontend, although database type decorators are used for example.",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "The following is a list of existing type decorators. The validator and serializer of `@deepkit/type` and `@deepkit/bson` as well as Deepkit Database of `@deepkit/orm` used this information differently. See the corresponding chapters to learn more about this.",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Integer and floats are defined as a base as `number` and has several sub-variants:",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "Here the `id` of the user is a number at runtime, but is interpreted as an integer in the validation and serialization.",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "This means, for example, that floats may not be used in validation and the serializer automatically converts floats to integers.",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "The subtypes can be used in the same way and are useful if a specific range of numbers is to be allowed.",
        "Float": "Float",
        "UUID": "UUID",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4 is usually stored as a binary in the database and as a string in JSON.",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM stores BinaryBigInt as a binary field.",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as a uint: 255 for negative, 0 for zero, or 1 for positive.",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "To change the name of a property in the serialization.",
        "Group": "Group",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.",
        "Data": "Data",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.",
        "Excluded": "Excluded",
        "Each property can be excluded from the serialization process for a specific target.": "Each property can be excluded from the serialization process for a specific target.",
        "Embedded": "Embedded",
        "Marks the field as an embedded type.": "Marks the field as an embedded type.",
        "It's possible to change the prefix (which is per default the property name).": "It's possible to change the prefix (which is per default the property name).",
        "Entity": "Entity",
        "To annotate interfaces with entity information. Only used in the database context.": "To annotate interfaces with entity information. Only used in the database context.",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "Database",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Validation": "Validation",
        "Siehe <<validation-constraint-types>>.": "See <<validation-constraint-types>>.",
        "Benutzerdefinierte Type-Decorators": "Custom Type Decorators",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "A type decorator can be defined as follows:",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "By convention, a type decorator is defined to be an object literal with a single optional property `__meta` that has a tuple as its type. The first entry in this tuple is its unique name and all subsequent tuple entries are arbitrary options. This allows a type decorator to be equipped with additional options.",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "The type decorator is used with the intersection operator `&`. Any number of type decorators can be used on one type.",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "The type decorators can be read out via the type objects of `typeOf<T>()` and `metaAnnotation`:",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "The result in `annotation` is either an array with options if the type decorator `myAnnotation` was used or `undefined` if not. If the type decorator has additional options as seen in `AnnotationOption`, the passed values can be found in the array.",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "Already supplied type decorators like `MapName`, `Group`, `Data`, etc have their own annotation object:",
        "Siehe <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "See <<runtime-types-reflection>> to learn more about this.",
        "External Classes": "External Classes",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "Since TypeScript does not include type information by default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "MyExternalClass` can now be used in serialization functions and in the reflection API.",
        "To following shows how to annotate generic classes:": "To following shows how to annotate generic classes:",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "To work directly with the type information itself, there are two basic variants: Type objects and Reflection classes. Reflection classes are discussed below. The function `typeOf` returns type objects, which are very simple object literals. It always contains a `kind` which is a number and gets its meaning from the enum `ReflectionKind`. `ReflectionKind` is defined in the `@deepkit/type` package as follows:",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "There are a number of possible type objects that can be returned. The simplest ones are `never`, `any`, `unknown`, `void, null,` and `undefined`, which are represented as follows:",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "For example, number 0 is the first entry of the `ReflectionKind` enum, in this case `never`, number 1 is the second entry, here `any`, and so on. Accordingly, primitive types like `string`, `number`, `boolean` are represented as follows:",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "These rather simple types have no further information at the type object, because they were passed directly as type argument to `typeOf`. However, if types are passed via type aliases, additional information can be found at the type object.",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "In this case, the name of the type alias 'Title' is also available. If a type alias is a generic, the types passed will also be available at the type object.",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "If the type passed is the result of an index access operator, the container and the index type are present:",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "Interfaces and object literals are both output as Reflection.objectLiteral and contain the properties and methods in the `types` array.",
        "Index Signatures sind ebenfalls in dem `types` array.": "Index signatures are also in the `types` array.",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "Classes are similar to object literals and also have their properties and methods under a `types` array in addition to `classType` which is a reference to the class itself.",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "Note that the type of Reflection.propertySignature has changed to Reflection.property and Reflection.methodSignature has changed to Reflection.method. Since properties and methods on classes have additional attributes, this information can also be retrieved. The latter additionally include `visibility`, `abstract`, and `default`.",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "Type objects of classes contain only the properties and methods of the class itself and not of the super-classes. This is contrary to type objects of interfaces/object-literals, which have all property signatures and method signatures of all parents resolved into `types`. To resolve the property and method of the super-classes, either ReflectionClass and its `ReflectionClass.getProperties()` (see following sections) or `resolveTypeMembers()` of `@deepkit/type` can be used.",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "There is a whole plethora of type objects. For example for literal, template literals, promise, enum, union, array, tuple, and many more. To find out which ones all exist and what information is available, it is recommended to import `type` from `@deepkit/type`. It is a `union` with all possible subtypes like TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, and many more. There you can find the exact structure.",
        "Type Cache": "Type cache",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "Type objects are cached for type aliases, functions, and classes as soon as no generic argument is passed. This means that a call to `typeOf<MyClass>()` always returns the same object.",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "However, as soon as a generic type is used, new objects are always created, even if the type passed is always the same. This is because an infinite number of combinations are theoretically possible and such a cache would effectively be a memory leak.",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "However, as soon as a type is instantiated multiple times in a recursive type, it is cached. However, the duration of the cache is limited only to the moment the type is computed and does not exist thereafter. Also, although the Type object is cached, a new reference is returned and is not the exact same object.",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "`MyType<string>` is cached as long as `Object` is computed. The PropertySignature of `a` and `b` thus have the same `type` from the cache, but are not the same Type object.",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "All non-root type objects have a parent property, which usually points to the enclosing parent. This is valuable, for example, to find out whether a Type is part of a union or not.",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "Ref 1' points to the actual union type object.",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "For cached type objects as exemplified above, the `parent` properties are not always the real parents. For example, for a class that is used multiple times, although immediate types in `types` (TypePropertySignature and TypeMethodSignature) point to the correct TypeClass, the `type` of these signature types point to the signature types of the TypeClass of the cached entry. This is important to know so as not to infinitely read the parent structure, but only the immediate parent. The fact that the parent does not have infinite precision is due to performance reasons.",
        "JIT Cache": "JIT Cache",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "In the further course some functions and features are described, which are often based on the type objects. To implement some of them in a performant way, a JIT (just in time) cache per type object is needed. This can be provided via `getJitContainer(type)`. This function returns a simple object on which arbitrary data can be stored. As long as no reference to the object is held, it will be deleted automatically by the GC as soon as the Type object itself is also no longer referenced.",
        "Reflection-Klassen": "Reflection classes",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "In addition to the `typeOf<>()` function, there are various reflection classes that provide an OOP alternative to the Type objects. The reflection classes are only available for classes, interface/object literals and functions and their direct sub-types (properties, methods, parameters). All deeper types must be read again with the Type objects.",
        "Typeninformation empfangen": "Receive type information",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "In order to provide functions that operate on types, it can be useful to offer the user to pass a type manually. For example, in a validation function, it might be useful to provide the type to be requested as the first type argument and the data to be validated as the first function argument.",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "In order for this function to receive the type `string`, it must communicate this to the type compiler.",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType` with the reference to the first type arguments `T` signals the type compiler that each call to `validate` should put the type in second place (since `type` is declared in second place). To then read out the information at runtime, the `resolveReceiveType` function is used.",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "It is useful to assign the result to the same variable to avoid creating a new one unnecessarily. In `type` now either a type object is stored or an error is thrown, if for example no type argument was passed, Deepkit's type compiler was not installed correctly, or the emitting of type information is not activated (see the section Installation above).",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "To learn in detail how Deepkit encodes and reads the type information in JavaScript, this chapter is intended. It explains how the types are actually converted into bytecode, emitted in JavaScript, and then interpreted at runtime.",
        "Typen-Compiler": "Type compiler",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "The type compiler (in @deepkit/type-compiler) is responsible for reading the defined types in the TypeScript files and compiling them into a bytecode. This bytecode has everything needed to execute the types in runtime.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "At the time of this writing, the Type compiler is a so-called TypeScript Transformer. This transformer is a plugin for the TypeScript compiler itself and converts a TypeScript AST (Abstract Syntax Tree) into another TypeScript AST. In this process, Deepkit's type compiler reads the AST, produces the corresponding bytecode, and inserts it into the AST.",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript itself does not allow to configure this plugin aka transformer via a tsconfig.json. It is either necessary to use the TypeScript compiler API directly, or a build system like Webpack with `ts-loader`. To avoid this inconvenience for Deepkit users, the Deepkit type compiler automatically installs itself in `node_modules/typescript` when `@deepkit/type-compiler` is installed. This makes it possible for all build tools that access the locally installed TypeScript (the one in `node_modules/typescript`) to automatically have the type compiler enabled. This makes tsc, Angular, webpack, ts-node, and some other tools work automatically with Deepkit's type compiler.",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "If the automatic execution of NPM install scripts is not activated and thus the locally installed typescript is not modified, this process must be executed manually if you want to do so. Alternatively, the types compiler can be used manually in a build tool such as webpack. See the Installation section above.",
        "Bytecode Encoding": "Bytecode Encoding",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "The bytecode is a sequence of commands for a virtual machine and is encoded in the JavaScript itself as an array of references and string (the actual bytecode).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "The existing commands themselves are each one byte in size and can be found in `@deepkit/type-spec` as `ReflectionOp` enums. At the time of this writing, the command set is over 81 commands in size.",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "A sequence of commands is encoded as a string to save memory. So a type `string[]` is conceptualized as a bytecode program `[string, array]` which has the bytes `[5, 37]` and encoded with the following algorithm:",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "Accordingly, a 5 becomes an `&` character and a 37 becomes an `F` character. Together they become `&F` and are emitted in Javascript as `['&F']`.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "To prevent naming conflicts, each type is given a \"_Ω\" prefix. For each explicitly defined type that is exported or used by an exported type, a bytecode is emitted the JavaScript. Classes and functions also receive a bytecode directly as a property.",
        "Virtuelle Maschine": "Virtual machine",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "A virtual machine (in `@deepkit/type` the class Processor) at runtime is responsible for decoding and executing the encoded bytecode. It always returns a type object, see the Reflection section above.",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation is the process of checking data for correctness. Correctness is given if the type is the correct one and additional defined constraints are fulfilled. Deepkit generally distinguishes between type validation and the validation of additional constraints.",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "Validation is used whenever data comes from a source that is considered uncertain. Uncertain means that no guaranteed assumptions can be made about the types or contents of the data, and thus the data could have literally any value at runtime.",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "For example, data from user input is generally not considered secure. Data from an HTTP request (query parameter, body), CLI arguments, or a read-in file must be validated. If a variable is declared as a number, there must also be a number in it, otherwise the program may crash or a security hole may occur.",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "In a controller of an HTTP route, for example, the top priority is to check every user input (query parameter, body). Especially in the TypeScript environment, it is important not to use type casts, as they are fundamentally insecure.",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in <<serialisation>> mehr Informationen.": "This often seen code is a bug that can lead to a program crash or a security vulnerability because a type cast `as number` was used that does not provide any security at runtime. The user can simply pass a string as `limit` and the program would then work with a string in `limit`, although the code is based on the fact that it must be a number. To maintain this security at runtime there are validators and type guards. Also, a serializer could be used to convert `limit` to a number. More information about this can be found in <<serialization>>.",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "Validation is an essential part of any application and it is better to use it once too often than once too little. Deepkit provides many validation options and has a high-performance implementation, so in most cases there is no need to worry about execution time. Use as much validation as possible, in case of doubt once more, to be on the safe side.",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "In doing so, many components of Deepkit such as the HTTP router, the RPC abstraction, but also the database abstraction itself have validation built in and is performed automatically, so in many cases it is not necessary to do this manually.",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "In the corresponding chapters (<<cli>>, <<http>>, <<rpc>>, <<database>>) it is explained in detail when a validation happens automatically. Make sure that you know where restrictions or types have to be defined and do not use `any` to make these validations work well and safely automatically. This can save you a lot of manual work to keep the code clean and safe.",
        "Benutzung": "Use",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "The basic function of the validator is to check a value for its type. For example, whether a value is a string. This is not about what the string contains, but only about its type. There are many types in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, and many more. Due to Typescript's powerful type system, a large variety of different types are available.",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "In JavaScript itself, primitive types can be parsed with the `typeof` operator. For more complex types like interfaces, mapped types, or generic set/map this is not so easy anymore and a validator library like `@deepkit/type` becomes necessary. Deepkit is the only solution that allows to validate all TypesScript types directly without any detours.",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` vorgenommen werden.": "In Deepkit, type validation can be done using either the `validate`, `is`, or `assert` function.",
        "Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "The function `is` is a so-called type guard and `assert` is a type assertion. Both will be explained in the next section.",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "The function `validate` returns an array of found errors and on success an empty array. Each entry in this array describes the exact error code and the error message as well as the path when more complex types like objects or arrays are validated.",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "All three functions are used in roughly the same way. The type is specified or referenced as the first type argument and the data is passed as the first function argument.",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "If you work with more complex types like classes or interfaces, the array can also contain several entries.",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "The validator also supports deep recursive types. Paths are then separated with a dot.",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "Take advantage of the benefits that TypeScript offers you. For example, more complex types such as a `user` can be reused in multiple places without having to declare it again and again. For example, if a `user` is to be validated without its `id`, TypeScript utitilies can be used to quickly and efficiently create derived subtypes. Very much in the spirit of DRY (Don't Repeat Yourself).",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit is the only major framework that has the ability to access TypeScripts types in this way at runtime. If you want to use types in frontend and backend, types can be swapped out to a separate file and thus imported anywhere. Use this option to your advantage to keep the code efficient and clean.",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "A type cast (contrary to type guard) in TypeScript is not a construct at runtime, but is only handled in the type system itself. It is not a safe way to assign a type to unknown data.",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "The `as string` code is not safe. The variable `data` could have literally any value, for example `{username: 123}`, or even `{}`, and would have the consequence that `username` is not a string, but something completely different and therefore the code `username.startsWith('@')` will lead to an error, so that in the worst case the program crashes. To guarantee at runtime that `data` here has a property `username` with the type string, type-guards must be used.",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "Type guards are functions that give TypeScript a hint about what type the passed data is guaranteed to have at runtime. Armed with this knowledge, TypeScript then \"narrows\" the type as the code progresses.  For example, `any` can be made into a string, or any other type in a safe way.",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "So if there is data of which the type is not known (`any` or `unknown`), a type guard helps to narrow it down more precisely based on the data itself. However, the type guard is only as safe as its implementation. If you make a mistake, this can have severe consequences, because fundamental assumptions suddenly turn out to be untrue.",
        "Type-Guard": "Type-Guard",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "A type guard on the above used type `User` could look in simplest form as follows. Note that the above explained special features with NaN are not part here and thus this type guard is not quite correct.",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "A type guard always returns a Boolean and is usually used directly in an If operation.",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "Writing a separate function for each type guard, especially for more complex types, and then adapting it every time a type changes is extremely tedious, error-prone, and not efficient. Therefore, Deepkit provides the function `is`, which automatically provides a Type-Guard for any TypeScript type. This then also automatically takes into account special features such as the above-mentioned problem with NaN. The function `is` does the same as `validate`, but instead of an array of errors it simply returns a boolean.",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "A pattern that can be found more often is to return an error directly in case of incorrect validation, so that subsequent code is not executed. This can be used in various places without changing the complete flow of the code.",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "Alternatively, a TypeScript type assertion can be used. The `assert` function automatically throws an error if the given data does not validate correctly to a type. The special signature of the function, which distinguishes TypeScript type assertions, helps TypeScript to automatically narrow the passed variable.",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "Here, too, take advantage of the benefits that TypeScript offers you. Types can be reused or customized using various TypeScript functions.",
        "Error Reporting": "Error Reporting",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "The functions `is`, `assert` and `validates` return a boolean as result. To get exact information about failed validation rules, the `validate` function can be used. It returns an empty array if everything was validated successfully. In case of errors the array will contain one or more entries with the following structure:",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "The function receives as first type argument any TypeScript type and as first argument the data to validate.",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "Complex types such as interfaces, classes, or generics can also be used.",
        "Einschränkungen": "Constraints",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "In addition to checking the types, other arbitrary constraints can be added to a type. The validation of these additional content constraints is done automatically after the types themselves have been validated. This is done in all validation functions like `validate`, `is`, and `assert`. For example, a constraint can be that a string must have a certain minimum or maximum length.",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "These constraints are added to the actual types via the type decorators. There is a whole variety of decorators that can be used. Own decorators can be defined and used at will in case of extended needs.",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "With `&` any number of type decorators can be added to the actual type. The result, here `username`, can then be used in all validation functions but also in other types.",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "The function `validate` gives useful error messages coming from the constraints.",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "These information can be represented for example wonderfully also at a form automatically and be translated by means of the `code`. Through the existing path for objects and arrays, fields in a form can filter out and display the appropriate error.",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "An often useful use case is also to define an email with a RegExp constraint. Once the type is defined, it can be used anywhere.",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "Any number of constraints can be added.",
        "Constraint Types": "Constraint Types",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "Validation using a custom validator function. See next section Custom Validator for more information.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Defines a regular expression as validation pattern. Usually used for email validation or more complex content validation.",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "Validation for alpha characters (a-Z).",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "Validation for alpha and numeric characters.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Validation for ASCII characters.",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Validation of numbers that are a multiple of given number.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "Validation for min/max length for arrays or strings.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "Validation for an array item or sub string being included/excluded",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date)...",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Ensures that the number is an integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.",
        "See Special types: integer/floats for more information": "See Special types: integer/floats for more information",
        "Benutzerdefinierte Validator": "Custom validator",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "If the built-in validators are not sufficient, custom validation functions can be created and used via the `Validate` decorator.",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "Note that your custom validation function is executed after all built-in type validators have been called. If a validator fails, all subsequent validators for the current type are skipped. Only one failure is possible per type.",
        "Generic Validator": "Generic Validator",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "In the Validator function the type object is available which can be used to get more information about the type using the validator. There is also a possibility to define any validator option that must be passed to the validate type and makes the validator configurable. With this information and its parent references, powerful generic validators can be created.",
        "Serialisation": "Serialization",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "Serialization is the process of converting data types into a format suitable for transport or storage, for example. Deserialization is the process of undoing this. This is done losslessly, meaning that data can be converted to and from a serialization target without losing data type information or the data itself.",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "In JavaScript, serialization is usually between JavaScript objects and JSON. JSON supports only String, Number, Boolean, Objects, and Arrays. JavaScript, on the other hand, supports many other types such as BigInt, ArrayBuffer, typed arrays, Date, custom class instances, and many more. Now, to transmit JavaScript data to a server using JSON, you need a serialization process (on the client) and a deserialization process (on the server), or vice versa if the server sends data to the client as JSON. Using `JSON.parse` and `JSON.stringify` is often not sufficient for this, as it is not lossless.",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "This serialization process is absolutely necessary for non-trivial data, since JSON loses its information even for basic types like a date. A `new Date` is finally serialized as a string in JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "As you can see, the result of JSON.stringify is a JSON string. If you deserialize it again with JSON.parse, you will not get a `date` object, but a string.",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "Although there are various workarounds to teach JSON.parse to deserialize Date objects, they are error-prone and poorly performing. To enable type-safe serialization and deserialization for this case and many other types, a serialization process is necessary.",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "There are four main functions available: `serialize`, `cast`/`deserialize` and `validatedDeserialize`. Under the hood of these functions, the globally available JSON serializer from `@deepkit/type` is used by default, but a custom serialization target can also be used.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type supports user-defined serialization targets, but already comes with a powerful JSON serialization target that serializes data as JSON objects and then can be correctly and safely converted as JSON using JSON.stringify. With `@deepkit/bson`, BSON can also be used as a serialization target. How to create a custom serialization target (for example for a database driver) can be learned in the <<serialization-custom-serialiser>> section.",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Note that although serializers also validate data for compatibility, these validations are different from the validation in <<validation>>. Only the `cast` function also calls the full validation process from the <<validation>> chapter after successful deserialization, and throws an error if the data is not valid.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe <<validation>>.": "Alternatively, `validatedDeserialize` can be used to validate after deserialization. Another alternative is to manually call the `validate` or `validates` functions on deserialized data from the `deserialize` function, see <<validation>>.",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "All functions from serialization and validation throw a `ValidationError` from `@deepkit/type` on errors.",
        "Cast": "Cast",
        "Todo": "Todo",
        "Serialisierung": "Serialization",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "The function `serialize` converts the passed data by default with the JSON serializer into a JSON object, that is: String, Number, Boolean, Object, or Array. The result of this can then be safely converted to a JSON using JSON.stringify.",
        "Deserialisierung": "Deserialization",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "The function `deserialize` converts the passed data per default with the JSON serializer into the corresponding specified types. The JSON serializer expects a JSON object, i.e.: string, number, boolean, object, or array. This is usually obtained from a JSON.parse call.",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "If the correct data type is already passed (for example, a Date object in the case of `created`), then this is taken as it is.",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "Not only a class, but any TypeScript type can be specified as the first type argument. So even primitives or very complex types can be passed:",
        "Weiche Typenkonvertierung": "Soft type conversion",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "In the deserialization process a soft type conversion is implemented. This means that String and Number for String types or a Number for a String type can be accepted and converted automatically. This is useful, for example, when data is accepted via a URL and passed to the deserializer. Since the URL is always a string, Deepkit Type still tries to resolve the types for Number and Boolean.",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "The following soft type conversions are built into the JSON serializer:",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*: Number or Bigint accept String, Number, and BigInt. `parseFloat` or `BigInt(x)` are used in case of a necessary conversion.",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*: Boolean accepts Number and String. 0, '0', 'false' is interpreted as `false`. 1, '1', 'true' is interpreted as `true`.",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*string*: String accepts Number, String, Boolean, and many more. All non-string values are automatically converted with `String(x)`.",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "The soft conversion can also be deactivated:",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "In the case of invalid data, no attempt is made to convert it and instead an error message is thrown.",
        "Type-Decorators": "Type Decorators",
        "Integer": "Integer",
        "Mapped": "Mapped",
        "Naming Strategy": "Naming Strategy",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Dependency Injection": "Dependency Injection",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "Dependency Injection (DI) is a design pattern in which classes and functions _receive_ their dependencies. It follows the principle of Inversion of Control (IoC) and helps to better separate complex code in order to significantly improve testability, modularity and clarity. Although there are other design patterns, such as the service locator pattern, for applying the principle of IoC, DI has established itself as the dominant pattern, especially in enterprise software.",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "To illustrate the principle of IoC, here is an example:",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "The UserRepository class has an HttpClient as a dependency. This dependency in itself is nothing remarkable, but it is problematic that UserRepository creates the HttpClient itself. This is obvious at first glance, but it has its drawbacks: What if we want to replace the HttpClient? What if we want to test UserRepository in a unit test without allowing real HTTP requests to go out? How do we know that the class even uses an HttpClient?",
        "Inversion of Control": "Inversion of Control",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "In the thought of Inversion of Control (IoC) is the following alternative variant that sets the HttpClient as an explicit dependency in the constructor (also known as constructor injection).",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "Now UserRepository is no longer responsible for creating the HttpClient, but the user of UserRepository. This is Inversion of Control (IoC). The control has been reversed or inverted. Specifically, this code applies dependency injection, because dependencies are received (injected) and no longer created or requested. Dependency Injection is only one variant of IoC.",
        "Service Locator": "Service Locator",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "Besides DI, Service Locator (SL) is also a way to apply the IoC principle. This is commonly considered the counterpart to Dependency Injection, as it requests dependencies rather than receiving them. If HttpClient were requested in the above code as follows, it would be called a Service Locator pattern.",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "The function `locator.getHttpClient` can have any name. Alternatives would be function calls like `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` or a container call like `container.get(HttpClient)`. An import of a global is a slightly different variant of a service locator, using the module system itself as the locator:",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "All these variants have in common that they explicitly request the HttpClient dependency. This request can happen not only to properties as a default value, but also somewhere in the middle of the code. Since in the middle of the code means that it is not part of a type interface, the use of the HttpClient is hidden. Depending on the variant of how the HttpClient is requested, it can sometimes be very difficult or completely impossible to replace it with another implementation. Especially in the area of unit tests and for the sake of clarity, difficulties can arise here, so that the service locator is now classified as an anti-pattern in certain situations.",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "With Dependency Injection, nothing is requested, but it is explicitly provided by the user or received by the code. As can be seen in the example of Inversion of Control, the dependency injection pattern has already been applied there. Specifically, constructor injection can be seen there, since the dependency is declared in the constructor. So UserRepository must now be used as follows.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "The code that wants to use UserRepository must also provide (inject) all its dependencies. Whether HttpClient should be created each time or the same one should be used each time is now decided by the user of the class and no longer by the class itself. It is no longer requested (from the class's point of view) as in the case of the service locator, or created entirely by itself in the initial example. This inversion of the flow has various advantages:",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "The code is easier to understand because all dependencies are explicitly visible.",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "The code is easier to test because all dependencies are unique and can be easily modified if needed.",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "The code is more modular, as dependencies can be easily exchanged.",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "It promotes the Separation of Concern principle, as UserRepository is no longer responsible for creating very complex dependencies itself when in doubt.",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "But an obvious disadvantage can also be recognized directly: Do I really need to create or manage all dependencies like the HttpClient myself? Yes and No. Yes, there are many cases where it is perfectly legitimate to manage the dependencies yourself. The hallmark of a good API is that dependencies don't get out of hand, and that even then they are pleasant to use. For many applications or complex libraries, this may well be the case. To provide a very complex low-level API with many dependencies in a simplified way to the user, facades are wonderfully suitable.",
        "Dependency Injection Container": "Dependency Injection Container",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "For more complex applications, however, it is not necessary to manage all dependencies yourself, because that is exactly what a so-called dependency injection container is for. This not only creates all objects automatically, but also \"injects\" the dependencies automatically, so that a manual \"new\" call is no longer necessary. There are various types of injection, such as constructor injection, method injection, or property injection. This makes it easy to manage even complicated constructions with many dependencies.",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "A dependency injection container (also called DI container or IoC container) brings Deepkit in `@deepkit/injector` or already ready integrated via app modules in the Deepkit framework. The above code would look like this using a low-level API from the `@deepkit/injector` package.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "The `injector` object in this case is the dependency injection container. Instead of using \"new UserRepository\", the container returns an instance of UserRepository using `get(UserRepository)`. To initialize the container statically a list of providers is passed to the function `InjectorContext.forProviders` (in this case simply the classes).",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "Since DI is all about providing dependencies, the dependencies are provided to the container, hence the technical term \"provider\". There are various types of providers: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. All together, they allow very flexible architectures to be mapped with a DI container.",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "All dependencies between providers are automatically resolved and as soon as an `injector.get()` call occurs, the objects and dependencies are created, cached, and correctly passed either as a constructor argument (constructor injection), set as a property (property injection), or passed to a method call (method injection).",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "Now to exchange the HttpClient with another one, another provider (here the ValueProvider) can be defined for HttpClient:",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "As soon as UserRepository is requested via `injector.get(UserRepository)`, it receives the AnotherHttpClient object. Alternatively, a ClassProvider can be used here very well, so that all dependencies of AnotherHttpClient are also managed by the DI container.",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "All types of providers are listed and explained in the <<dependency-injection-providers>> section.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "It should be mentioned here that Deepkit's DI container only works with Deepkit's runtime types. This means that any code that contains classes, types, interfaces, and functions must be compiled by the Deepkit Type Compiler in order to have the type information available at runtime. See the chapter <<runtime-types>>.",
        "Dependency Inversion": "Dependency Inversion",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "The example of UserRepository under Inversion of Control shows that UserRepository depends on a lower level HTTP library. In addition, a concrete implementation (class) is declared as a dependency instead of an abstraction (interface). At first glance, this may seem to be in line with the object-oriented paradigms, but it can lead to problems, especially in complex and large architectures.",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "An alternative variant would be to convert the HttpClient dependency into an abstraction (interface) and thus not import code from an HTTP library into UserRepository.",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "This is called the dependency inversion principle. UserRepository no longer has a dependency directly on an HTTP library and is instead based on an abstraction (interface). It thus solves two fundamental goals in this principle:",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "High-level modules should not import anything from low-level modules.",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "Implementations should be based on abstractions (interfaces).",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "Merging the two implementations (UserRepository with an HTTP library) can now be done via the DI container.",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "Since Deepkit's DI container is capable of resolving abstract dependencies (interfaces) like this one of HttpClientInterface, UserRepository automatically gets the implementation of HttpClient since HttpClient implemented the interface HttpClientInterface. This is done either by HttpClient specifically implementing HttpClientInterface (`class HttpClient implements HttpClientInterface`), or by HttpClient's API simply being compatible with HttpClientInterface.",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "As soon as HttpClient modifies its API (for example, removes the `get` method) and is thus no longer compatible with HttpClientInterface, the DI container throws an error (\"the HttpClientInterface dependency was not provided\").",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "Here the user, who wants to bring both implementations together, is in the obligation to find a solution. As an example, an adapter class could be registered here that implements HttpClientInterface and correctly forwards the method calls to HttpClient.",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "It should be noted here that although in theory the dependency inversion principle has its advantages, in practice it also has significant disadvantages. It not only leads to more code (since more interfaces have to be written), but also to more complexity (since each implementation now has an interface for each dependency). This price to pay is only worth it when the application reaches a certain size and this flexibility is needed. Like any design pattern and principle, this one has its cost-use factor, which should be thought through before it is applied.",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "Design patterns should not be used blindly and across the board for even the simplest code. However, if the prerequisites such as a complex architecture, large applications, or a scaling team are given, dependency inversion and other design patterns only unfold their true strength.",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since Dependency Injection in Deepkit is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/injector` can be installed by itself or the Deepkit framework which already uses the library under the hood.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Once the library is installed, the API of it can be used directly.",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "To use Dependency Injection now, there are three ways.",
        "Injector API (Low Level)": "Injector API (Low Level)",
        "Module API": "Modules API",
        "App API (Deepkit Framework)": "App API (Deepkit Framework)",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "If `@deepkit/injector` is to be used without the deepkit framework, the first two variants are recommended.",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "The Injector API has already been introduced in the introduction to Dependency Injection. It is characterized by a very simple usage by means of a single class `InjectorContext` which creates a single DI container and is particularly suitable for simpler applications without modules.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "The `injector` object in this case is the dependency injection container. The function `InjectorContext.forProviders` takes an array of providers. See the <<dependency-injection-providers>> section to learn what values can be passed.",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "A more complex API is the `InjectorModule` class, which allows to store the providers in different modules to create multiple encapsulated DI containers per module. Also this allows using configuration classes per module, which makes it easier to provide configuration values automatically validated to the providers. Modules can import themselves among themselves, providers export, in order to build up so a hierarchy and nicely separated architecture.",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "This API should be used if the application is more complex and the Deepkit framework is not used.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "The `injector` object in this case is the dependency injection container. Providers can be split into different modules and then imported again in different places using module imports. This creates a natural hierarchy that maps the hierarchy of the application or architecture.",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "The InjectorContext should always be given the top module in the hierarchy, also called root module or app module. The InjectorContext then only has an intermediary task: calls to `injector.get()` are simply forwarded to the root module. However, it is also possible to get providers from non-root modules by passing the module as a second argument.",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "All non-root modules are encapsulated by default, so that all providers in this module are only available to itself. If a provider is to be available to other modules, this provider must be exported. By exporting, the provider moves to the parent module of the hierarchy and can be used that way.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "To export all providers by default to the top level, the root module, the option `forRoot` can be used. This allows all providers to be used by all other modules.",
        "App API": "App API",
        "Einführung": "Introduction",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Once the Deepkit framework is used, modules are defined with the `@deepkit/app` API. This is based on the Module API, so the capabilities from there are also available. In addition, it is possible to work with powerful hooks and to define configuration loaders in order to map even more dynamic architectures.",
        "Providers": "Providers",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "There are several ways to provide dependencies in the Dependency Injection container. The simplest variant is simply the specification of a class. This is also known as short ClassProvider.",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "This represents a special provider, since only the class is specified. All other providers must be specified as object literals.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "By default, all providers are marked as singletons, so only one instance exists at any given time. To create a new instance each time a provider is deployed, the `transient` option can be used. This will cause classes to be recreated each time or factories to be executed each time.",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "Besides the short ClassProvider there is also the regular ClassProvider, which is an object literal instead of a class.",
        "Dies ist Äquivalent zu diesen beiden:": "This is equivalent to these two:",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "It can be used to exchange a provider with another class.",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "In this example, the `OtherUserRepository` class is now also managed in the DI container and all its dependencies are resolved automatically.",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "Static values can be provided with this provider.",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "Since not only class instances can be provided as dependencies, any value can be specified as `useValue`. A symbol or a primitive (string, number, boolean) could also be used as a provider token.",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "Primitive provider tokens must be declared with the Inject type as a dependency.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "The combination of an inject alias and primitive provider tokens can also be used to provide dependencies from packages that do not contain runtime type information.",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "And then declared on the user side as follows:",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "A forwarding to an already defined provider can be defined.",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "A function can be used to provide a value for the provider. This function can also contain parameters, which in turn are provided by the DI container. Thus, other dependencies or configuration options are accessible.",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "In addition to classes and primitives, abstractions (interfaces) can also be provided. This is done via the function `provide` and is particularly useful if the value to be provided does not contain any type information.",
        "Asynchronous Providers": "Asynchronous Providers",
        "Asynchroner Provider sind aufgrund des Designs nicht möglich, da eine asynchroner": "Asynchronous providers are not possible due to the design, since an asynchronous",
        "Dependency Injection Container bedeuten würde, dass das Anfordern von Providern ebenfalls asynchron": "Dependency Injection container would mean that requesting providers would also be asynchronous.",
        "wäre und damit die gesamte Anwendung auf höchster Ebene bereits zur asynchronität gezwungen ist.": "would be and thus the entire application is already forced to asynchrony at the highest level.",
        "Um etwas asynchron zu initialisieren, sollte dieses Initialisieren in den Application Server Bootstrap verlagert werden,": "To initialize something asynchronously, this initialization should be moved to the application server bootstrap,",
        "da dort die Events asynchron sein können. Alternativ kann eine Initialisierung manuell angestossen werden.": "because there the events can be asynchronous. Alternatively, an initialization can be triggered manually.",
        "TODO: Explain it better, maybe example": "TODO: Explain it better, maybe example",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "If multiple providers have implemented the Connection interface, the last provider is used.",
        "Als Argument für provide() sind alle anderen Provider möglich.": "As argument for provide() all other providers are possible.",
        "Constructor/Property Injection": "Constructor/Property Injection",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "In most cases, constructor injection is used. All dependencies are specified as constructor arguments and are automatically injected by the DI container.",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "Optional dependencies should be marked as such, otherwise an error could be triggered if no provider can be found.",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "An alternative to constructor injection is property injection. This is usually used when the dependency is optional or the constructor is otherwise too full. The properties are automatically assigned once the instance is created (and thus the constructor is executed).",
        "Konfiguration": "Configuration",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "The dependency injection container also allows configuration options to be injected. This configuration injection can be received via constructor injection or property injection.",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "The Module API supports the definition of a configuration definition, which is a regular class. By providing such a class with properties, each property acts as a configuration option. Because of the way classes can be defined in TypeScript, this allows defining a type and default values per property.",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "The configuration options `domain` and `debug` can now be used quite conveniently type-safe in providers.",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "The values of the options themselves can be set via `configure()`.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Options that do not have a default value but are still necessary can be provided with a `!`. This forces the user of the module to provide the value, otherwise an error will occur.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Also, all serialization and validation types from the previous <<validation>> and <<serialization>> chapters can be used to specify in great detail what type and content constraints an option must have.",
        "Injection": "Injection",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "Configuration options, like other dependencies, can be safely and easily injected through the DI container as shown earlier. The simplest method is to reference a single option using the index access operator:",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "Configuration options can be referenced not only individually, but also as a group. The TypeScript utility type `Partial` is used for this purpose:",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "To get all configuration options, the configuration class can also be referenced directly:",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "However, it is recommended to reference only the configuration options that are actually used. This not only simplifies unit tests, but also makes it easier to see what is actually needed from the code.",
        "Scopes": "Scopes",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "By default, all providers of the DI container are singletons and are therefore instantiated only once. This means that in the example of UserRepository there is always only one instance of UserRepository during the entire runtime. At no time is a second instance created, unless the user does this manually with the \"new\" keyword.",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "However, there are various use cases where a provider should only be instantiated for a short time or only during a specific event. Such an event could be, for example, an HTTP request or an RPC call. This would mean that a new instance is created for each event and after this instance is no longer used it is automatically removed (by the garbage collector).",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "An HTTP request is a classic example of a scope. For example, providers such as a session, a user object, or other request-related providers can be registered to this scope. To create a scope, simply choose an arbitrary scope name and then specify it with the providers.",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "Once a scope is specified, this provider cannot be obtained directly from the DI container, so the following call will fail:",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "Instead, a scoped DI container must be created. This would happen every time an HTTP request comes in:",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "Providers that are also registered in this scope can now be requested on this scoped DI container, as well as all providers that have not defined a scope.",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "Since all providers are singleton by default, each call to `get(UserSession)` will always return the same instance per scoped container. If you create multiple scoped containers, multiple UserSessions will be created.",
        "Scoped DI Container haben die Fähigkeit, Werte dynamisch von außen zu setzen. So ist es zum Beispiel bei einem HTTP-Scope einfach möglich, die Objekte HttpRequest und HttpResponse zu setzen.": "Scoped DI containers have the ability to set values dynamically from the outside. For example, in an HTTP scope, it is easy to set the HttpRequest and HttpResponse objects.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "Applications using the Deepkit framework have by default an `http`, an `rpc`, and a `cli` scope. See the chapter <<cli>>, <<http>>, or <<rpc>> respectively.",
        "Setup Calls": "Setup Calls",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "Setup calls allow to manipulate the result of a provider. This is useful for example to use another dependency injection variant, the method injection.",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "Setup calls can only be used with the module API or the app API and are registered above the module.",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "The `setupProvider` method thereby returns a proxy object of UserRepository on which its methods can be called. It should be noted that these method calls are merely placed in a queue and are not executed at this time. Accordingly, no return value is returned.",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "In addition to method calls, properties can also be set.",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "This assignment is also simply placed in a queue.",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "The calls or the assignments in the queue are then executed on the actual result of the provider as soon as this is created. That is with a ClassProvider these are applied to the class instance, as soon as the instance is created, with a FactoryProvider on the result of the Factory, and with a ValueProvider on the Provider.",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "To reference not only static values, but also other providers, the function `injectorReference` can be used. This function returns a reference to a provider, which is also requested by the DI container when the setup calls are executed.",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces*",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Setup calls can also be assigned to an interface.",
        "Event System": "Event System",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "An event system allows application components in the same process to communicate with each other by sending and listening for events. It helps modularize the code by sending messages between functions that do not know about each other directly.",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "The application or library opens the possibility to execute additional functions at a certain time of the execution. These additional functions register themselves as so-called event listeners.",
        "Ein Event kann dabei vielfältig sein:": "An event can be multifaceted:",
        "Die Anwendung fährt hoch oder runter.": "The application goes up or down.",
        "Ein neuer User wurde erstellt oder gelöscht.": "A new user has been created or deleted.",
        "Eine Error wurde geworfen.": "An error was thrown.",
        "Ein neuer HTTP-Request ist hereingekommen.": "A new HTTP request has come in.",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit Framework and its libraries already offer various events to which the user can listen and react. However, any number of custom events can be created to make the application modularly extensible.",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "Below is an example of the low-level API of `@deepkit/event`. When using Deepkit framework, event listener registration is not done via `EventDispatcher` directly but via modules.",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since Deepkit's event system is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/event` can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "Note that `@deepkit/event` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.",
        "Event Token": "Event token",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "At the heart of the event system are the event tokens. They are objects that define the unique event ID and the event type. An event can be triggered and an event can be listened to via an event token. Conceptually, the person who triggers the event of an event token is also the owner of this event token. The event token decides accordingly which data is available at the event and whether asynchronous event listeners are allowed.",
        "TODO asynchrone": "TODO asynchronous",
        "Event Types": "Event Types",
        "Propagation": "Propagation",
        "TODO. event.stop()": "TODO. event.stop()",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Command-line Interface (CLI) programs are programs that interact via the terminal in the form of text input and text output. The advantage of interacting with the application in this variant is that only a terminal must exist either locally or via an SSH connection.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "A CLI application in Deepkit has full access to the DI container and can thus access all providers and configuration options.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "The arguments and options of the CLI application are controlled by method parameters via TypeScript types and are automatically serialized and validated.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI is one of three entry points to a Deepkit Framework application. In the Deepkit framework, the application is always launched via a CLI program, which is itself written in TypeScript by the user. Therefore, there is no Deepkit specific global CLI tool to launch a Deepkit application. This is how you launch the HTTP/RPC server, perform migrations, or run your own commands. This is all done through the same entry point, the same file. Once the Deepkit framework is used by importing `FrameworkModule` from `@deepkit/framework`, the application gets additional commands for the application server, migrations, and more.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "The CLI framework allows you to easily register your own commands and is based on simple classes. In fact, it is based on `@deepkit/app`, a small package intended only for this purpose, which can also be used standalone without the deepkit framework. In this package you can find decorators that are needed to decorate the CLI controller class.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "Controllers are managed or instantiated by the dependency injection container and can therefore use other providers. See the <<dependency-injection>> chapter for more details.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since CLI programs in Deepkit are based on Runtime Types, it is necessary to have @deepkit/type already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, @deepkit/app can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Note that `@deepkit/app` is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators`.",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "To create a command for your application, you need to create a CLI controller. This is a simple class that has an `exeecute` method and is equipped with information about the command.",
        "_Datei: app.ts_": "_File: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "In the decorator `@cli.controller` the unique name of the CLI application is defined as the first argument. Further options like a description can be optionally added in the object at the second position.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "This code is already a complete CLI application and can be started this way:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "You can see that a \"test\" command is available. To execute this, the name must be passed as an argument:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "It is also possible to make the file executable using `chmod +x app.ts`, so that the command `./app.ts` is already sufficient to start it. Note that then a so-called",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang is necessary. Shebang denotes the character combination `#!` at the beginning of a script program. In the example above this is already present: `&#35;!/usr/bin/env ts-node-script` and uses the script mode of `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "In this way, any number of commands can be created and registered. The unique name specified in `@cli.controller` should be well chosen and allows grouping of commands with the `:` character (e.g. `user:create`, `user:remove`, etc).",
        "Argumente": "Arguments",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "To add arguments, new parameters are added to the `execute` method and decorated with the `@arg` decorator.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "If you execute this command now without specifying a name, an error will be issued:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "By using `--help` you will get more information about the required arguments:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Once the name is passed as an argument, the `execute` method in TestCommand is executed and the name is passed correctly.",
        "Flags": "Flags",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags are another way to pass values to your command. Mostly these are optional, but they don`t have to be. Parameters decorated with `@flag name` can be passed via `--name value` or `--name=value`.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "In the help view you can see in the \"OPTIONS\" that a `--id` flag is necessary. If you enter this flag correctly, the command will receive this value.",
        "Boolean Flags": "Boolean Flags",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flags have the advantage that they can also be used as a worthless flag, for example to activate a certain behavior. As soon as a parameter is marked as an optional Boolean, this behavior is activated.",
        "Multiple Flags": "Multiple Flags",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "To pass multiple values to the same flag, a flag can be marked as an array.",
        "Single Character Flags": "Single Character Flags",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "To allow a flag to be passed as a single character as well, `@flag.char('x')` can be used.",
        "Optional / Default": "Optional / Default",
        "Dasselbe für Parameter mit einem Default-Wert:": "The same for parameters with a default value:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "This also applies to flags in the same way.",
        "Serialization / Validation": "Serialization / Validation",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "All arguments and flags are automatically deserialized based on its types, validated and can be provided with additional constraints.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "Thus, arguments defined as numbers are always guaranteed to be real numbers in the controller, even though the command-line interface is based on text and thus strings. The conversion happens automatically with the feature <<serialization-loosely-conversion>>.",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Additional constraints can be defined with the type decorators from `@deepkit/type`.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "The type `Postive` in `id` indicates that only positive numbers are wanted. If the user now passes a negative number, the code in `execute` will not be executed at all and an error message will be presented.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "If the number is positive, this works again as before. This additional validation, which is very easy to do, makes the command much more robust against wrong entries. See the chapter <<validation>> for more information.",
        "Description": "Description",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "To describe a flag or argument, `@flag.description` or `@arg.description` can be used respectively.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "In the help view, this description appears after the flag or argument:",
        "Exit code": "Exit code",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "The exit code is 0 by default, which means that the command was executed successfully. To change the exit code, a number other than 0 should be returned in the `exucute` method.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "The class of the command is managed by the DI Container, so dependencies can be defined that are resolved via the DI Container.",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "Processing HTTP requests is one of the most well-known tasks for a server. It converts an input (HTTP request) into an output (HTTP response) and performs a specific task. A client can send data to the server via an HTTP request in a variety of ways, which must be read and handled correctly. In addition to the HTTP body, HTTP query or HTTP header values are also possible. How data is actually processed depends on the server. It is the server that defines where and how the values are to be sent by the client.",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "The top priority here is not only to correctly execute what the user expects, but to correctly convert (deserialize) and validate any input from the HTTP request.",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "The pipeline through which an HTTP request passes on the server can be varied and complex. Many simple HTTP libraries pass only the HTTP request and the HTTP response for a given route, and expect the developer to process the HTTP response directly. A middleware API allows the pipeline to be extended as needed.",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "This is very well tailored for simple use cases, but quickly becomes confusing as the application grows, since all inputs and outputs must be manually serialized or deserialized and validated. Also, consideration must be given to how objects and services such as a database abstraction can be obtained from the application itself. It forces the developer to put an architecture on top of it that maps these mandatory functionalities.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Deepkit's HTTP library leverages the power of TypeScript and Dependency Injection. Serialization/deserialization and validation of any values happen automatically based on the defined types. It also allows defining routes either via a functional API as in the example above or via controller classes to cover the different needs of an architecture.",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "It can be used either with an existing HTTP server like Node's `http` module or with the Deepkit framework. Both API variants have access to the dependency injection container and can thus conveniently retrieve objects such as a database abstraction and configurations from the application.",
        "_Deepkit Beispiel_": "_Deepkit Example_",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since CLI programs in Deepkit are based on runtime types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Siehe dazu xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].": "See xref:runtime-types.adoc#runtime-types-installation[Runtime Type Installation].",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "Note that `@deepkit/http` for the controller API is based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators` once the controller API is used.",
        "Funktionale API": "Functional API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "The functional API is based on functions and can be registered via the router registry, which can be obtained via the DI container of the app.",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "The router registry can also be obtained in Event Listener or in the bootstrap, so that based on modules, configurations and other providers various routes are registered.",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "Once modules are used, functional routes can also be provided dynamically by modules.",
        "Siehe <<framework-modules>>, um mehr über App Module zu erfahren.": "See <<framework-modules>> to learn more about App Modules.",
        "Controller API": "Controller API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "The controller API is based on classes and can be registered via the App-API under the option `controllers`.",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "Once modules are used, controllers can also be provided by modules.",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "To provide controllers dynamically (depending on the configuration option, for example), the `process` hook can be used.",
        "HTTP Server": "HTTP Server",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "If Deepkit Framework is used, an HTTP server is already built in. However, the HTTP library can also be used with its own HTTP server without using the Deepkit framework.",
        "HTTP Client": "HTTP Client",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name that can be referenced when forwarding. Depending on the API, the way a name is defined differs.",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "From all routes with a name the URL can be requested by `Router.resolveUrl()`.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "The router functions as well as the controller classes and controller methods can define arbitrary dependencies, which are resolved by the dependency injection container. For example, it is possible to conveniently get to a database abstraction or logger.",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "For example, if a database has been provided as a provider, it can be injected:",
        "_Funktionaler API:_": "_Functional API:_",
        "_Controller API:_": "_Controller API:_",
        "Siehe <<dependency-injection>> für mehr Informationen.": "See <<dependency-injection>> for more information.",
        "Input": "Input",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "All of the following input variations function in the same way for both the functional and the controller API. They allow to read data from an HTTP request in a type-safe and decoupled way.",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "This leads not only to significantly increased security, but also easier unit testing,",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "since, strictly speaking, not even an HTTP request object needs to exist to test the route.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "All parameters are automatically converted (deserialized) to the defined TypeScript type and validated. This is done via the `@deepkit/type` package and its <<serialization>> and <<validation>> features.",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "For simplicity, all examples with the functional API are shown below.",
        "Path Parameters": "Path Parameters",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "Path parameters are values extracted from the URL of the route. The type of the value depends on the type at the associated parameter of the function or method.",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "The conversion is done automatically with the <<serialization-loosely-conversion>> feature.",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "If a Path parameter is defined as a type other than string, it will be converted correctly.",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "Additional validation constraints can also be applied to the types.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in <<http-validation>> zu finden.": "All validation types from `@deepkit/type` can be applied. More about this can be found in <<http-validation>>.",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "The Path parameters have `[^/]+` set as a regular expression by default in the URL matching. The RegExp for this can be customized as follows:",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "This is only necessary in exceptional cases, because often the types in combination with validation types themselves already correctly restrict possible values.",
        "Query Parameters": "Query Parameters",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "Query parameters are values from the URL after the `?` character and can be read with the `HttpQuery<T>` type. The name of the parameter corresponds to the name of the query parameter.",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "Query parameters are also automatically deserialized and validated.",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*Warning*: Parameter values are not escaped/sanitized. Returning them directly in a string in a route as HTML opens a security hole (XSS). Make sure never to trust external input and filter/sanitize/convert data where necessary.",
        "Query Model": "Query Model",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "With a large number of query parameters, it can quickly become confusing. To bring order back in here, a model (class or interface) can be used, which summarizes all possible query parameters.",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "The properties in the given model can contain all TypeScript types and validation types that `@deepkit/type` supports. See the <<serialization>> and <<validation>> chapters.",
        "Body": "Body",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "For HTTP methods that allow an HTTP body, a body model can also be specified.",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "The body content type from the HTTP request must be either `application/x-www-form-urlencoded`, `multipart/form-data` or `application/json` so Deepkit can automatically convert this to JavaScript objects.",
        "Header": "Header",
        "Stream": "Stream",
        "Manual Validation Handling": "Manual Validation Handling",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "To manually take over the validation of the body model, a special type `HttpBodyValidation<T>` can be used. It allows to receive also invalid body data and to react very specifically to error messages.",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "As soon as `valid()` returns `false`, the values in the specified model may be in a faulty state. This means that the validation has failed. If `HttpBodyValidation` is not used and an incorrect HTTP request is received, the request would be directly aborted and the code in the function would never be executed. Use `HttpBodyValidation` only if, for example, error messages regarding the body should be manually processed in the same route.",
        "File Upload": "File Upload",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "A special property type on the body model can be used to allow the client to upload files. Any number of `UploadedFile` can be used.",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "By default, Router saves all uploaded files to a temp folder and removes them once the code in the route has been executed. It is therefore necessary to read the file in the specified path in `path` and save it to a permanent location (local disk, cloud storage, database).",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Validation in an HTTP server is a mandatory functionality, because almost always work with data that is not trustworthy. The more places data is validated, the more stable the server is. Validation in HTTP routes can be conveniently used via types and validation constraints and is checked with a highly optimized validator from `@deepkit/type`, so there are no performance problems in this regard. It is therefore highly recommended to use these validation capabilities as well. Better one time too much, than one time too little.",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "All inputs such as path parameters, query parameters, and body parameters are automatically validated for the specified TypeScript type. If additional constraints are specified via `@deepkit/type` types, these are also checked.",
        "Siehe <<validation>> für mehr Informationen dazu.": "See <<validation>> for more information on this.",
        "Output": "Output",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "A route can return various data structures. Some of them are handled in a special way, such as redirects and templates, and others, such as simple objects, are simply sent as JSON.",
        "JSON": "JSON",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "By default, normal JavaScript values are returned to the client as JSON with the header `application/json; charset=utf-8`.",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "If an explicit return type is specified for the function or method, the data is serialized to JSON with the Deepkit JSON Serializer according to this type.",
        "HTML": "HTML",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "To send HTML there are two possibilities. Either the object `HtmlResponse` or Template Engine with TSX is used.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu <<template>>.": "The template engine variant with TSX has the advantage that used variables are automatically HTML-escaped. See <<template>>.",
        "Custom Content": "Custom Content",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "Besides HTML and JSON it is also possible to send text or binary data with a specific content type. This is done via the object `Response`.",
        "HTTP Errors": "HTTP Errors",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "By throwing various HTTP errors, it is possible to immediately interrupt the processing of an HTTP request and output the corresponding HTTP status of the error.",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "By default, all errors are returned to the client as JSON. This behavior can be customized in the event system under the event `httpWorkflow.onControllerError`. See the section <<http-events>>.",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "The error `HttpAccessDeniedError` is a special case. As soon as it is thrown, the HTTP workflow (see <<http-events>>) does not jump to `controllerError` but to `accessDenied`.",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "Custom HTTP errors can be created and thrown with `createHttpError`.",
        "Zusätzliche Header": "Additional headers",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "To modify the header of an HTTP response, additional methods can be called on the `Response`, `JSONResponse`, and `HTMLResponse` objects.",
        "Redirect": "Redirect",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "To return a 301 or 302 redirect as a response, `Redirect.toRoute` or `Redirect.toUrl` can be used.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "The `Redirect.toRoute` method uses the name of the route. How to set a route name can be seen in the <<http-route-name>> section. If this referenced route (query or path) contains parameters, they can be specified via the second argument:",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "Alternatively, you can redirect to a URL with `Redirect.toUrl`.",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "By default, both use a 302 forwarding. This can be customized via the `statusCode` argument.",
        "Scope": "Scope",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "All HTTP controllers and functional routes are managed within the `http` dependency injection scope. HTTP controllers are instantiated accordingly for each HTTP request. This also means that both can access providers registered for the `http` scope. So additionally `HttpRequest` and `HttpResponse` from `@deepkit/http` are usable as dependencies. If Deepkit Framework is used, `SessionHandler` from `@deepkit/framework` is also available.",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "It can be useful to place providers in the `http` scope, for example to instantiate services for each HTTP request. Once the HTTP request has been processed, the `http` scoped DI container is deleted, thus cleaning up all its provider instances from the garbage collector (GC).",
        "Siehe <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "See <<dependency-injection-scopes>> to learn how to place providers in the `http` scope.",
        "Events": "Events",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "The HTTP module is based on a workflow engine that provides various event tokens that can be used to hook into the entire process of processing an HTTP request.",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "The workflow engine is a finite state machine that creates a new state machine instance for each HTTP request and then jumps from position to position. The first position is the `start` and the last one the `response`. Additional code can be executed in each position.",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "Each event token has its own event type with additional information.",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "Since all HTTP events are based on the workflow engine, its behavior can be modified by using the specified event and jumping there with the `event.next()` method.",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "The HTTP module uses its own event listeners on these event tokens to implement HTTP request processing. All these event listeners have a priority of 100, which means that when you listen for an event, your listener is executed first by default (since the default priority is 0). Add a priority above 100 to run after the HTTP module's event listeners.",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "For example, suppose you want to catch the event when a controller is invoked. If a particular controller is to be invoked, we check if the user has access to it. If the user has access, we continue. But if not, we jump to the next workflow item `accessDenied`. There, the procedure of an access-denied is then automatically processed further.",
        "Security": "Security",
        "Sessions": "Sessions",
        "Middleware": "Middleware",
        "Resolver": "Resolver",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "Router supports a way to resolve complex parameter types. For example, given a route such as `/user/:id`, this `id` can be resolved to a `user` object outside the route using a resolver. This further decouples HTTP abstraction and route code, further simplifying testing and modularity.",
        "Der Decorator in `@http.resolveParameter` gibt dabei an, welche Klasse mit dem `UserResolver` aufgelöst werden soll. Sobald nun die angegebene Klasse `User` als Parameter in der Funktion beziehungsweise Methode angegeben ist, wird der Resolver genutzt, um diese bereitzustellen.": "The decorator in `@http.resolveParameter` specifies which class is to be resolved with the `UserResolver`. As soon as the specified class `User` is specified as a parameter in the function or method, the resolver is used to provide it.",
        "Ist `@http.resolveParameter` an der Klasse angegeben, erhalten all Methoden dieser Klasse diesen Resolver. Der Decorator kann auch pro Methode angewendet werden:": "If `@http.resolveParameter` is specified at the class, all methods of this class get this resolver. The decorator can also be applied per method:",
        "Auch kann die funktionale API genutzt werden:": "Also, the functional API can be used:",
        "Das Objekt `User` muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der Benutzer eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle abbildbar sind.": "The `User` object does not necessarily have to depend on a parameter. It could just as well depend on a session or an HTTP header, and only be provided when the user is logged in. In `RouteParameterResolverContext` a lot of information about the HTTP request is available, so that many use cases can be mapped.",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "In principle, it is also possible to have complex parameter types provided via the Dependency Injection container from the `http` scope, since these are also available in the route function or method. However, this has the disadvantage that no asynchronous function calls can be used, since the DI container is synchronous throughout.",
        "RPC": "RPC",
        "RPC steht für Remote Procedure Call und erlaubt es, Funktionen (procedures) auf einem remote Server so aufzurufen als wäre es eine lokale Funktion. Im Gegensatz zu HTTP Client-Server Kommunikation geschieht die Zuordnung nicht über die HTTP-Methode und einer URL, sondern dem Funktionsnamen. Die zu sendenden Daten werden als normale Funktion-Argumente übergeben und das Resultat des Funktionsaufrufes auf dem Server an den Client zurückgesendet.": "RPC stands for Remote Procedure Call and allows to call functions (procedures) on a remote server as if it were a local function. In contrast to HTTP client-server communication, the assignment is not done via the HTTP method and a URL, but the function name. The data to be sent is passed as normal function arguments and the result of the function call on the server is returned to the client.",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion leichtgewichtiger ist, da weder mit Headern, URLs, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es oft einen speziellen Client benötigt.": "The advantage of RPC is that the client-server abstraction is more lightweight, since no headers, URLs, query strings or the like are used. The disadvantage is that functions on a server via RPC cannot be called easily by a browser and it often requires a special client.",
        "Ein Schlüsselfeature von RPC ist, dass die Daten zwischen dem Client und Server automatisch serialisiert und deserialisiert werden. Aus diesem Grund sind meist typen-sichere RPC-Clients möglich. Manche RPC-Frameworks zwingen den Benutzern daher, die Typen (Parameter-Types und Return-Types) in einem bestimmten Format bereitzustellen. Dies kann in Form von einer eigenen DSL wie bei gRPC (Protocol Buffers) und GraphQL mit einem Code-Generator sein oder in Form von einem JavaScript Schema-Builder. Zusätzliche Validierung der Daten kann das RPC-Framework ebenfalls anbieten, wird aber nicht von allen unterstützt.": "A key feature of RPC is that the data between the client and server is automatically serialized and deserialized. For this reason, type-safe RPC clients are usually possible. Some RPC frameworks therefore force users to provide the types (parameter types and return types) in a specific format. This can be in the form of a custom DSL as in gRPC (Protocol Buffers) and GraphQL with a code generator, or in the form of a JavaScript schema builder. Additional validation of the data can also be provided by the RPC framework, but is not supported by all.",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "In Deepkit RPC, the types from the functions are extracted from the TypeScript code itself (see <<runtime-types>>), so there is no need to use a code generator or define them manually. Deepkit supports automatic serialization and deserialization of parameters and results in this regard. Once additional constraints are defined from <<validation>>, they are also automatically validated. This makes communication via RPC extremely type-safe and effective. The support for streaming via `rxjs` in Deepkit RPC also makes this RPC framework a suitable tool for real-time communication.",
        "Um das Konzept hinter RPC zu veranschaulichen folgender Code:": "To illustrate the concept behind RPC the following code:",
        "Eine Methode wie `hello` wird ganz normal innerhalb einer Klasse auf dem Server implementiert und kann dann von einem remote Client aufgerufen werden.": "A method like `hello` is implemented normally within a class on the server and can then be called from a remote client.",
        "Da RPC fundamental auf asynchroner Kommunikation basiert, ist die Kommunikation meist über HTTP, kann aber auch über TCP oder WebSockets geschehen. Das bedeutet, dass alle Funktionsaufrufe in TypeScript selbst zu einem `Promise` umgewandelt werden. Mit einem entsprechenden `await` kann das Resultat asynchron empfangen werden.": "Since RPC is fundamentally based on asynchronous communication, communication is mostly over HTTP, but can also happen over TCP or WebSockets. This means that all function calls in TypeScript itself are converted to a `promise`. With a corresponding `await` the result can be received asynchronously.",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Sobald ein Projekt im Client (meist Frontend) und Server (backend) TypeScript genutzt wird, spricht man von Isomorphic TypeScript. Ein typen-sicheres RPC Framework, das auf TypeScript's Typen basiert, ist dann besonders profitable für ein solches Projekt, da Typen zwischen Client und Server geteilt werden können.": "As soon as a project uses TypeScript in the client (mostly frontend) and server (backend), it is called Isomorphic TypeScript. A type-safe RPC framework based on TypeScript's types is then particularly profitable for such a project, since types can be shared between client and server.",
        "Um diesen Vorteil zu nutzen, sollten Typen, die auf beiden Seiten genutzt werden, in eine eigene Datei oder Package ausgelagert werden. Das Importieren auf der jeweiligen Seite fügt diese dann wieder zusammen.": "To take advantage of this, types that are used on both sides should be swapped out into a separate file or package. Importing on the respective side will then merge them again.",
        "Das Interface `UserControllerApi` agiert hierbei als Vertrag zwischen Client und Server. Der Server muss dies korrekt implementieren und der Client kann es konsumieren.": "The interface `UserControllerApi` acts here as a contract between client and server. The server must implement this correctly and the client can consume it.",
        "Abwärtskompatiblität kann auf dieselbe Art und Weise umgesetzt werden wie bei einer normalen lokalen API auch: Entweder werden neue Parameter als optional markiert oder es wird eine neue Methode hinzugefügt.": "Backward compatibility can be implemented in the same way as for a normal local API: either new parameters are marked as optional or a new method is added.",
        "Es ist zwar auch möglich, direkt `UserController` via `import type { UserController } from './server.ts` zu importieren, so hat dies jedoch andere Nachteile wie keine Unterstützung für nominale Typen (was bedeutet, dass Klassen-Instanzen nicht mit `instanceof` geprüft werden können).": "While it is also possible to directly import `UserController` via `import type { UserController } from './server.ts`, this has other disadvantages like no support for nominal types (which means that class instances cannot be checked with `instanceof`).",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Since Deepkit RPC is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly. See <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/rpc` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "If this is done successfully, `@deepkit/rpc` can be installed or the Deepkit framework which already uses the library under the hood.",
        "Zu beachten ist, dass Controller-Klassen in `@deepkit/rpc` auf TypeScript-Decorators basieren und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss": "Note that controller classes in `@deepkit/rpc` are based on TypeScript decorators and this feature must be enabled accordingly with `experimentalDecorators`.",
        "Das Paket `@deepkit/rpc` muss auf dem Server und Client installiert werden, sofern beide ihre eigene `package.json` haben.": "The `@deepkit/rpc` package must be installed on the server and client if both have their own `package.json`.",
        "Um über TCP mit dem Server zu kommunizieren, muss das Paket `@deepkit/rpc-tcp` im Client und Server installiert werden.": "To communicate with the server via TCP, the `@deepkit/rpc-tcp` package must be installed in the client and server.",
        "Für eine WebSocket-Kommunikation braucht es das Paket ebenfalls auf dem Server. Der Client im Browser hingegen nutzt `WebSocket` aus dem offiziellen Standard.": "For a WebSocket communication it needs the package on the server as well. The client in the browser, on the other hand, uses `WebSocket` from the official standard.",
        "Sobald der Client über WebSocket auch in einer Umgebung genutzt werden soll, wo `WebSocket` nicht verfügbar ist (zum Beispiel NodeJS), so wird das Paket `ws` in dem Client benötigt.": "As soon as the client is to be used via WebSocket in an environment where `WebSocket` is not available (for example NodeJS), the package `ws` is required in the client.",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend WebSockets und der low-level API von `@deepkit/rpc`. Sobald das Deepkit Framework benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "Below is a fully functional example based on WebSockets and the low-level API of `@deepkit/rpc`. Once the Deepkit framework is used, controllers are provided via app modules and no RpcKernel is instantiated manually.",
        "_Datei: server.ts_": "_file: server.ts_",
        "_Datei: client.ts_": "_file: client.ts_",
        "Server Controller": "Server Controller",
        "Das \"Procedure\" in Remote Procedure Call wird auch gerne Action genannt. Eine solche Action wird als Methode in einer Klasse definiert und mit dem `@rpc.action` Decorator markiert. Die Klasse selbst wird dabei als Controller durch den `@rpc.controller` Decorator markiert und einen eindeutigen Namen vergeben. Dieser Name wird dann im Client referenziert, um den korrekten Controller anzusprechen. Es können beliebig viele Controller definiert und registriert werden.": "The \"Procedure\" in Remote Procedure Call is also called Action. Such an action is defined as a method in a class and marked with the `@rpc.action` decorator. The class itself is marked as controller by the `@rpc.controller` decorator and assigned a unique name. This name is then referenced in the client to address the correct controller. Any number of controllers can be defined and registered.",
        "Nur Methoden, die auch als `@rpc.action()` markiert sind, können von einem Client angesprochen werden.": "Only methods that are also marked as `@rpc.action()` can be accessed by a client.",
        "Typen müssen explizit angeben werden und können nicht inferred werden. Das ist wichtig, da der Serializer genau wissen muss, wie die Typen aussehen, um diese in Binärdaten (BSON) oder JSON umzuwandeln.": "Types must be explicitly specified and cannot be inferred. This is important because the serializer needs to know exactly what the types are in order to convert them to binary data (BSON) or JSON.",
        "Client Controller": "Client Controller",
        "Der normale Flow in RPC ist es, dass der Client Funktionen auf dem Server ausführen kann. Es ist aber in Deepkit RPC auch möglich, dass der Server Funktionen auf dem Client ausführen kann. Um das zu erlauben, kann der Client ebenfalls einen Controller registrieren.": "The normal flow in RPC is that the client can perform functions on the server. However, it is also possible in Deepkit RPC for the server to perform functions on the client. To allow this, the client can also register a controller.",
        "Die Controller-Klassen werden von dem Dependency Injection Container von `@deepkit/injector` verwaltet. Wenn das Deepkit Framework genutzt wird, haben diese Controller automatisch zugriff auf die Provider des Modules, die den Controller bereitstellen.": "The controller classes are managed by the dependency injection container of `@deepkit/injector`. When the Deepkit framework is used, these controllers automatically have access to the module's providers that deploy the controller.",
        "Controller werden in dem Deepkit Framework in dem Dependency Injection Scope `rpc` instantiiert, sodass alle Controller automatisch auf diverse Provider aus diesem Scope zugriff haben. Diese zusätzlichen Provider sind `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, und `ConnectionWriter`.": "Controllers are instantiated in the Deepkit framework in the dependency injection scope `rpc` so that all controllers automatically have access to various providers from this scope. These additional providers are `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, and `ConnectionWriter`.",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden. Der RPC Controller wird dann über diesen DI Container instantiiert.": "However, as soon as a `RpcKernel` is instantiated manually, a DI container can also be passed there. The RPC controller is then instantiated via this DI container.",
        "Siehe <<dependency-injection>>, um mehr zu erfahren.": "See <<dependency-injection>> to learn more.",
        "Nominal Types": "Nominal Types",
        "Wenn Daten auf dem Client von dem Funktionsaufruf empfangen werden, wurden diese zuvor auf dem Server serialisiert und anschließend auf dem Client deserialisiert. Sind in dem Return-Typ der Funktion nun Klassen genutzt, werden diese im Client rekonstruiert, verlieren jedoch ihre nominale Identität und alle Methoden. Um diesem Verhalten entgegenzuwirken, können Klassen als nominale Typen über eine eindeutige ID registriert werden. Dies sollte für alle Klassen gemacht werden, die in einer RPC-API genutzt werden.": "When data is received on the client from the function call, it was previously serialized on the server and then deserialized on the client. If classes are now used in the return type of the function, they are reconstructed in the client, but lose their nominal identity and all methods. To counteract this behavior, classes can be registered as nominal types via a unique ID. This should be done for all classes used in an RPC API.",
        "Um eine Klasse zu registrieren ist das Nutzen von dem Decorator `@entity.name('id')` nötig.": "To register a class it is necessary to use the decorator `@entity.name('id')`.",
        "Sobald diese Klasse nun als Resultat einer Funktion genutzt wird, wird ihre Identität gewahrt.": "As soon as this class is now used as the result of a function, its identity is preserved.",
        "Error Forwarding": "Error Forwarding",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu <<rpc-nominal-types>>.": "RPC functions can throw errors. These errors are forwarded to the client by default and thrown again there. If custom error classes are used, their nominal type should be enabled. See <<rpc-nominal-types>> for this.",
        "Standardmäßig sind alle RPC Funktionen von jedem Client aus aufrufbar. Auch ist das Feature Peer-To-Peer Kommunikation standardmäßig aktiviert. Um hier genau einstellen zu können, welcher Client was darf, kann die Klasse `RpcKernelSecurity` überschrieben werden.": "By default, all RPC functions can be called from any client. Also the feature Peer-To-Peer communication is activated by default. To be able to set exactly which client is allowed to do what, the class `RpcKernelSecurity` can be overridden.",
        "Um diese zu nutzen wird entweder dem `RpcKernel` eine Instanz davon übergeben:": "To use this either the `RpcKernel` is passed an instance of it:",
        "Oder im Falle einer Deepkit Framework Anwendung die Klasse `RpcKernelSecurity` mit einem Provider überschrieben.": "Or in the case of a Deepkit Framework application the class `RpcKernelSecurity` is overwritten with a provider.",
        "Authentication / Session": "Authentication / Session",
        "Das Objekt `Session` ist standardmäßig eine anonyme Session, was bedeutet, dass der Client sich nicht authentifiziert hat. Sobald er sich authentifizieren will, wird die Methode `authenticate` aufgerufen.  Das Token, das die `authenticate` Methode erhält, kommt von dem Client und kann einen beliebigen Wert haben.": "The `session` object is by default an anonymous session, which means that the client has not authenticated itself. As soon as it wants to authenticate, the `authenticate` method is called.  The token that the `authenticate` method receives comes from the client and can have any value.",
        "Sobald der Client einen Token setzt, wird die Authentifizierung ausgeführt, sobald die erste RPC Funktion oder manuell `client.connect()` aufgerufen wird.": "Once the client sets a token, authentication is performed as soon as the first RPC function or manually `client.connect()` is called.",
        "Hier erhält `RpcKernelSecurity.authenticate` das Token `123456789` und kann entsprechend eine andere Session zurückgeben. Diese zurückgegebene Session wird dann an alle anderen Methoden wie der `hasControllerAccess` übergeben.": "Here `RpcKernelSecurity.authenticate` receives the token `123456789` and can return another session accordingly. This returned session is then passed to all other methods like the `hasControllerAccess`.",
        "Controller Access": "Controller Access",
        "Mit der Methode `hasControllerAccess` kann bestimmt werden, ob ein Client eine bestimmte RPC Funktion ausführen darf. Diese Methode wird bei jedem RPC Funktionsaufruf ausgeführt. Gibt diese `false` zurück, ist der Zugriff verweigert und es wird ein Fehler auf dem Client geworfen.": "The `hasControllerAccess` method can be used to determine whether a client is allowed to execute a specific RPC function. This method is executed on every RPC function call. If it returns `false`, access is denied and an error is thrown on the client.",
        "In `RpcControllerAccess` sind mehrere wertvolle Informationen über die RPC Funktion enthalten:": "In `RpcControllerAccess` there are several valuable information about the RPC function:",
        "Gruppen und zusätzliche Daten sind über den Decorator `@rpc.action()` änderbar:": "Groups and additional data can be changed via the decorator `@rpc.action()`:",
        "Transform Error": "Transform Error",
        "Da geworfene Fehler automatisch mit all seinen Informationen wie die Fehlermeldung und auch den Stacktrace dem Client weitergeleitet werden, könnte dies unerwünscht sensitive Informationen veröffentlichen. Um dies zu ändern, kann in der Methode `transformError` der geworfene Fehler abgeändert werden.": "Since thrown errors are automatically forwarded to the client with all its information like the error message and also the stacktrace, this could unwantedly publish sensitive information. To change this, in the method `transformError` the thrown error can be modified.",
        "Beachte, dass sobald der Error in einen generischen `Error` umgewandelt wird, der komplette Stacktrace und die Identität des Errors verloren gehen. Entsprechend kann in dem Client keine `instanceof` checks mehr auf den Error genutzt werden.": "Note that once the error is converted to a generic `error`, the complete stack trace and the identity of the error are lost. Accordingly, no `instanceof` checks can be used on the error in the client.",
        "Wird Deepkit RPC zwischen zwei Microservices verwendet, und ist somit der Client und Server unter vollständiger Kontrolle des Entwicklers, so ist ein Transformieren des Errors nur selten nötig. Läuft der Client hingegen in einem Browser bei einem Unbekannten, so sollte in `transformError` genaustens darauf geachtet werden, welche Informationen man preisgeben möchte. Im Zweifel sollte jeder Error mit einem generischen `Error` umgewandelt werden, um so sicherzustellen, dass keine internen Details nach außen gelangen. Das Loggen des Errors würde sich an dieser Stelle dann anbieten.": "If Deepkit RPC is used between two microservices, and thus the client and server are under complete control of the developer, then transforming the error is rarely necessary. If, on the other hand, the client is running in a browser with an unknown, then care should be taken in `transformError` as to what information is to be revealed. If in doubt, each error should be transformed with a generic `Error` to ensure that no internal details are leaked. Logging the error would then be a good idea at this point.",
        "Sofern die Deepkit RPC Library direkt benutzt wird, wird die `RpcKernelSecurity` Klasse selbst instantiiert. Benötigt diese Klasse eine Datenbank oder einen Logger, so muss dieser selbst übergeben werden.": "If the Deepkit RPC library is used directly, the `RpcKernelSecurity` class itself is instantiated. If this class needs a database or a logger, this must be passed itself.",
        "Wenn das Deepkit Framework genutzt wird, wird die Klasse von dem Dependency Injection Container instantiiert und hat so automatisch Zugriff auf alle anderen Provider der Anwendung.": "When the Deepkit framework is used, the class is instantiated by the Dependency Injection container and thus automatically has access to all other providers in the application.",
        "Siehe hierzu auch <<dependency-injection>>.": "See also <<dependency-injection>>.",
        "Streaming RxJS": "Streaming RxJS",
        "Transport Protocol": "Transport Protocol",
        "Deepkit RPC unterstützt mehrere Transportprotokolle. WebSockets ist dabei das Protokoll, das die beste Kompatibilität hat (da Browser es unterstützen) und gleichzeitig alle Features wie Streaming unterstützt. TCP ist in der Regel schneller und eignet sich hervorragend für die Kommunikation zwischen Servern (Microservices) oder Nicht-Browser Clients.": "Deepkit RPC supports several transport protocols. WebSockets is the protocol that has the best compatibility (since browsers support it) while supporting all features like streaming. TCP is usually faster and is great for communication between servers (microservices) or non-browser clients.",
        "Deepkit's RPC HTTP Protokoll ist dabei eine Variante, die besonders einfach im Browser zu debuggen ist, da jeder Funktionsaufruf ein HTTP-Request ist, hat jedoch seine Limitierungen wie kein Support für RxJS Streaming.": "Deepkit's RPC HTTP protocol is a variant that is particularly easy to debug in the browser, as each function call is an HTTP request, but has its limitations such as no support for RxJS streaming.",
        "TODO: Not implemented yet.": "TODO: Not implemented yet.",
        "WebSockets": "WebSockets",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.",
        "TCP": "TCP",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Connection": "Connection",
        "Read Replica": "Read Replica",
        "Primitives": "Primitive",
        "Primary Key": "Primary Key",
        "Auto Increment": "Auto Increment",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Optional / Nullable",
        "Embedded Types": "Embedded Types",
        "Default Values": "Default Values",
        "Default Expressions": "Default Expressions",
        "Complex Types": "Complex Types",
        "Exclude": "Exclude",
        "Database Specific Column Types": "Database Specific Column Types",
        "Session / Unit Of Work": "Session / Unit Of Work",
        "Identity Map": "Identity Map",
        "Change Detection": "Change Detection",
        "Request/Response": "Request/Response",
        "Query": "Query",
        "Find": "Find",
        "Filter": "Filter",
        "Equal": "Equal",
        "Greater / Smaller": "Greater / Smaller",
        "RegExp": "RegExp",
        "Grouping AND/OR": "Grouping AND/OR",
        "In": "In",
        "Order": "Order",
        "Pagination": "Pagination",
        "Aggregation": "Aggregation",
        "Join": "Join",
        "Returning": "Returning",
        "Patch": "Patch",
        "Delete": "Delete",
        "Lift": "Lift",
        "Repository": "Repository",
        "Relations": "Relations",
        "One To Many": "One To Many",
        "Many To Many": "Many To Many",
        "One To One": "One To One",
        "Constraints": "Constraints",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Inheritance": "Inheritance",
        "Table Per Class": "Table Per Class",
        "Single Table Inheritance": "Single Table Inheritance",
        "Index": "Index",
        "Case Sensitivity": "Case Sensitivity",
        "Character Sets": "Character Sets",
        "Collations": "Collations",
        "Batching": "Batching",
        "Caching": "Caching",
        "Multitenancy": "Multitenancy",
        "Query Events": "Query Events",
        "Unit Of Work Events": "Unit Of Work Events",
        "Transactions": "Transactions",
        "Isolations": "Isolations",
        "Locking": "Locking",
        "Optimistic Locking": "Optimistic Locking",
        "Pessimistic Locking": "Pessimistic Locking",
        "Custom Types": "Custom Types",
        "Logging": "Logging",
        "Migration": "Migration",
        "Seeding": "Seeding",
        "Raw Database Access": "Raw Database Access",
        "SQL": "SQL",
        "App Configuration": "App Configuration",
        "Composite Primary Key": "Composite Primary Key",
        "Plugins": "Plugins",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Server": "Server",
        "Client": "Client",
        "Key/Value": "Key/Value",
        "Publish / Subscribe": "Publish / Subscribe",
        "Template": "Template",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "A server-side TSX (JSX) based template engine that can be used to generate HTML in a type-safe manner.",
        "Components": "Components",
        "Function Components": "Function Components",
        "Class Components": "Class Components",
        "Dynamic HTML": "Dynamic HTML",
        "Optimization": "Optimization",
        "Framework": "Framework",
        "Modules": "Modules",
        "Configuration": "Configuration",
        "Application Server": "Application Server",
        "Public Directory": "Public Directory",
        "File Structure": "File Structure",
        "Logger": "Logger",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Workflow",
        "Testing": "Testing",
        "Debugger": "Debugger",
        "Module": "Modules",
        "Profiler": "Profiler",
        "Deployment": "Deployment",
        "Compiling": "Compiling",
        "Packaging": "Packaging",
        "Docker": "Docker",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript is JavaScript that scales. A language designed to implement complex use cases. It allows JavaScript to be written with types that are checked and removed at compile time. This resulting type safety allows for easier writing and maintenance of complex applications. This, among other things, is what has made TypeScript so popular: It allows finding bugs in code, especially on a large scale, much faster and easier than would be possible with pure JavaScript - and it works with JavaScript, not against it.",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "Deepkit is TypeScript that scales. A framework written in TypeScript for TypeScript, designed to develop very complex software in TypeScript. It brings many design patterns known from the Enterprise to TypeScript and introduces completely new features that are only possible with TypeScript's new type system to increase development speed especially in teams. Small applications can also benefit from this new approach, as Deepkit comes with many libraries for very common use cases that can be used individually or in combination. The framework itself is designed to be as agile as possible and as complex as necessary, not only to get initial results quickly, but also to maintain development speed in the long term.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript is now the largest developer community in the world and provides the developer with a correspondingly large selection of many libraries and tools to cover the needs of a project. However, it is not always easy to find the right library. Often the philosophies, API and code qualities of these differ so much that a lot of sticky code and additional abstractions have to be introduced by the developer in order for these libraries to work properly with each other at all. The provision of core functions, which are needed by virtually every project, in nicely abstracted libraries brought together in a framework by a manufacturer or a community has proven itself again and again in the last decades: Java Spring, PHP Symfony/Laravel, and C++ QT are just a few very well-known and successful examples.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "These frameworks offer to the developer often far common and decades proven concepts, which are converted into libraries or components, in order to be able to be used so comfortably among themselves harmonizing demand-fairly. The offered functionalities and Design patterns are thereby not cubed, but based on sometimes over decades old concepts, which worked satisfactorily by the fight in the competition with alternative ideas.",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript has seen massive progress over the years, so that more and more design patterns from the enterprise environment can now be applied. Design patterns that can be found in more and more libraries, frameworks, and tools. However, JavaScript and also TypeScript have the problem that in order to efficiently apply many proven enterprise patterns, decisive functions are missing in the language itself. This does not mean that these design patterns cannot be applied in general, but that they are less efficient than in other current languages.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript completely removes its type information at compile time, once TypeScript is converted to JavaScript, so no information about it exists in the generated JavaScript or at runtime. It is undeniable that types are very valuable during development and when checking the correctness of the program. However, types also have tremendous value at runtime. This value is reflected where at runtime data is transformed (converted/serialized), data is validated, meta-information is added to objects, or interface information is required. In these and many other use cases, type information can be very useful at runtime because it provides libraries with the information needed to efficiently provide functionality. Currently, many of these use cases instead use alternatives that incompletely mimic TypeScript's type system, forcing the developer to write types in a new way that has nothing to do with TypeScript's syntax. The result is that TypeScript's powerful type system can no longer show its strength here, and less ergonomic and less efficient ways of working must be used instead.",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit has developed a type compiler that leaves type information in place, allowing dynamic types to be computed at runtime and existing type information to be read at runtime. With this paradigm shift, completely new ways of working are possible, providing the required information for the aforementioned use cases, radically simplifying the development of complex software, and giving the code more expressiveness. It is thus possible for the first time to use the full power and expressiveness of TypeScript at runtime as well.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "Based on this paradigm shift, Deepkit has developed a whole set of libraries for use cases that can be found in just about any program: Validation, Serialization, Database Abstraction, CLI parser, HTTP Router, RPC Framework, Logger, Template System, Event System and many more. The fundamental difference from other libraries is that type information is at the core of the functionality and as much TypeScript as possible should be reused at runtime, so less boilerplate needs to be written by the developer and even complex programs can be seen at a glance what they are doing. Finally, one of the key features of TypeScript is to give expression to even complex code, and Deepkit brings these expressiveness benefits to the runtime in the form of a powerful framework to now better scale application architecture with appropriate enterprise patterns.",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit consists of two large areas: One is the Deepkit Libraries and the Deepkit Framework. The Deepkit Libraries are a whole family of standalone TypeScript libraries (NPM packages) that are good at one topic and are optimized, well tested, and designed to complement each other optimally. A project can use individual Deepkit libraries, or the entire Deepkit framework, which brings together all the capabilities of the libraries and complements them with additional tools such as the debugger. All together, it allows the developer to create complex, fast, and production-ready applications.",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit supports a wide range of use cases. From simple command-line tools (CLI programs) to web applications and micro-services to desktop or mobile applications. The code is designed to run in any known JavaScript engine (browser as well as NodeJS) and integrates beautifully with other frameworks such as Angular, React, and Vue.",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "The claim behind Deepkit Framework is to apply clean code, SOLID principles, and enterprise design patterns to not only offer correspondingly high code quality, but to allow the user to apply them as well. Deepkit also tries to promote these same principles in its documentation and examples, but does not force the developer to follow them themselves.",
        "High-Performance": "High-Performance",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "One of the most difficult problems in software development is to maintain a high development speed even after months or years, especially when the code and the team grow. There are many frameworks that promise to get you started quickly and allow you to cobble together more complex applications on your own in a very short time. However, these usually have the common problem that the development speed decreases drastically the older the project or the larger the team becomes. It is not uncommon that even after a few months and only a handful of developers, the development speed collapses to such an extent that it drops to 1% of the original speed.",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "To counteract this phenomenon, it is necessary to apply established design patterns and use the right framework and libraries in advance. Enterprise design patterns have established themselves for the reason that they scale excellently even with larger applications and large teams. Correctly applied, they develop their capabilities especially when a project is to be developed over a longer period of time (several months to years).",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "Design patterns have their advantages in theory, but in practice almost every pattern also has its disadvantages. These disadvantages vary depending on the language and framework, since the language and framework themselves determine how ergonomically a pattern can be applied. Just because a certain pattern can be used in a language, it does not mean that it automatically makes development better and faster.",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "Some languages are better suited than others for applying certain patterns. With JavaScript or even TypeScript itself, various design patterns are often usable in the core, but there are limitations here that massively affect the user experience and thus speed. For example, Typescript decorators with all their idiosyncrasies may become necessary if a dependency injection framework specifies and is based on them.",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit's runtime type system ensures that these design patterns can be applied in the most ergonomic way and with as little boilerplate as possible, unlocking their power to maintain high development speed not only initially, but also over the long term.",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "One of the biggest advantages of TypeScript is that complex code can be written better in many use cases. This includes frontend, backend, CLI tools, mobile and desktop apps, and much more. When a project spans these use cases and relies almost exclusively on TypeScript, it is called Isomorphic TypeScript. Using TypeScript in as much code as possible can massively increase development speed. So the following advantages are then suddenly available:",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "Code can be shared between departments (frontend, backend, microservice, etc).",
        "Models, Typen und Interfaces": "Models, types and interfaces",
        "Business logic": "Business logic",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "A unified audit system of a single package manager.",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "Reuse of known third-party libraries in all departments.",
        "Wissensteilung innerhalb der Teams.": "Knowledge sharing within teams.",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "Recruitment is simplified to one group (and the biggest one: JavaScript developers).",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit framework and its runtime type system are designed to exploit these and more advantages of Isomorphic TypeScript to the utmost, so that its maximum powers are revealed.",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "Old approaches such as the dual stack (frontend and backend in different languages) can no longer keep up by far, since the context switch between the languages alone already costs an enormous amount of energy and time. All the other advantages that have already been explained even make it an unfair comparison. An isomorphic tech stack like TypeScript, properly applied, is many times faster in development time on a fundamental level than any combination of a dual stack for backend/frontend like Java/JavaScript, PHP/JavaScript, or even JavaScript/JavaScript. Since faster development speed also means less time needed for the same features, it also means that Isomorphic TypeScript saves cash. Besides all the advantages already presented, this is the killer argument to use Isomorphic TypeScript in all the next especially commercial projects.",
        "Welcome to the Deepkit documentation. In this documentation you will find more information about how to use each library and the Deepkit Framework in great detail with example code.": "Welcome to the Deepkit documentation. In this documentation you will find more information about how to use each library and the Deepkit Framework in great detail with example code.",
        "API": "API",
        "Use the API documentation to get very detailed information about the API of each module.": "Use the API documentation to get very detailed information about the API of each module.",
        "link:https://deepkit.io/assets/api-docs/modules.html[API Documentation, role=big]": "link:https://deepkit.io/assets/api-docs/modules.html[API Documentation, role=big]",
        "Support": "Support",
        "If you need help, please join the Discord community server:": "If you need help, please join the Discord community server:",
        "link:https://deepkit.io/community[Community, role=big]": "link:https://deepkit.io/community[Community, role=big]",
        "Deepkit bietet ein ORM, das es ermöglicht, auf Datenbanken auf moderne Art und Weise zuzugreifen.": "Deepkit provides an ORM that allows to access databases in a modern way.",
        "Entities werden dabei einfach über TypeScript Typen definiert und dann direkt die Datenbank angesprochen.": "Entities are simply defined using TypeScript types and then the database is addressed directly.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/orm` selbst und ein Datenbank-Adapter installiert werden.": "If this is done successfully, `@deepkit/orm` itself and a database adapter can be installed.",
        "Sobald die Library installiert ist, kann ein Datenbank-Adapter installiert werden die API davon direkt benutzt werden.": "Once the library is installed, a database adapter can be installed and the API of it can be used directly.",
        "Falls Klassen als Entities verwendet werden sollen, muss <code>experimentalDecorators</code> in der tsconfig.json aktiviert werden:": "If classes are to be used as entities, <code>experimentalDecorators</code> must be enabled in tsconfig.json:",
        "Sobald die Library installiert ist, kann ein Datenbank-Adapter installiert und die API davon direkt benutzt werden.": "Once the library is installed, a database adapter can be installed and the API of it can be used directly.",
        "Entities werden dabei einfach über TypeScript Typen definiert:": "Entities are simply defined using TypeScript types:",
        "Dabei können beliebige TypeScript Typen und Validierung-Dekoratoren von Deepkit benutzt werden, um sein Entity vollumfänglich zu definieren.": "In doing so, any of Deepkit's TypeScript types and validation decorators can be used to fully define its entity.",
        "Das Entity-Typensystem ist dabei so ausgelegt, dass diese Typen beziehungsweise Klassen ebenfalls in anderen Bereichen wie HTTP-Routen, RPC-Aktionen, oder Frontend benutzt werden können. Das verhindert, dass man zum Beispiel einen User mehrmals in der gesamten Applikation verteilt definiert hat.": "The entity type system is designed so that these types or classes can also be used in other areas such as HTTP routes, RPC actions or frontend. This prevents, for example, that a user is defined several times in the entire application.",
        "Da Deepkit ORM auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Since Deepkit ORM is based on Runtime Types, it is necessary to have `@deepkit/type` already installed correctly.",
        "Dabei können beliebige TypeScript Typen und Validierung-Dekoratoren von Deepkit benutzt werden, um die Entity vollumfänglich zu definieren.": "In doing so, any TypeScript types and validation decorators from Deepkit can be used to fully define the entity."
    },
    "german": {},
    "chinese": {
        "Einführung": "介绍",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。它可以在开发过程中（但最迟在编译过程中）比纯JavaScript更快、更容易地发现错误，并与JavaScript一起工作，而不是反对它。一个用TypeScript编写的框架，旨在用TypeScript开发非常复杂的软件。它将许多从企业中已知的设计模式带到了TypeScript，并引入了只有TypeScript的新类型系统才能实现的全新功能，以提高开发速度，尤其是在团队中。小型应用程序也可以从这种新方法中受益，因为Deepkit为非常常见的使用情况配备了许多库，可以单独或组合使用。该框架本身被设计成尽可能的敏捷，并在必要的情况下尽可能的复杂，这不仅是为了快速获得初步的结果，也是为了长期保持开发速度。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries nicht nur untereinander einwandfrei funktionieren, sondern auch, dass die vorhandene Komplexität des Projektes effizient in Code gegossen werden kann. Auch ist es sehr schwer Ansprechpartner, gerade im Enterprise-Bereich, zu finden, wenn das Projekt auf tausende third-party Libraries basiert. Teilweise sind Libraries recht schnell nicht mehr richtig gepflegt und man hat entsprechend das Nachsehen, wenn der Fall mal eintritt, dass ein Bug gefunden oder ein Feature entwickelt werden soll.": "JavaScript现在是世界上最大的开发者社区，为开发者提供了相应的许多库和工具的选择，以满足项目的需求。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念和代码质量差别很大，以至于开发人员必须引入大量的胶水代码和额外的抽象，以便这些库不仅能相互正常工作，而且还能将项目的现有复杂性有效地投射到代码中。如果项目是基于数以千计的第三方图书馆，也很难找到联系人，特别是在企业部门。在某些情况下，库不再得到适当的维护，如果发现一个错误或需要开发一个功能，你将一无所获。",
        "Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "近几十年来，制造商或社区将几乎每个项目都需要的核心功能提供给精美的抽象库，并将其汇集到一个框架中，这一点已被反复证明。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten gegossen sind, um so bequem, untereinander harmonierend, und bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念被投在库或组件中，以便它们可以方便地使用，相互协调，并根据需要使用。所提供的功能不是切块的，而是基于有时是几十年前的概念，并且在与其他想法的竞争中证明了自己。",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript在这些年里取得了巨大的进步，因此与此同时，越来越多来自企业环境的设计模式可以被应用。在越来越多的库、框架和工具中可以找到的设计模式。然而，JavaScript和TypeScript有一个问题，即为了有效地应用许多已被证实的企业模式，语言本身缺少决定性的功能。这并不意味着这些设计模式不能被普遍应用，而是说它们的效率不如当前的其他语言。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (de-/serializer), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, die sie brauchen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译时完全删除了它的类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中和运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据被转换（de/serialised）、数据被验证、元信息被添加到对象中，或者在运行时需要接口信息的地方，这个值会被反映出来。在这些和其他许多用例中，运行时的类型信息可能非常有用，因为它为库提供了它们所需要的信息。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里无法再显示出它的优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Deepkit开发了一种类型编译器，将类型信息留在原地，允许在运行时计算动态类型，并在运行时读取现有类型信息。随着这种模式的转变，全新的工作方式成为可能，为上述用例提供了所需的信息，从根本上简化了复杂软件的开发，并赋予代码更多的表现力。第一次有可能在运行时使用TypeScript的全部功能和表现力。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikations-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种模式的转变，Deepkit开发了一整套用于几乎所有程序中都能找到的用例库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发人员需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit由两个主要领域组成。首先是Deepkit库和Deepkit框架。Deepkit库是一整个独立的TypeScript库（NPM包）家族，它们擅长一个主题，并经过优化、测试，旨在以最佳方式相互补充。一个项目可以使用单独的Deepkit库，也可以使用整个Deepkit框架，后者汇集了这些库的所有功能，并以调试器等附加工具对其进行补充。总之，它使开发人员能够建立复杂、快速和可生产的应用程序。",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit支持一系列的使用案例。从简单的命令行工具（CLI程序）到网络应用和微服务再到桌面或移动应用。这些代码被设计成可以在任何已知的JavaScript引擎（浏览器以及NodeJS）中运行，并与Angular、React和Vue等其他框架完美整合。",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "Deepkit Framework背后的主张是应用干净的代码、SOLID原则和企业设计模式，不仅提供高质量的代码，而且让用户也能应用它们。另外，Deepkit试图在其文档和示例中推广这些相同的原则，但并不强迫开发者自己遵循这些原则。",
        "High-Performance": "高性能",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "软件开发中最困难的问题之一是在数月或数年后仍能保持较高的开发速度，特别是随着代码和团队的成长。有许多框架承诺快速启动，用它们可以在很短的时间内组装出更复杂的应用程序。然而，他们通常有一个共同的问题，即项目越老或团队越大，开发速度就会急剧下降。即使在几个月后，只有少数几个开发人员，开发速度也会崩溃，以至于下降到原来速度的1%，这种情况并不罕见。",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "为了抵制这种现象，有必要应用既定的设计模式，并提前使用正确的框架和库。企业设计模式已经确立了自己的地位，因为它们即使在较大的应用程序和大型团队中也能出色地扩展。正确地应用，它们会发展出自己的能力，特别是当一个项目要在较长的时间内（几个月到几年）开发时。",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "设计模式在理论上有其优点，但在实践中，几乎每一种模式也有其缺点。这些缺点根据语言和框架的不同而表现得不同，因为语言和框架本身决定了一个模式的应用是否符合人体工程学。仅仅因为某种模式可以应用于某种语言，并不意味着它可以自动地使开发变得更好、更快。",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel kann wie bereits oben ausgeführt Typescript-Dekoratoren mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "有些语言比其他语言更适合应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在其核心中使用，但有一些限制，大量损害用户体验，从而影响速度。例如，如上所述，如果一个依赖注入框架指定了这个框架并以其为基础，那么Typescript装饰器及其所有的特异性就可能成为必要。",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "Deepkit的运行时类型系统确保以最符合人体工程学的方式和尽可能少的模板来应用这些设计模式，释放它们的力量，以便不仅在最初，而且在长期保持高开发速度。",
        "Isomorphic TypeScript": "Isomorphic TypeScript",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "TypeScript的最大优势之一是在许多用例中可以更好地编写复杂代码。这包括前端、后端、CLI工具、移动和桌面应用程序，以及更多。当一个项目跨越了这些用例并几乎完全依赖TypeScript时，它被称为Isomorphic TypeScript。在尽可能多的代码中使用TypeScript可以极大地提高开发速度。",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit框架及其运行时类型系统旨在最大限度地利用Isomorphic TypeScript的这些以及更多的优势，从而使其最大的力量凸显出来。",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "双栈（不同语言的前端和后端）等老方法已经远远跟不上了，因为仅语言之间的上下文切换就已经花费了巨大的精力和时间。所有其他已经解释过的优点甚至使它成为一个不公平的比较。像TypeScript这样的同构技术栈，如果应用得当，在基本层面上比任何后端/前端的双栈组合（如Java/JavaScript、PHP/JavaScript，甚至JavaScript/JavaScript）的开发时间快很多倍。由于更高的开发速度也意味着同样的功能需要更少的时间，这也意味着Isomorphic TypeScript可以节省资金。除了已经介绍的所有好处，这也是在所有下一步尤其是商业项目中使用Isomorphic TypeScript的杀手锏。",
        "pageBreak:": "pageBreak:",
        "Runtime Types": "运行时类型",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Dekoratoren zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "在TypeScript中提供运行时的类型信息变化很大。它允许采用新的工作方式，而这在以前只能以迂回的方式或根本不可能实现。声明类型和模式已经成为现代开发过程中的一个重要部分。GraphQL、验证器、ORM、ProtoBuf等编码器以及其他许多东西都依赖于在运行时有模式信息可用，以提供基本功能。这些工具和库有时需要开发人员学习全新的语言，这些语言是专门为使用情况开发的。例如，ProtoBuf和GraphQL有自己的声明语言，验证器通常基于自己的模式API，甚至是JSON模式，这也是一种独立的定义结构的方式。其中一些需要在每次更改时运行代码生成器，以便将模式信息也提供给运行时。另一个著名的模式是使用实验性的TypeScript装饰器，在运行时向类提供元信息。",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "但这一切有必要吗？TypeScript提供了一个非常强大的语言来描述甚至非常复杂的结构。事实上，TypeScript现在是游刃有余的，这大致意味着理论上任何种类的程序都可以映射到TypeScript中。当然，这有其实际的局限性，但重要的一点是，TypeScript能够完全取代任何声明格式，如GraphQL、ProtoBuf、JSON Schema和许多其他格式。在运行时与类型系统相结合，有可能涵盖所有描述的工具和它们在TypeScript本身的使用情况，而不需要任何代码生成器。但是，为什么仍然没有确切的解决方案呢？",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "从历史上看，TypeScript在最近几年经历了巨大的变化。它已经被完全重写了好几次，获得了基本的功能，并经历了一系列的迭代和突破性变化。然而，与此同时，TypeScript已经达到了产品市场的契合度，大大减缓了基本创新和突破性变化发生的速度。TypeScript已经证明了自己，并展示了像JavaScript这样的高度动态语言的高度迷人的类型系统应该是什么样子。市场感激地接受了这一推动，并迎来了用JavaScript开发的新时代。",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "此时正是在语言本身的基础上建立工具的好时机，使上述情况成为可能。Deepkit希望成为推动力，将几十年来来自Java和PHP等语言企业的成熟设计模式不仅从根本上引入TypeScript，而且以一种新的、更好的方式与JavaScript一起工作，而不是反对它。通过运行时的类型信息，这些现在第一次不仅在原则上是可能的，而且允许全新的更简单的设计模式，这在Java和PHP等语言中是不可能的。",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "在运行时读取类型信息是Deepkit建立其基础的能力，TypeScript本身已经在这里奠定了基础，通过全新的方法与经过测试的方法有力地结合，大大简化了开发人员的生活。Deepkit库的API主要集中在使用尽可能多的TypeScript类型信息，以达到尽可能的高效。运行时的类型系统意味着类型信息在运行时是可读的，动态类型是可计算的。这意味着，例如，对于类的所有属性和对于函数的所有参数和返回类型都可以被读出。",
        "Nehmen wir als Beispiel diese Funktion:": "以这个函数为例：",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "在JavaScript本身，有几个信息可以在运行时被读出。例如，函数的名称（如果没有用最小化器修改）：",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "另一方面，可以读出参数的数量：",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "只要多写一点代码，也可以读出参数的名称。然而，如果没有一个简陋的JavaScript解析器或对log.toString()的正则表达法，这是不可能做到的，所以就这样了。由于TypeScript将上述函数翻译成JavaScript，如下：",
        "sind die Informationen, dass message vom Typ string und der Return-Typ vom Type void ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "消息是字符串类型，返回类型是void类型的信息已不再可用。",
        "Installation": "Installation",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "安装Deepkit的运行时类型系统需要两个包。`@deepkit/type-compiler`中的类型编译器和`@deepkit/type`中的必要运行时间。类型编译器可以安装在`package.json`_devDependencies_中，因为它只在构建时需要。",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Dekoratoren verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "运行时类型信息默认不生成。必须在`tsconfig.json`文件中设置`\"反射\": true`，以便在该文件同一文件夹的所有文件或所有子文件夹中启用。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。这对于使用`@deepkit/type`来说并不是严格必要的，但对于其他deepkit库和`@deepkit/framework`中的某些功能来说是必要的。",
        "_Datei: tsconfig.json_": "_文件：tsconfig.json_",
        "Type compiler": "Type compiler",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in` node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript本身并不允许你通过`tsconfig.json`来配置类型编译器。有必要直接使用TypeScript编译器API或像Webpack这样带有_ts-loader_的构建系统。为了避免Deepkit用户走这条不方便的路，一旦`@deepkit/type-compiler`被安装，Deepkit类型编译器就会自动安装在`node_modules/typescript`中（这是通过NPM安装钩子完成的）。",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "这使得所有访问本地安装的TypeScript（`node_modules/typescript`中的）的构建工具都能自动启用类型编译器。这使得_tsc_、Angular、webpack、_ts-node_和其他一些工具能够自动与deepkit类型编译器一起工作。",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgenden Kommando nachgeholt werden:": "如果类型编译器不能成功地自动安装（例如，由于NPM安装钩子被禁用），这可以通过以下命令手动完成：",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "注意，如果本地的typecript版本已经更新（例如，如果软件包中的typecript版本。",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "如果要在webpack构建中使用类型编译器，可以使用`ts-loader`包（或任何其他支持transformer注册的类型脚本加载器）来完成。）",
        "_Datei: webpack.config.js_": "_文件：webpack.config.js_",
        "Typen-Dekoratoren": "Type-decorators",
        "Typen-Dekoratoren sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um meist zur Laufzeit das Verhalten festzulegen. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden.  Die Datenbank Library kann diese Information nutzen, um die korrekten SQL Queries zu erstellen.": "Type-decorators是普通的TypeScript类型，包含元信息，主要用于在运行时指定行为。例如，一个类属性可以被标记为主键、引用或索引。  数据库库可以使用这些信息来创建正确的SQL查询。",
        "Es können auch Validator-Einschränkungen wie zum Beispiel MaxLength, Maximum, oder Positive an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist.": "Validator约束，如MaxLength、Maximum或Positive，也可以被添加到任何类型。我们也可以告诉序列化器如何序列化或反序列化一个特定的值。",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Dekoratoren, die alle direkt aus @deepkit/type benutzt werden können. Sie sind designt, nicht aus einer bestimmten Library zu kommen, um so Typen nicht an eine Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppelt. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Dekoratoren genutzt werden.": "Deepkit附带了一系列的类型装饰器，所有这些都可以直接从@deepkit/type中使用。它们被设计成不来自于某个特定的库，所以类型不必与Deepkit RPC或Deepkit Database这样的库耦合。这使得类型的重用更加容易，甚至在前端也是如此，尽管数据库类型装饰器被使用，例如。",
        "Enhanced Types": "Enhanced Types",
        "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .": "integer, float, UUID, MongoId, BinaryBigint, SignedBigInt, .",
        "Meta": "Meta",
        "MapName, Group, Data, Entity, InlineRuntimeType.": "MapName, Group, Data, Entity, InlineRuntimeType。",
        "Serializer": "Serializer",
        "Excluded, Embedded.": "Excluded, Embedded.",
        "Database": "Database",
        "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Reflection": "Reflection",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "为了直接处理类型信息本身，这里有两个基本变种。类型对象和反思类。下面将讨论反思类。函数`typeOf`返回类型对象，它是非常简单的对象字面。它总是包含一个`kind'，这是一个数字，通过枚举`ReflectionKind'获得其含义。`ReflectionKind`在包`@deepkit/type`中定义如下：",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "有许多可能的类型对象可以被返回。其中最简单的是`never`、`any`、`unknown`、`void、null`和`undefined`，其表示方法如下：",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "例如，数字0是`ReflectionKind`枚举的第一个条目，在这里是`never`，数字1是第二个条目，这里是`any`，以此类推。因此，原始类型如`string`、`number`、`boolean`被表示为：",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "这些相当简单的类型在类型对象处没有进一步的信息，因为它们被直接作为类型参数传递给`typeOf`。然而，如果类型是通过类型别名传递的，额外的信息可以在类型对象中找到。",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "在这种情况下，类型别名`title`的名字也会出现。如果一个类型别名是一个泛型，那么传递的类型也将在类型对象处可用。",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "如果传递的类型是一个索引访问操作的结果，那么容器和索引类型将出现：",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "接口和对象字面都作为Reflection.objectLiteral输出，并包含`types`数组中的属性和方法。",
        "Index Signatures sind ebenfalls in dem `types` array.": "索引签名也在 \"types \"数组中。",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "类类似于对象字面，除了 \"classType \"是对类本身的引用外，它们的属性和方法也在 \"types \"数组中。",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "注意，类型已经从Reflection.propertySignature变为Reflection.property，Reflection.methodSignature变为Reflection.method。由于类上的属性和方法有额外的属性，这些信息也可以被检索到。后者还包括`visibility`、`abstract`和`default`。",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "类的类型对象只包括类本身的属性和方法，不包括超类的属性和方法。这与接口/对象文字的类型对象相反，后者将所有父类的所有属性签名和方法签名解析为 \"类型\"。要解决超类的属性和方法，可以使用ReflectionClass及其`ReflectionClass.getProperties()`（见下面的章节）或`@deepkit/type`的`resolveTypeMembers()`。",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "有一大堆类型对象。例如，对于字面意思、模板字面意思、承诺、枚举、联合、数组、元组等等。要想知道哪些类型都存在，有哪些信息，建议从`@deepkit/type`中导入`type`。它是一个具有所有可能的子类型的 \"union\"，如TypeAny、TypeUnknonwn、TypeVoid、TypeString、TypeNumber、TypeObjectLiteral、TypeArray、TypeClass，以及更多。确切的结构可以在那里找到。",
        "Type Cache": "类型缓存",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "一旦没有传递通用参数，类型对象就会被缓存到类型别名、函数和类。具体来说，这意味着对`typeOf<MyClass>()`的调用将总是返回相同的对象。",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "但是只要使用Generic类型，新的对象将总是被创建，即使传递的类型总是相同。这是因为理论上有无限多的组合是可能的，所以缓存实际上是一种内存泄漏。",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "然而，只要一个类型被多次实例化为递归类型，它就会被缓存起来。然而，缓存的持续时间只限于计算类型的时刻，此后就不存在了。另外，虽然Type对象被缓存了，但返回的是一个新的引用，并不是完全相同的对象。",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht das selbe Type-Objekt.": "`MyType<string>`被缓存了，只要`Object`被计算了。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "所有非根Type对象都有一个父属性，它通常指向包围的父。",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "`Ref 1`指向实际的联合类型对象。",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "在缓存类型对象的情况下，如上所述，`parent`属性并不总是真正的父对象。所以，例如，对于一个多次使用的类，虽然`types`中的即时类型（TypePropertySignature和TypeMethodSignature）指向正确的TypeClass，但这些签名类型的`type`指向缓存条目的TypeClass的签名类型。知道这一点很重要，这样就不会无限地读取父结构，而只读取直接的父结构。父类没有无限精度是由于性能的原因。",
        "JIT cache": "JIT缓存",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "在进一步的课程中，描述了一些经常基于Type对象的函数和特性。为了以一种高性能的方式实现其中的一些内容，需要对每个类型对象进行JIT缓存（just in time）。这可以通过`getJitContainer(type)`提供。这个函数返回一个简单的对象，上面可以存储任何数据。只要不保留对该对象的引用，只要Type对象本身也不再被引用，它就会通过GC自动删除自己。",
        "Reflection-Klassen": "反射类",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "除了`typeOf<>()`函数，还有各种反射类，它们提供了Type对象的OOP替代品。反射类只适用于类、界面/对象字面和函数以及它们的直接子类型（属性、方法、参数）。所有更深层次的类型必须再次用Type对象来读取。",
        "Typeninformation empfangen": "接收类型信息",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "为了提供自己对类型进行操作的函数，提供给用户手动传递一个类型可能是有用的。例如，在一个验证函数中，提供要请求的类型作为第一个类型参数和要验证的数据作为第一个函数参数可能是有用的。",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "为了让这个函数接收类型`string`，它必须告诉类型编译器这一点。",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType`与第一个类型参数`T`的引用给类型编译器发出信号，任何对`validate`的调用应该把类型放在第二位（因为`type`被声明在第二位）。为了在运行时读出信息，使用了`resolveReceiveType`函数。",
        "Es ist nützlich, das Ergebnis der selben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typenkompiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "将结果分配给同一个变量是很有用的，这样就不会不必要地创建一个新变量。在`type`中，要么现在就存储一个类型对象，要么就抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有启用类型信息的发射（见上面的安装部分）。",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "为了详细了解Deepkit如何编码和读取JavaScript中的类型信息，本章旨在介绍。",
        "Typen-Compiler": "类型编译器",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "类型编译器（在@deepkit/type-compiler中）负责读取TypeScript文件中定义的类型并将其编译为字节码。这个字节码拥有在运行时执行类型所需的一切。",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "在本书出版时，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，可以将一个TypeScript AST转化为另一个TypeScript AST。Deepkit的类型编译器在这个过程中读取AST，产生相关的字节码，并将其插入AST中。",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "TypeScript本身不允许你通过tsconfig.json来配置这个插件，又称转化器。要么直接使用TypeScript编译器API，要么使用Webpack这样的构建系统与`ts-loader`。为了避免 Deepkit 用户的这种不便，在安装 `@deepkit/type-compiler` 时，Deepkit 类型编译器会自动安装在 `node_modules/typescript` 中。这使得所有访问本地安装的TypeScript（即`node_modules/typescript`中的那个）的构建工具都能自动启用类型编译器。这使得tsc、Angular、webpack、ts-node和其他一些工具能够自动与Deepkit的类型编译器一起工作。",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "如果没有启用NPM安装脚本的自动运行，因此本地安装的类型脚本不会被修改，如果你想，这个过程必须手动运行。另外，类型编译器也可以在webpack等构建工具中手动使用。",
        "Bytecode Encoding": "字节码编码",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "字节码是虚拟机的命令序列，在JavaScript中被编码为引用数组和字符串（实际的字节码）。",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlessatz über 81 Befehle gross.": "现有的命令本身是一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`枚举。在写这篇文章的时候，命令集的大小超过了81条。",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "一连串的命令被编码为一个字符串，以节省内存。因此，一个类型`string[]`被概念化为一个字节码Program`[string, array]`，它有字节`[5, 37]`，并使用以下算法进行编码：",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "据此，5成为`&`字符，37成为`F`字符。",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__&#8486;\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "为了防止命名冲突，每个类型都有一个\"__&#8486; \"作为前缀，这些都成为\"&F\"，并在Javascript中以\"['&F']\"的形式发出。对于每个明确定义的、被导出的或被导出的类型所使用的类型，一个字节码会发射出JavaScript。类和函数也可以直接接收字节码作为属性。",
        "Virtuelle Maschine": "虚拟机",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "运行时虚拟机（在`@deepkit/type`类的处理器中）负责解码和执行编码的字节码。它总是返回一个类型对象，见上面的Reflection部分。",
        "Validation": "验证",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Validation是检查数据正确性的过程。如果类型是正确的，并且满足了其他定义的限制，那么正确性就得到了。Deepkit通常区分类型验证和附加约束的验证。",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "只要数据来自被认为不安全的来源，就会使用验证。不确定意味着不能对数据的类型或内容做出有保障的假设，因此数据在运行时可能具有字面上的任何价值。",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "因此来自用户输入的数据通常不被认为是安全的。来自HTTP请求（查询参数、正文）、CLI参数或读入文件的数据必须被验证。如果一个变量被声明为数字，其中也必须有一个数字，否则程序会崩溃或出现安全漏洞。",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "例如，在一个HTTP路由的控制器中，首要任务是检查每个用户的输入（查询参数，正文）。特别是在TypeScript环境中，不要使用类型转换，因为它们从根本上是不安全的。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个类型转换`作为数字`，在运行时没有提供任何安全。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "在相关章节（<<cli>>, <<http>>, <<rpc>>, <<database>>）中，我们详细解释了什么时候验证会自动进行。确保你知道在什么地方必须定义限制或类型，不要使用`any`，这样这些验证就能很好地自动安全工作。这可以为你节省大量的手工工作，以保持代码的干净和安全。",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "验证器的基本功能是检查一个值的类型。例如，一个值是否是一个字符串。这不是关于字符串包含什么，只是它的类型。在Typescript中有很多类型：字符串、数字、布尔值、大数、对象、类、接口、泛型、映射类型等等。通过Typescript强大的类型系统，可以提供大量不同的类型。",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "在JavaScript本身，原始类型可以用`typeof`操作符进行解析。对于更复杂的类型，如接口、映射类型或通用集合/映射，这就不再那么容易了，因此需要一个验证器库，如`@deepkit/type`。Deepkit是唯一允许直接验证所有TypesScript类型而不走弯路的解决方案。",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "`username`的类型是字符串。如果验证器要检查变量`username`是否是一个字符串，这可以很容易地用JavaScript本身完成。",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "因此，函数`isString`可以被看作是一个类型验证器。然而，在JavaScript本身，当需要检查数字时，就会变得更加困难。有一些特殊的功能，比如当一个无效的字符串被转换为数字时，NaN（\"不是数字\"）。",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "运算符`typeof`返回Number，尽管它的值是NaN（\"不是数字\"），字面意思是说它不想成为一个数字。从这里开始，必须进行特殊的额外检查，如`isNaN()`，而且很快就会发现使用外部库，如Deepkit，它会自动考虑到这些特殊性。",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "在Deepkit中，类型验证可以通过`validate`、`is`或`assert`函数进行。函数`is`是一个所谓的类型保护，`assert`是一个类型断言。",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "函数`validate`返回一个发现错误的数组，如果成功则返回一个空数组。这个数组中的每个条目都描述了确切的错误代码和错误信息以及路径，只要更复杂的类型，如对象或数组得到验证。",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "这三个函数的使用大致相同。类型被指定或引用为第一个类型参数，数据作为第一个函数参数被传递。",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "当处理更复杂的类型如类或接口时，数组也可以包含几个条目。",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "验证器也支持深度递归类型。路径然后用一个点隔开。",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "利用TypeScript为你提供的好处。因此，更复杂的类型，如 \"用户\"，可以在多个地方重复使用，而不必一次又一次地声明。例如，如果一个 \"用户 \"要在没有 \"id \"的情况下被验证，TypeScript的工具可以被用来快速有效地创建派生的子类型。为了保持DRY（Don't Repeat Yourself）。",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit是唯一能够在运行时以这种方式访问TypeScripts类型的主要框架。如果你想在前端和后端使用类型，可以将类型外包给一个单独的文件，从而在任何地方都可以导入。",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "TypeScript中的类型转换（与类型保护相反）在运行时不是一个构造，而只是在类型系统本身中处理。",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "代码 \"as string \"在此并不安全，它是为未知数据分配类型的一种方式。变量`data`实际上可以有任何值，例如`{username: 123}`，甚至`{}`，这将导致`username`不是一个字符串，而是完全不同的东西，因此代码`username.startingWith('@')`将导致一个错误，所以在最坏的情况下，程序会崩溃。为了保证在运行时`data`有一个类型为String的属性`username`，必须使用类型保护。",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "类型保护是给TypeScript一个提示，告诉它在运行时保证传递的数据有什么类型。掌握了这些知识，TypeScript就会随着代码的进展完善（\"缩小\"）该类型。  例如，`any`可以以安全的方式变成字符串或其他类型。",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "因此，如果有数据的类型不知道（`any`或`unknown`），类型保护有助于根据数据本身更精确地缩小范围。然而，类型保护只有在其实施时才是安全的。如果你犯了一个错误，这可能会产生严重的后果，因为基本的假设突然变成了不真实的。",
        "Type-Guard": "类型防护",
        "Ein Type-Guard auf den obige genutzten Typen User könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obig erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht korrekt ist.": "上面使用的类型用户的类型防护，其最简单的形式是这样。请注意，上面用NaN解释的特殊功能不属于这个范围，因此这个类型保护器是不正确的。",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "类型保护器总是返回一个布尔值，通常直接用于If操作。",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "为每个类型保护器编写一个单独的函数，特别是对于更复杂的类型，然后在每次类型改变时调整它是非常繁琐的，容易出错，而且没有效率。因此，Deepkit提供了函数`is`，它为任何TypeScript类型自动提供了一个类型保护器。这就自动考虑到了一些特殊的特点，比如上面提到的NaN的问题。函数`is`的作用与`validate`相同，但它不是返回一个错误数组，而是简单地返回一个布尔值。",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "经常可以发现的一种模式是，如果验证失败，直接返回一个错误，这样就不会执行后续的代码。这可以在不同的地方使用，而不改变代码的完整流程。",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "另外，还可以使用TypeScript类型断言。如果给定的数据不能正确验证为一个类型，函数`assert`会自动抛出一个错误。函数的特殊签名，区别于TypeScript的类型断言，有助于TypeScript自动细化（'缩小'）传递的变量。",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "再次，利用TypeScript为他们提供的好处。类型可以被各种TypeScript函数重用或定制。",
        "Einschränkungen": "约束",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "除了检查类型，其他任意的约束可以被添加到一个类型。这些额外的内容约束的检查是在类型本身被检查后自动完成的。这是在所有验证函数中进行的，如`validate`、`is`和`assert`。一个限制可以是，例如，一个字符串必须有一定的最小或最大长度。",
        "Diese Einschränkungen werden über die Typen-Dekorationen an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Dekoratoren können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "这些限制是通过类型装饰添加到实际的类型中。有一整套可以使用的装饰品。如果需要扩展，可以随意定义和使用自己的装饰器。",
        "Mit `&` können beliebig viele Typen-Dekoratoren an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "用`&`可以在实际的类型上添加任意数量的类型装饰器。结果，这里是`username'，然后可以在所有的验证函数中使用，但也可以在其他类型中使用。",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "函数`validate'给出了有用的错误信息，这些信息来自于限制。",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "例如，这些信息也可以奇妙地自动显示在表单上，并通过`code'翻译。使用对象和数组的现有路径，表单中的字段可以过滤出并显示适当的错误。",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "一个经常有用的用例也是用一个正则约束来定义一个电子邮件。一旦定义了类型，就可以在任何地方使用。",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "可以添加任何数量的约束。",
        "Constraint Types": "约束类型",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "使用自定义验证函数进行验证。",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "定义一个正则表达式作为验证模式，更多信息见下一节自定义验证器。通常用于电子邮件验证或更复杂的内容验证。",
        "Alpha": "Alpha",
        "Validation for alpha characters (a-Z).": "验证字母字符（a-Z）。",
        "Alphanumeric": "Alphanumeric",
        "Validation for alpha and numeric characters.": "验证字母和数字字符。",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "验证ASCII字符。",
        "Decimal&lt;number, number&gt;": "Decimal&lt;number, number&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "验证代表十进制数字的字符串，如0.1，.3，1.1，1.00003，4.0等。",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "验证数字是给定数字的倍数。",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinLength&lt;number&gt;, MaxLength&lt;number&gt;",
        "Validation for min/max length for arrays or strings.": "验证数组或字符串的最小/最大长度。",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "验证一个数组项或子字符串被包括/排除",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimum&lt;number&gt;, Maximum&lt;number&gt;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "验证一个值是最小或最大的给定数字。与`>=`和`&lt;=`相同。",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "与最小/最大值相同，但不包括值本身。",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Positive, Negative, PositiveNoZero, NegativeNoZero",
        "Validation for a value being positive or negative.": "Validation for a value being positive or negative.",
        "BeforeNow, AfterNow": "BeforeNow, AfterNow",
        "Validation for a date value compared to now (new Date)..": "Validation for a date value compared to now (new Date).",
        "Email": "Email",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "通过`/^\\S+@\\S+$/`对电子邮件进行简单的regexp验证。",
        "integer": "integer",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "确保数字是正确范围内的整数，所以不需要做 \"string & Email\"。是自动的 \"数字\"，所以不需要做 \"数字和整数\"。",
        "See Special types: integer/floats for more information": "更多信息见特殊类型：整数/浮点",
        "Benutzerdefinierte Validator": "自定义验证器",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "如果内置的验证器不够用，可以通过`Validate`装饰器创建和使用自定义验证器函数。",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "请注意，你的自定义验证器函数是在所有内置类型验证被调用后执行。如果一个验证器失败了，当前类型的所有后续验证器都被省略。每个类型只可能有一次失败。",
        "Generic Validator": "通用验证器",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "在验证器函数中，类型对象是可用的，可以使用验证器来获得更多关于类型的信息。也有一种方法可以定义任何必须传递给验证类型的验证器选项，使验证器可配置。有了这些信息及其父级引用，就可以创建强大的通用验证器。",
        "Serialisation": "序列化",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "序列化是将数据类型转换为适合传输或存储的格式的过程，例如。反序列化是撤销这一过程。这是无损完成的，这意味着数据可以在不丢失数据类型信息或数据本身的情况下转换为序列化目标。",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet.": "在JavaScript中，序列化通常在JavaScript对象和JSON之间完成。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），反之亦然，如果服务器将数据作为JSON发送到客户端。",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "这个序列化过程对于非琐碎的数据是绝对必要的，因为JSON甚至对于像日期这样的基本类型都会丢失其信息。一个 \"新日期 \"最终被序列化为JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "中的字符串，可以看出，JSON.stringify的结果是一个JSON字符串。如果再次用JSON.parse反序列化，结果不是一个`日期'对象，而是一个字符串。",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "尽管有各种变通方法来教JSON.parse反序列化日期对象，但它们容易出错，而且性能很差。为了使这种情况和许多其他类型的类型安全的序列化和反序列化，需要一个序列化过程。",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "有四个主要功能。`serialize`, `cast`/`deserialize`和`validatedDeserialize`。在这些函数的引擎盖下，默认使用`@deepkit/type`的全局可用的JSON序列化器，但也可以使用自定义的序列化目标。",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type支持自定义的序列化目标，但已经配备了一个强大的JSON序列化目标，可以将数据序列化为JSON对象，然后可以使用JSON.stringify正确、安全地转换为JSON。通过`@deepkit/bson`，BSON也可以作为一个序列化目标。如何创建一个自定义的序列化目标（例如为数据库驱动），可以在<<序列化-自定义序列化器>>一节中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten validieren, um sicherzustellen, dass diese auch umgewandelt werden können, diese Validierung nicht dieselbe ist wie in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "注意，尽管序列化器也会验证数据以确保其可以被转换，但这种验证与<<验证>>一章中的验证是不同的。只有`cast`函数在成功反序列化后还会调用完整的验证过程，如果数据无效就会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "另外，`validatedDeserialize`也可以用来在反序列化后进行验证。另一种方法是手动调用`validate'或`validates'函数来处理来自`deserialize'函数的反序列化数据，详见<<validation>>章节。",
        "Alle Funktionen aus den Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "所有来自序列化和验证的函数在出错时都会从`@deepkit/type`中抛出一个`ValidationError`。",
        "Deserialisierung": "反序列化",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "`deserialize`函数默认使用JSON序列化器将传递的数据转换为适当的指定类型。JSON序列化器希望得到一个JSON对象，即字符串、数字、布尔值、对象或数组。",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "如果已经传递了正确的数据类型（例如，在`created'的情况下是一个Date对象），那么这将被视为是。",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "不仅是一个类，而且任何TypeScript类型都可以被指定为第一个类型参数。因此，即使是基元或非常复杂的类型也可以被传递：",
        "Weiche Typenkonvertierung": "软类型转换",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserialisierer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "软类型转换是在反序列化过程中实现。这意味着String和Number的字符串类型或Number的字符串类型可以被接受并自动转换。这很有用，例如，当数据通过一个URL被接受并传递给反序列化器时。由于URL总是一个字符串，Deepkit Type仍然会尝试解决Number和Boolean的类型。",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serialiser eingebaut:": "JSON序列化器中内置了以下软类型转换：",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "也可以禁用软转换：",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "如果数据是无效的，它将不会尝试转换，而是抛出一个错误消息。",
        "Serialisierung": "序列化",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "函数`serialize`根据默认情况用JSON序列化器将传递的数据转换为JSON对象，即：字符串、数字、布尔值、对象或数组。然后可以使用JSON.stringify将其结果安全地转换为JSON。",
        "Benutzerdefinierter Serializer": "Custom Serializer",
        "Todo": "Todo",
        "Dependency Injection": "依赖注入",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten": "Dependency Injection（DI）是一种设计模式，类和函数接受其依赖性",
        "_empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\")": "_。它遵循控制反转（IoC）",
        "und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität,": "的原则，有助于更好地分离复杂的代码，以显著提高可测试性、模块化",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "为了说明IoC的原则，这里有一个例子：",
        "Die Klasse UserRepository hat dabei als Abhängigkeit einen HttpClient. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "UserRepository类有一个HttpClient作为依赖关系。这个依赖关系本身并不显眼，但UserRepository自己创建了HttpClient，这就有问题了。乍一看，这似乎很明显，但它有其缺点。如果我们想替换掉HttpClient怎么办？如果我们想在单元测试中测试UserRepository，而不允许真正的HTTP请求出去呢？我们怎么知道这个类根本就在使用HttpClient呢？",
        "Inversion of Control": "控制反转",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "在控制反转（IoC）的思想中，有以下的替代变体，它将HttpClient设置为构造函数中的显式依赖（也称为构造函数注入）。",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "现在UserRepository不再负责创建HttpClient，但UserRepository的用户负责。这就是反转控制（IoC）。控制权已被逆转或颠倒。具体来说，这段代码使用了依赖注入，因为依赖被接收（注入），不再创建或请求。依赖注入只是应用IoC的一种方式。",
        "Service Locator": "服务定位器",
        "Neben DI ist auch ein Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "除了DI之外，服务定位器（SL）是应用IoC原则的另一种方式。这通常被认为是与依赖性注入相对应的，因为它请求依赖性而不是接受它们。如果HttpClient在上述代码中被请求如下，就会说到服务定位器模式。",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "函数`locator.getHttpClient`可以有一个完全任意的名字。替代品是函数调用，如`useContext(HttpClient)`、`getHttpClient()`、`await import(\"client\")`，或容器调用，如`container.get(HttpClient)`。全局的导入是服务定位器的一个稍微不同的变体，使用模块系统本身作为定位器：",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "所有这些变体的共同点是它们明确请求依赖HttpClient。这种要求不仅可能发生在作为默认值的属性上，也可能发生在代码中间的某个地方。因为在代码的中间意味着它不是类型接口的一部分，所以HttpClient的使用是隐藏的。根据HttpClient被请求的方式的不同，有时候用另一种实现来替换它是非常困难的，或者是完全不可能的。特别是在单元测试领域，为了清晰起见，这里会出现困难，所以现在服务定位器在某些情况下被归类为反模式。",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "在依赖注入中，没有任何东西被请求，但它是由用户明确提供或由代码接收。从控制反转的例子中可以看出，依赖注入模式已经在那里得到了应用。具体来说，在这里可以看到构造函数注入，因为依赖关系是在构造函数中声明的。所以UserRepository现在必须如下使用。",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes mal neu erstellt oder jedes mal der selbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "想要使用UserRepository的代码也必须提供（注入）所有的依赖。每次是否要重新创建HttpClient，或者每次是否要使用同一个HttpClient，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被要求（从类的角度），或者在最初的例子中，完全由类本身创建。这种倒置的流程有各种优点：",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "但也可以直接认识到一个明显的缺点。我真的要自己创建或管理像HttpClient这样的所有依赖性吗？是的，有很多情况下，自己管理依赖关系是完全合法的。一个好的API的特点是，依赖性不会失控，即使如此，它们仍然是令人愉快的使用。对于许多应用程序或复杂的库，这很可能是一种情况。",
        "Dependency Injection Container": "依赖注入容器",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "另一方面，对于更复杂的应用程序，没有必要自己管理所有的依赖，因为这正是所谓的依赖注入容器的作用。这不仅自动创建了所有的对象，而且还自动 \"注入 \"了依赖关系，这样就不再需要手动调用 \"新建 \"了。有各种类型的注入，如构造函数注入、方法注入或属性注入。",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "依赖注入容器（也称为DI容器或IoC容器）在`@deepkit/injector`中随Deepkit一起提供，或者已经通过Deepkit框架中的应用模块集成。使用`@deepkit/injector`包中的低级API，上面的代码会是这样的。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "本例中的`injector`对象是依赖注入容器。容器没有使用`new UserRepository`，而是使用`get(UserRepository)`返回UserRepository的实例。为了静态地初始化容器，一个提供者的列表被传递给函数`InjectorContext.forProviders`（在这种情况下只是简单的类）。",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "由于DI是关于提供依赖关系的，容器被提供了依赖关系，因此技术术语为 \"提供者\"。有各种类型的提供者：ClassProvider、ValueProvider、ExistingProvider、FactoryProvider。",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "提供者之间的所有依赖关系都被自动解决，一旦发生`injector.get()`调用，对象和依赖关系就会被创建、缓存，并正确地作为构造函数参数传递（构造函数注入）、设置为属性（属性注入）或传递给方法调用（方法注入）。",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "为了与另一个HttpClient交换，可以为HttpClient定义另一个提供者（这里是ValueProvider）：",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "一旦UserRepository通过`injector.get(UserRepository)`被请求，它就会收到另一个HttpClient对象。",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "所有类型的提供者都在<<dependency-injection-providers>>部分列出并解释。",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "在这一点上值得一提的是，Deepkit的DI容器只适用于Deepkit的运行时类型。这意味着任何包含类、类型、接口和函数的代码都必须经过Deepkit类型编译器的编译，以便在运行时获得类型信息。参见<<runtime-types>>一章。",
        "Dependency Inversion": "依赖反转",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "控制反转下的UserRepository的例子显示，UserRepository依赖于一个较低的层次，即一个HTTP库。此外，一个具体的实现（类）而不是抽象的（接口）被声明为依赖关系。乍一看，这似乎符合面向对象的范式，但它可能会导致问题，特别是在复杂和大型的架构中。",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "两个实现（UserRepository与HTTP库）的合并现在可以通过DI容器完成。",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "由于Deepkit的DI容器能够解决抽象的依赖关系（接口），例如在这种情况下，UserRepository自动获得HttpClient的实现，因为HttpClient已经实现了接口HttpClientInterface。这可以通过HttpClient专门实现HttpClientInterface（`class HttpClient implements HttpClientInterface`），或者通过HttpClient的API仅仅与HttpClientInterface兼容来实现。",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "一旦HttpClient改变了它的API（例如，删除了`get'方法），从而不再与HttpClientInterface兼容，DI容器就会抛出一个错误（\"没有提供HttpClientInterface的依赖性\"）。",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "在这里，想要将两种实现结合起来的用户不得不找到一种解决方案。作为一个例子，可以在这里注册一个适配器类，它实现了HttpClientInterface并正确地将方法调用转发给HttpClient。",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip sein Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "这里应该注意的是，尽管在理论上，依赖反转原则有其优点，但在实践中，它也有相当的缺点。例如，这不仅会导致更多的代码（因为必须编写更多的接口），而且还会导致更多的复杂性（因为现在每个实现都有一个接口来处理每个依赖关系）。只有当应用达到一定规模，并且还需要这种灵活性时，这种代价才是值得的。像每一个设计模式和原则一样，这个模式也有它的成本使用因素，在应用之前应该考虑清楚。",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "设计模式不应该盲目地用于每一个代码，无论多么简单。然而，如果有复杂的架构、大型应用程序或扩展团队等先决条件，依赖反转和其他设计模式才会展开其真正的力量。",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "由于Deepkit中的依赖注入是基于运行时类型的，因此有必要将`@deepkit/type`已经正确安装。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果已经成功完成，`@deepkit/injector`可以自行安装，或者安装已经使用该库的Deepkit框架的引擎。",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "一旦库被安装，可以直接使用其中的API。",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "现在要使用依赖注入，有三种可能性。",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "如果`@deepkit/injector`要在没有Deepkit框架的情况下使用，推荐使用前两种变体。",
        "Injector API": "Injector API",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "在依赖注入的介绍中已经介绍了Injector API。它的特点是使用非常简单，通过单一的`InjectorContext`类来创建一个DI容器，特别适合于没有模块的简单应用。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "本例中的`injector`对象是依赖注入容器。在这种情况下，函数`InjectorContext.forProviders`接收一个提供者的数组。",
        "Module API": "模块API",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hiararchie und schön separierte Architektur aufzubauen.": "一个稍微复杂的API是 \"InjectorModule \"类，它允许在不同的模块中交换提供者，以便为每个模块创建多个封装的DI容器。这也允许每个模块使用配置类，这使得自动向提供者提供经过验证的配置值更加容易。模块之间可以相互导入，并导出提供者，以建立一个层次分明、分离良好的架构。",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "如果应用程序比较复杂，并且没有使用Deepkit框架，就应该使用这个API。",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "这种情况下的`injector`对象是依赖注入容器。提供者可以被分割成不同的模块，然后可以用模块导入的方式将它们重新导入到不同的地方。这创建了一个自然的层次结构，映射了应用程序或架构的层次结构。",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "InjectorContext应该总是被赋予层次结构中的顶级模块，也称为根模块或应用模块。然后InjectorContext只有一个中间任务：对`injector.get()`的调用被简单地转发给根模块。然而，非根模块的提供者也可以通过传递模块作为第二个参数来获得。",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "所有非根模块都被默认封装，因此这个模块中的所有提供者只对它自己有效。如果一个提供者要对其他模块可用，这个提供者必须被导出。",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden.": "要想把所有的提供者默认导出到顶层，即根模块，可以使用选项`forRoot`。",
        "App API": "App API",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, so dass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "只要使用Deepkit框架，就可以用`@deepkit/app`的API定义模块。这是基于模块API的，所以那里的能力也是可用的。此外，还可以使用强大的钩子和定义配置加载器来映射更多的动态架构。",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "<framework-modules>一章对此有更详细的描述。",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "在依赖注入容器中，有几种方法来提供依赖。最简单的变体是简单地指定一个类。这也被称为短的ClassProvider。",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "这代表一个特殊的提供者，因为只指定了类。",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes mal neu ausgeführt werden.": "默认情况下，所有的提供者都被标记为单子，因此在任何时候都只有一个实例存在。要在每次提供的时候创建一个新的实例，可以使用`transient`选项。这将导致每次都要重新创建类，或者每次都要执行工厂。",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "除了简短的ClassProvider，还有普通的ClassProvider，它是一个对象字面，而不是一个类。",
        "Dies ist Äquivalent zu diesen beiden:": "这相当于这两个：",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "它可以用来将一个提供者与另一个类交换。",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "在这个例子中，`OtherUserRepository'类现在也在DI容器中被管理，它的所有依赖关系都被自动解决。",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "静态值可以用这个提供者提供。",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "因为不仅是类实例可以作为依赖关系提供，任何值都可以被指定为`useValue'。符号或基元（字符串、数字、布尔）也可以作为提供者标记。",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "基元提供者标记必须作为依赖关系与注入类型一起声明。",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängikeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "通过注入别名和基元提供者标记的结合，也可以从不包含运行时类型信息的包中提供依赖关系。",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "然后在用户端声明如下：",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "可以定义一个已经定义的提供者的重定向。",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfigurations-Optionen zugreifbar.": "可以用一个函数来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "除了类和基元之外，还可以提供抽象（接口）。这是用`provide`函数完成的，当要提供的值不包含任何类型信息时特别有用。",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "如果几个提供者实现了接口连接，则使用最后一个提供者。",
        "Als Argument für provide() sind alle anderen Provider möglich.": "所有其他提供者都可以作为provide()的参数。",
        "Constructor/Property Injection": "构造器/属性注入",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "在大多数情况下，使用构造器注入。所有的依赖被指定为构造函数参数，并由DI容器自动注入。",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "可选的依赖应该被标记为这样，否则如果找不到提供者，可能会引发错误。",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "构造函数注入的一个替代方法是属性注入。这通常是在依赖关系是可选的或者构造函数太满的情况下使用。一旦实例被创建（也就是构造函数被执行），这些属性就会被自动分配。",
        "Konfiguration": "配置",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "依赖注入容器也允许注入配置选项。这种配置注入可以通过构造函数注入或属性注入来接收。",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "模块API支持定义配置定义，它是一个普通的类。通过为这样的类提供属性，每个属性都作为一个配置选项。",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "配置选项`domain`和`debug`现在可以方便地以类型安全的方式在提供者中使用。",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "选项本身的值可以通过`configure()`来设置。",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem \"!\" versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "没有默认值但仍然需要的选项可以用\"！\"来标记。这迫使模块的用户提供该值，否则将导致错误。",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "同时，前几章的所有序列化和验证类型<<validation>>和<<serialisation>>可以用来非常详细地指定一个选项必须有哪些类型和内容限制。",
        "Injection": "注入",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "配置选项可以像其他依赖关系一样通过DI容器安全而容易地注入，如前所示。最简单的方法是使用索引访问操作符来引用单个选项：",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "配置选项不仅可以单独引用，还可以作为一个组来引用。为此，使用了TypeScript实用类型`Partial`：",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "为了获得所有的配置选项，也可以直接引用配置类：",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "然而，建议只引用实际使用的配置选项。这不仅简化了单元测试，也使我们更容易从代码中看到实际需要的东西。",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "默认情况下，DI容器的所有提供者是一个单子，因此只被实例化一次。这意味着在UserRepository的例子中，在整个运行时间内，始终只有一个UserRepository的实例。在任何时候都不会创建第二个实例，除非用户用 \"new \"关键字手动创建。",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "然而，在各种使用情况下，一个提供者应该只在短时间内或只在某一事件中被实例化。这样的事件可以是，例如，一个HTTP请求或一个RPC调用。这就意味着每次事件发生时都会创建一个新的实例，在这个实例不再被使用后，它会被自动删除（由垃圾收集器）。",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "一个HTTP请求是一个典型的作用域的例子。例如，诸如会话、用户对象或其他与请求有关的提供者可以被注册到这个范围。要创建一个作用域，只需选择一个任意的作用域名称，然后用提供者来指定它。",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "一旦指定了一个作用域，就不能再直接通过DI容器获得该提供者，所以下面的调用失败了：",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedesmal geschehen sobald ein HTTP-Request reinkommt:": "相反，必须创建一个作用域的DI容器。这将在每次HTTP请求进来时发生：",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "在这个范围内的DI容器上，现在也可以请求也在这个范围内注册的提供者，以及所有没有定义范围的提供者。",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "由于所有的提供者默认是单子，每次调用`get(UserSession)`将总是返回每个范围内容器的相同实例。如果你创建了多个作用域的容器，也将创建多个UserSessions。",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "与Deepkit框架一起工作的应用程序默认有一个`http`、一个`rpc`和一个`cli`作用域。请分别参阅<<cli>>、<<http>>或<<rpc>>一章。",
        "Setup Calls": "设置调用",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "设置调用允许你操纵一个提供者的结果。这很有用，例如，使用另一种依赖注入的变体，方法注入。",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "设置调用只能分别用于模块API或应用API，并在模块之上注册。",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "`setupProvider`方法返回一个UserRepository的代理对象，其方法可以被调用。应该注意的是，这些方法调用只是被放在一个队列中，此时并没有被执行。相应地，也没有返回值。",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "除了方法调用，还可以设置属性。",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "这种赋值也只放在队列中。",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "队列中的调用或赋值，一旦被创建，就在提供者的实际结果上执行。也就是说，在ClassProvider的情况下，一旦实例被创建，它们就被应用到类实例上，在FactoryProvider的情况下，它们被应用到工厂的结果上，而在ValueProvider的情况下，它们被应用到提供者上。",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "为了不仅引用静态值，也引用其他提供者，可以使用函数`injectorReference`。这将返回一个对提供者的引用，这也是DI容器在执行设置调用时的请求。",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Interfaces也可以被分配设置调用。",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "命令行接口（CLI）程序是通过终端以文本输入和文本输出形式进行交互的程序。",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Deepkit中的CLI应用程序可以完全访问DI容器，因此可以访问所有提供者和配置选项。",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Dekoratoren, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI框架允许你根据简单的类来轻松注册自己的命令。事实上，它是以`@deepkit/app`为基础的，这是一个专门用于此目的的小包，也可以独立使用，不需要Deepkit框架。在这个包中，你将找到装饰CLI控制器类所需的装饰器。",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "控制器是由依赖注入容器管理或实例化的，因此可以使用其他提供者。",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit中的CLI程序是基于运行时类型的，因此必须已经正确安装@deepkit/type。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果成功完成，可以安装@deepkit/app或Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "注意，`@deepkit/app`是基于TypeScript装饰器的，该功能必须通过`experimentalDecorators`相应启用。",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "为了给你的应用程序创建一个命令，你需要创建一个CLI控制器。这是一个简单的类，它有一个方法`exeecute`，并配备了关于命令的信息。",
        "_Datei: app.ts_": "_文件：app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "在装饰器`@cli.controller`中，CLI应用程序的唯一名称被定义为第一个参数。进一步的选项，如描述，可以选择在对象中的第二个位置添加。",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "这段代码已经是一个完整的CLI应用程序，可以像这样启动：",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "你可以看到，一个 \"测试 \"命令可用。要运行这个，必须将名称作为参数传入：",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "也可以用`chmod +x app.ts`使文件可执行，这样`./app.ts`命令已经足以启动它。应该注意的是，这时需要一个所谓的",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "shebang。Shebang指的是脚本程序开始时的字符组合`#！`。在上面的例子中，已经出现了：`&#35;!/usr/bin/env ts-node-script`，并且使用了`ts-node`的脚本模式。",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "通过这种方式，可以创建和注册任何数量的命令。在`@cli.controller`中给出的唯一名称应该选择得当，并允许用`:`字符对命令进行分组（例如，`user:create`，`user:remove`，等等）。",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "为了添加参数，新参数被添加到`execute`方法中，并用`@arg`装饰器进行装饰。",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "如果你现在执行这个命令而没有指定一个名字，将会产生一个错误：",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "使用`--help`会给你更多关于所需参数的信息：",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "一旦名字被作为参数传递，TestCommand中的`execute`方法将被执行，名字将被正确传递。",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flags是另一种向命令传递数值的方式。通常这些是可选的，但不一定是。用`@flag name`装饰的参数可以通过`--name value`或`--name=value`传递。",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "在帮助视图中，你现在可以在 \"OPTIONS \"中看到一个`--id`标志是必要的。如果指定正确，命令就会收到这个值。",
        "Boolean Flags": "布尔标志",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "标志的优点是，它们也可以作为无值标志使用，例如，激活某种行为。只要一个参数被标记为可选的布尔值，这个行为就会被激活。",
        "Multiple Flags": "多个标志",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "为了向同一个标志传递多个值，可以将一个标志标记为一个数组。",
        "Single Character Flags": "单字符标志",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "为了让标志也能以单字符形式传递，可以使用`@flag.char('x')`。",
        "Optional / Default": "可选/默认",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "`execute`方法的签名定义了哪些参数或标志是可选的。如果参数被标记为可选，则不需要指定。",
        "The signature of the method `execute` defines which arguments or flags are optional. If the parameter is optional in the type system, the user does not have to provide it.": "方法`执行'的签名定义了哪些参数或标志是可选的。如果该参数在类型系统中是可选的，那么用户就不必提供它。",
        "Dasselbe für Parameter mit einem Default-Wert:": "有默认值的参数也是如此：",
        "Dies gilt auch für Flags in derselben Art und Weise.": "这也以同样的方式适用于标志。",
        "Serialization / Validation": "序列化/验证",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "所有的参数和标志都会根据它们的类型自动反序列化，进行验证，并且可以提供额外的限制。",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "所以定义为数字的参数在控制器中总是被保证为实数，尽管命令行界面是基于文本的，因此是字符串。",
        "Zusätzliche Einschränkungen können mit den Typen-Dekoratoren aus `@deepkit/type` definiert werden.": "额外的限制可以通过`@deepkit/type`的类型装饰器来定义。",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "`id`的`Postive`类型表示只需要正数。如果用户现在传递一个负数，`执行'中的代码根本不被执行，并出现一个错误信息。",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "如果数字是正数，这时又像以前一样工作。这种额外的验证是非常容易做到的，它使命令对错误的条目更加强大。",
        "Description": "描述",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "为了描述一个标志或参数，可以使用`@flag.description`或`@arg.description`。",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "在帮助视图中，这个描述出现在标志或参数的后面：",
        "Exit code": "退出代码",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "退出代码默认为0，这意味着命令被成功执行。要改变退出代码，应该在`exucute`方法中返回一个非0的数字。",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "命令的类由DI容器管理，所以可以定义依赖关系，通过DI容器解决。",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "处理HTTP查询有时是服务器最著名的任务。它将输入（HTTP请求）转换为输出（HTTP响应），并执行一项特定的任务。客户端可以通过HTTP请求以各种方式向服务器发送数据，这些数据必须被正确读取和处理。除了HTTP主体外，HTTP查询或HTTP头值也是可能的。数据如何被实际处理取决于服务器。",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "这里的首要任务不仅是正确执行用户期望的内容，而且要正确转换（反序列化）和验证来自HTTP请求的任何输入。",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "HTTP请求在服务器上通过的管道可能是多样化和复杂的。许多简单的HTTP库只是简单地传递给定路由的HTTP请求和HTTP响应，并期望开发者直接处理HTTP响应。一个中间件API允许管道根据需要进行扩展。",
        "_Express Beispiel_": "_Express Example_",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte bzw Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den User damit eine Architektur selbst obendrauf zu setzen, die einem diese zwingenden Funktionalitäten abnimmt.": "这对简单的用例来说是非常合适的，但随着应用的增长，很快就会变得混乱，因为所有的输入和输出都必须手动进行序列化或反序列化并进行验证。还有必要考虑如何从应用程序本身获得对象或服务，如数据库抽象。",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection: Serialisierung bzw Deserialisierung und Validierung von jeglichen Werten passiert automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer gewählten Architektur abzudecken.": "Deepkit的HTTP库使用了TypeScript和依赖注入的力量：序列化或反序列化以及任何数值的验证都是根据定义的类型自动进行的。",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "它还允许你通过一个功能性的API来定义路由，就像上面的例子一样，或者通过控制器类来覆盖所选架构的不同需求。这两种API变体都可以访问依赖性注入容器，因此可以方便地从应用程序中获得数据库抽象和配置等对象。",
        "_Deepkit Beispiel_": "_Deepkit 示例_",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，必须用`experimentalDecorators`相应启用该功能。",
        "Funktionale API": "功能API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "功能API是基于函数的，可以通过路由器注册表注册，可以通过应用程序的DI容器获得。",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "路由器注册表也可以在事件监听器或引导中获得，这样就可以根据模块、配置和其他提供者注册各种路由。",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "一旦使用了模块，功能路由也可以由模块动态提供。",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "参见<<framework-modules>>一章，了解更多关于App Modules的信息。",
        "Controller API": "控制器API",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "控制器API基于类，可以通过App API在`controllers`选项下注册。",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "一旦使用了模块，控制器也可以由模块提供。",
        "HTTP Server": "HTTP服务器",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "如果使用Deepkit Framework，已经内置了一个HTTP服务器。然而，HTTP库也可以在不使用Deepkit框架的情况下使用自己的HTTP服务器。",
        "HTTP Client": "HTTP客户端",
        "todo: fetch API, validation, und cast.": "todo: fetch API, validation, and cast.",
        "Route Names": "Route Names",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Routes can be given a unique name that can be referenced in a redirect.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "路由器函数以及控制器类和控制器方法可以定义任意的依赖关系，由依赖注入容器来解决。",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "例如，如果一个数据库作为提供者被提供，它可以被注入：",
        "_Funktionaler API:_": "_功能型API:_",
        "_Controller API:_": "_控制器API:_",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "更多信息见<<依赖-注入>>一章。",
        "Input": "输入",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "以下所有的输入变化对功能型和控制器API的功能都是一样的。",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "这不仅大大提高了安全性，而且还简化了单元测试，",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "因为严格来说，为了测试路由，甚至不需要存在一个HTTP请求对象。",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "所有参数都被自动转换（反序列化）为定义的TypeScript类型并进行验证。这是通过`@deepkit/type`包及其<<序列化>>和<<验证>>功能完成的。",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "为了简单起见，下面展示了所有带有功能API的例子。",
        "Path Parameters": "路径参数",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "路径参数是从路由的URL中提取的值。",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "转换是使用<<serialisation-loosely-conversion>>功能自动完成的。",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "如果一个路径参数被定义为字符串以外的类型，它将被正确转换。",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "额外的验证约束也可以应用于该类型。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>一章。",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "路径参数在URL匹配时默认设置为`[^/]+`正则表达式。这方面的正则表达式可以调整如下：",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "这只有在特殊情况下才需要，因为通常情况下，与验证类型本身相结合的类型已经正确地限制了可能的值。",
        "Query Parameters": "查询参数",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "查询参数是URL中`?`字符后面的值，可以用`HttpQuery<T>`类型读取。",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "查询参数的名称与查询参数的名称相对应。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "所有来自`@deepkit/type`的验证类型都可以应用。关于这一点，请参见<<http-validation>>章节。",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*警告*。参数值没有被转义/消毒。在路由中直接以字符串的形式将它们作为HTML返回，会打开一个安全漏洞（XSS）。确保从不信任外部输入，并在必要时过滤/净化/转换数据。",
        "Query Model": "查询模型",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "由于有很多查询参数，很快就会变得混乱。",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "指定模型中的属性可以包含所有TypeScript类型和`@deepkit/type'支持的验证类型，只有在例如要在同一个路由中手动评估关于body的错误信息时才使用`HttpBodyValidation`。参见<<序列化>>和<<验证>>两章。",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "对于允许HTTP主体的HTTP方法，也可以指定一个主体模型。",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "来自HTTP请求的body内容类型必须是`application/x-www-form-urlencoded`、`multipart/form-data`或`application/json`，以便Deepkit自动将其转换为JavaScript对象。",
        "Manual Validation Handling": "手动验证处理",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "为了手动处理body模型的验证，可以使用一个特殊类型`HttpBodyValidation<T>`。它允许接收无效的主体数据，并对错误信息作出非常具体的反应。",
        "Sobald valid() den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "一旦valid()返回值`false`，指定模型中的值可能处于错误的状态。这意味着验证失败。如果没有使用`HttpBodyValidation`，并且收到了一个不正确的HTTP请求，该请求将被直接中止，函数中的代码将永远不会被执行。",
        "File Upload": "文件上传",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "主体模型上的一个特殊的属性类型可以用来允许客户端上传文件。可以使用任何数量的`UploadedFile`。",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "默认情况下，路由器将所有上传的文件存储在一个临时文件夹中，一旦路由中的代码被执行，就将其删除。因此，有必要读取`path`中指定路径的文件，并将其保存到一个永久的位置（本地硬盘、云存储、数据库）。",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet werden, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "HTTP服务器中的验证是一个强制性的功能，因为它几乎总是涉及到不能信任的数据工作。数据验证的地方越多，服务器就越稳定。HTTP路由中的验证可以方便地通过类型和验证约束来使用，并通过来自`@deepkit/type`的高度优化的验证器进行检查，因此在这方面不存在性能问题。因此，强烈建议使用这些验证能力。",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "所有的输入，如路径参数、查询参数和主体参数都会自动验证为指定的TypeScript类型。如果通过`@deepkit/type`的类型指定了额外的约束，这些约束也会被检查。",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "关于这方面的更多信息，请看<<validation>>章节。",
        "Output": "输出",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "路由可以返回各种数据结构。其中一些是以特殊的方式处理的，如重定向和模板，而其他的，如简单的对象，只是作为JSON发送。",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "默认情况下，正常的JavaScript值会以JSON形式返回给客户端，标题为`application/json; charset=utf-8`。",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "如果在函数或方法中指定了明确的返回类型，那么数据将根据该类型被Deepkit JSON序列化器序列化为JSON。",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "要发送HTML，有两种可能。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "带TSX的Template-Engine变体的优点是使用的变量会自动进行HTML转义。见<<template>>一章。",
        "Custom Content": "自定义内容",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "除了HTML和JSON，还可以发送具有特定内容类型的文本或二进制数据。这是通过对象`Response`",
        "Zusätzliche Header": "Additional Header",
        "Um den Header einer Antwort zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "来改变响应的头，可以在对象`Response`、`JSONResponse`和`HTMLResponse`上调用其他方法。",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "要返回301或302重定向作为响应，可以使用`Redirect.toRoute`或`Redirect.toUrl`。",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "这里的`Redirect.toRoute`方法使用路由的名称。如何设置路由名称可以在<<http-route-name>>部分看到。如果这个被引用的路由（查询或路径）包含参数，这些参数可以通过第二个参数指定：",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "或者，用`Redirect.toUrl`重定向到一个URL。",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "默认情况下，两者都使用302重定向。",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "所有的HTTP控制器和功能路由都在`http`依赖性注入范围内管理。HTTP控制器为每个HTTP请求进行相应的实例化。这也意味着两者都可以访问为`http`范围注册的提供者。因此，另外来自`@deepkit/http`的`HttpRequest`和`HttpResponse`可以作为依赖关系使用。如果使用Deepkit Framework，`@deepkit/framework'中的`SessionHandler'也是可用的。",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "在`http'范围内放置提供者可能相当有用，例如为每个HTTP请求重新实例化服务。一旦HTTP请求被处理，`http`作用域的DI容器就会被删除，从而从垃圾收集器（GC）中清理掉所有的提供者实例。",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见<<依赖-注入-作用域>>一章，了解如何在`http`作用域中放置提供者。",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "HTTP模块基于一个工作流引擎，它提供了各种事件标记，可以用来钩住处理HTTP请求的整个过程。",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "工作流引擎是一个有限状态机，为每个HTTP请求创建一个新的状态机实例，然后从一个位置跳到另一个位置。第一个位置是 \"开始\"，最后一个是 \"回应\"。",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "每个事件标记都有自己的事件类型，并有额外的信息。",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "由于所有的HTTP事件都是基于工作流引擎的，它的行为可以通过使用指定的事件并通过`event.next()`方法跳转到那里来修改。",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "HTTP模块在这些事件标记上使用自己的事件监听器来实现HTTP请求的处理。所有这些事件监听器的优先级都是100，这意味着当你监听一个事件时，你的监听器将被默认首先执行（因为默认优先级是0）。",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "例如，假设你想捕捉一个控制器被调用的事件，那么你可以在HTTP模块的事件监听者之后添加一个高于100的优先级。如果一个特定的控制器要被调用，我们要检查用户是否有权限访问它。如果用户有权限，我们继续。但如果不是，我们就跳到下一个工作流程项目`accessDenied`。在那里，访问拒绝的程序会被自动进一步处理。",
        "Middleware": "中间件",
        "Resolver": "解析器",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "路由器支持一种解析复杂参数类型的方法。例如，给定一个路由，如`/user/:id`，这个`id`可以通过一个解析器解析到路由之外的`user`对象。这进一步解耦了HTTP抽象和路由代码，进一步简化了测试和模块化。",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "用户不一定要在这里依赖一个参数。它也可以依赖于会话或HTTP头，并且只在用户登录后提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，所以很多用例都可以通过这种方式进行映射。",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "原则上，也可以通过依赖注入容器从`http`范围提供复杂的参数类型，因为这些也可以在路由函数或方法中使用。然而，这有一个缺点，就是不能使用异步函数调用，因为DI容器自始至终都是同步的。",
        "RPC": "RPC",
        "Connection": "连接",
        "Entity": "实体",
        "Session": "会话",
        "Query": "查询",
        "Repository": "存储",
        "Relations": "关系",
        "Inheritance": "继承",
        "Index": "索引",
        "Case Sensitivity": "大小写敏感度",
        "Character Sets": "字符集",
        "Key/Value": "Key/Value",
        "Pub/Sub": "Pub/Sub",
        "Eine TSX basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "一个基于TSX的模板引擎，可以以一种类型安全的方式生成HTML。",
        "TypeScript ist Javascript das skaliert. Eine Sprache, die designt ist, komplexen Code zu schreiben. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Das führt oft dazu, dass TypeScript-Code nach dem Kompilieren wie normaler JavaScript-Code aussieht. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern während dem Entwickeln (spätestens jedoch bei dem Kompilieren) viel schneller und einfacher als würde das mit reinem JavaScript möglich sein und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的Javascript。一种旨在编写复杂代码的语言。它允许编写带有类型的JavaScript，这些类型在编译时被检查和删除。这往往导致TypeScript代码在编译后看起来像普通的JavaScript代码。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "验证是任何应用程序的重要组成部分，使用一次太频繁比一次太少好。Deepkit提供了许多验证选项，并有一个高性能的实现，所以在绝大多数情况下，不需要担心执行时间。",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "CLI应用程序的参数和选项由方法参数通过TypeScript类型控制，并自动进行序列化和验证。",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI是Deepkit Framework应用程序的三个入口点之一。在Deepkit框架中，应用程序总是通过CLI程序启动，该程序本身是由用户用TypeScript编写的。因此，没有针对Deepkit的全局CLI工具来启动Deepkit应用程序。这是你启动HTTP/RPC服务器、执行迁移或运行你自己的命令的方式。这都是通过同一个入口点，同一个文件完成的。一旦通过从`@deepkit/framework`中导入`FrameworkModule`来使用Deepkit框架，应用程序就会得到应用服务器、迁移等的额外命令。",
        ":stem[\\documentclass[UTF8]{ctexart}]": ":stem[/documentclass[UTF8]{ctexart}]",
        "Benutzung": "使用",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "依赖注入（DI）是一种设计模式，其中类和函数_receive_ their dependencies。它遵循反转控制（IoC）的原则，有助于更好地分离复杂的代码，以提高可测试性、模块化和清晰度。尽管还有其他设计模式，如服务定位器模式，来应用IoC的原则，但DI已经确立了自己的主导模式，特别是在企业软件中。",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript是可以扩展的JavaScript。一种旨在实现复杂用例的语言。它允许用类型来编写JavaScript，这些类型在编译时被检查和删除。这种类型的安全允许更容易编写和维护复杂的应用程序。除其他外，这也是使TypeScript如此受欢迎的原因。",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript现在是世界上最大的开发者社区，它为开发者提供了相应的大量选择，包括许多库和工具，以满足项目的需要。然而，要找到合适的图书馆并不总是那么容易。通常情况下，这些库的理念、API和代码质量差别很大，以至于开发人员必须引入大量的粘性代码和额外的抽象，以使这些库能够相互正常工作。近几十年来，制造商或社区将几乎每个项目都需要的核心功能放在漂亮的抽象化的库中，并将其汇集到一个框架中，这已经一次又一次地证明了自己。Java Spring、PHP Symfony/Laravel和C++ QT只是其中几个著名的成功例子。",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "这些框架通常为开发者提供广泛使用的、已有几十年历史的概念，这些概念以库或组件的形式实现，这样就可以根据需要方便地相互协调使用。所提供的功能和设计模式不是立方体，而是基于有时是几十年前的概念，并在与其他想法的竞争中证明了自己。",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript在编译过程中完全删除了其类型信息，只要TypeScript被转换为JavaScript，那么在生成的JavaScript中或运行时就不存在任何相关信息。不可否认，在开发过程中和检查程序的正确性时，类型是非常有价值的。然而，类型在运行时也有巨大的价值。在数据在运行时被转换/序列化、数据被验证、元信息被添加到对象或需要接口信息的情况下，这个值会被反映出来。在这些和其他许多用例中，类型信息在运行时可能非常有用，因为它为库提供了必要的信息以有效地提供功能。目前，许多这些用例反而使用了不完全模仿TypeScript类型系统的替代品，并迫使开发者以一种与TypeScript语法无关的新方式来编写类型。其结果是，TypeScript强大的类型系统在这里不能再发挥其优势，而必须使用不那么符合人体工程学、效率较低的工作方式。",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "基于这种范式的转变，Deepkit为几乎所有程序中都能找到的用例开发了一整套库。验证、序列化、数据库抽象、CLI解析器、HTTP路由器、RPC框架、记录器、模板系统、事件系统等等。与其他库的根本区别在于，类型信息是功能的核心，尽可能多的TypeScript应该在运行时被重用，这样就可以减少开发者需要编写的模板，即使是复杂的程序也可以一目了然地看到它们在做什么。毕竟，TypeScript的主要特点之一是为复杂的代码赋予表达能力，而Deepkit以强大的框架形式将这些表达能力的好处带到了运行时，现在可以通过适当的企业模式更好地扩展应用架构。",
        "Type Compiler": "类型编译器",
        "Typeninformation Empfangen": "接收类型信息",
        "Validate&lt;typeof MyValidator&gt;": "Validate&lt;typeof MyValidator&gt;",
        "Pattern&lt;typeof MyRegexp&gt;": "Pattern&lt;typeof MyRegexp&gt;",
        "Decimal&lt;number, Number&gt;": "Decimal&lt;number, Number&gt;",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "有些语言比其他语言更适合于应用某些模式。对于JavaScript甚至TypeScript本身，各种设计模式往往可以在其核心中使用，但有一些限制，大量损害用户体验，从而影响速度。例如，如果一个依赖注入框架指定并基于它们，那么Typescript装饰器及其所有的特异性可能成为必要的。",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "代码可以在部门之间共享（前端、后端、微服务等）。",
        "Models, Typen und Interfaces": "模型、类型和接口",
        "Business logic": "业务逻辑",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "单一包管理器的统一审计系统。",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "在所有部门中重复使用熟悉的第三方库。",
        "Wissensteilung innerhalb der Teams.": "团队内的知识共享。",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "招聘简化为一个群体（而且是最大的群体：JavaScript开发人员）。",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "在运行时在TypeScript中提供类型信息变化很大。它允许采用新的工作方式，而这在以前只能以迂回的方式或根本不可能实现。声明类型和模式已经成为现代开发过程中的一个重要部分。GraphQL、验证器、ORM、ProtoBuf等编码器以及其他许多东西都依赖于在运行时有模式信息可用，以提供基本功能。这些工具和库有时需要开发人员学习全新的语言，这些语言是专门为使用情况开发的。例如，ProtoBuf和GraphQL有自己的声明语言，验证器通常基于自己的模式API，甚至是JSON模式，这也是一种独立的定义结构的方式。其中一些需要在每次更改时运行代码生成器，以便将模式信息也提供给运行时。另一个著名的模式是使用实验性的TypeScript装饰器，在运行时向类提供元信息。",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "`message`是字符串类型，返回类型是`void`类型的信息不再可用了。",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "运行时类型信息默认不生成。必须在`tsconfig.json`文件中设置`\"反射\": true`，以便在这个文件的同一文件夹中的所有文件或所有子文件夹中启用它。如果要使用装饰器，`\"experimentalDecorators\": true`必须在`tsconfig.json`中启用。",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "TypeScript本身不允许你通过`tsconfig.json'来配置类型编译器，这对于使用`@deepkit/type'并不是严格必要的，但对于其他deepkit库和`@deepkit/framework'中的某些功能是必要的。有必要直接使用TypeScript编译器API或像Webpack这样的构建系统与_ts-loader_。为了给Deepkit用户省去这个不方便的路径，Deepkit类型编译器一旦安装了`@deepkit/type-compiler`，就会自动安装在`node_modules/typescript`中（这是通过NPM安装挂钩完成的）。",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "如果类型编译器不能成功地自动安装（例如，因为NPM安装钩子被禁用），这可以通过以下命令手动完成：",
        "Typen-Decorators": "类型装饰器",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "类型装饰器是正常的TypeScript类型，包含元信息，可以在运行时改变各种函数的行为。Deepkit已经提供了一些类型装饰器，涵盖了一些使用情况。例如，一个类属性可以被标记为主键、引用或索引。数据库库可以在运行时使用这些信息来创建正确的SQL查询，而不需要事先生成代码。",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Validator约束，如`MaxLength`、`Maximum`或`Positive`，也可以添加到任何类型。也可以告诉序列化器如何序列化或反序列化一个特定的值。此外，还可以创建完全自定义的类型装饰器，并在运行时读取这些装饰器，从而可以在运行时非常自定义地使用类型系统。",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit带有一整套类型装饰器，所有这些都可以直接从`@deepkit/type`中使用。它们被设计成不来自多个库，这样就不会把代码直接绑在某个特定的库上，如Deepkit RPC或Deepkit数据库。这使得类型的重用更加容易，即使是在前端，即使使用了数据库类型装饰器。",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "下面是现有类型装饰器的列表。`@deepkit/type`和`@deepkit/bson`的验证器和序列化器以及`@deepkit/orm`的Deepkit数据库以不同的方式使用这一信息。请参阅相关章节了解更多。",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Integer和floats被定义为基数`number`，并有几个子变量：",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "这里，在运行时，用户的`id`是一个数字，但在验证和序列化时被解释为一个整数。",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "这意味着在这里，例如，浮点数可能不会被用于验证，序列化器会自动将浮点数转换为整数。",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "子类型可以以同样的方式使用，如果要允许一定范围的数字，子类型是很有用的。",
        "Float": "Float",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4通常在数据库中存储为二进制，在JSON中存储为字符串。",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "将此字段标记为MongoDB的ObjectId。解决为一个字符串。",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save as bigint in JavaScript has a unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the BinaryBigInt is available.": "默认情况下，普通的bigint类型在JSON中序列化为数字（在BSON中序列化为长）。然而，这对可能保存的内容有限制，因为JavaScript中的bigint有无限的潜在大小，而JavaScript中的数字和BSON中的long是有限的。",
        "Same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (abs(x)).": "与bigint相同，但在数据库中序列化为无限大小的无符号二进制（而不是大多数数据库中的8字节），在JSON中为字符串。负值将被转换为正值（abs(x)）。",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM将BinaryBigInt存储为二进制字段。",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "在序列化中改变一个属性的名称。",
        "Group": "Group",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "属性可以被归为一组。对于序列化，你可以将一个组排除在序列化之外。",
        "Data": "Data",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "每个属性都可以添加额外的元数据，可以通过Reflection API读取。",
        "Excluded": "Excluded",
        "Each property can be excluded from the serialization process for a specific target.": "每个属性都可以从特定目标的序列化过程中排除。",
        "Embedded": "Embedded",
        "Marks the field as an embedded type.": "将字段标记为嵌入式类型。",
        "It's possible to change the prefix (which is per default the property name).": "可以改变前缀（默认是属性名称）。",
        "To annotate interfaces with entity information. Only used in the database context.": "用实体信息注释接口。",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Siehe dazu Kapitel Validation <<validation-constraint-types>>.": "See chapter Validation <<validation-constraint-types>>。",
        "Benutzerdefinierte Type-Decorators": "用户定义的类型装饰器",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "一个类型装饰器可以定义如下：",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "按照惯例，一个类型装饰器被定义为一个对象字面，有一个单一的可选属性`__meta`，它的类型是一个元组。这个元组的第一个条目是它的唯一名称，所有进一步的元组条目是任何选项。这允许一个类型装饰器配备额外的选项。",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "类型装饰器与相交运算符`&`一起使用。",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "类型装饰器可以通过`typeOf<T>()`和`metaAnnotation`的类型对象读出：",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "如果使用了类型装饰器`myAnnotation`，`annotation`中的结果是一个带有选项的数组，如果没有则是`undefined`。如果类型装饰器有额外的选项，如在`AnnotationOption`中看到的那样，传递的值将在数组中找到。",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "已经提供的类型装饰器如`MapName`、`Group`、`Data`等都有自己的注释对象：",
        "Siehe das Kapitel <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "参见<<runtime-types-reflection>>章节以了解更多信息。",
        "External Classes": "外部类",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "由于TypeScript默认不包含类型信息，所以从其他包（没有使用@deepkit/type-compiler）导入的类型/类将没有类型信息。",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "要为一个外部类注释类型，请使用`annotateClass`，并确保这个函数在你的应用程序的引导阶段执行，然后再在其他地方使用导入的类。",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "`MyExternalClass`现在可以在序列化函数和反射API中使用。",
        "To following shows how to annotate generic classes:": "下面展示了如何注释通用类：",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "`MyType<string>`只要`Object`被计算，就被缓存。因此，`a'和`b'的PropertySignature从缓存中具有相同的`类型'，但不是同一个Type对象。",
        "JIT Cache": "JIT缓存",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "将结果分配给同一个变量是很有用的，这样就不会不必要地创造一个新的变量。在`type`中，要么现在就存储一个类型对象，要么就抛出一个错误，例如，没有传递类型参数，Deepkit的类型编译器没有正确安装，或者没有启用类型信息的发射（见上面的安装部分）。",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "为了详细了解Deepkit如何编码和读取JavaScript中的类型信息，本章的目的是。它解释了类型实际上是如何被转换为字节码的，在JavaScript中发出，然后在运行时解释。",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "在写这篇文章时，类型编译器是一个所谓的TypeScript转化器。这个转化器是TypeScript编译器本身的一个插件，可以将TypeScript AST（抽象语法树）转化为另一个TypeScript AST。在这个过程中，Deepkit的类型编译器会读取AST，产生相关的字节码，并将其插入AST中。",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "现有的命令本身每个都是一个字节大小，可以在`@deepkit/type-spec`中找到，作为`ReflectionOp`的枚举。在写这篇文章的时候，命令集的规模超过81条。",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "为了防止命名冲突，每个类型都有一个\"__Ω \"作为前缀。对于每个明确定义的、被导出的或被导出的类型所使用的类型，一个字节码会发射出JavaScript。",
        "Error Reporting": "错误报告",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "函数`is`、`assert`和`validates`返回一个布尔值作为结果。为了获得验证规则失败的确切信息，可以使用函数`validate`。如果所有东西都被成功验证，它将返回一个空数组。如果出现错误，数组包含一个或多个条目，其结构如下：",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "该函数接收作为第一类型参数的任意TypeScript类型和作为第一参数的要验证的数据。",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "复杂的类型如接口、类或泛型也可以在这里使用。",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "这些限制通过类型装饰器添加到实际类型中。有一整套可以使用的装饰器。如果需要扩展，可以随意定义和使用自定义装饰器。",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "任何数量的类型装饰器都可以用`&`添加到实际类型中。结果，这里是`username'，然后可以在所有的验证函数中使用，也可以在其他类型中使用。",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "在JavaScript中，序列化通常是在JavaScript对象和JSON之间。JSON只支持字符串、数字、布尔值、对象和数组。另一方面，JavaScript支持许多其他类型，如BigInt、ArrayBuffer、类型化数组、Date、自定义类实例等等。现在，要使用JSON向服务器传输JavaScript数据，你需要一个序列化过程（在客户端）和一个反序列化过程（在服务器上），如果服务器将数据作为JSON发送给客户端，则反之亦然。使用`JSON.parse`和`JSON.stringify`往往不能满足这个要求，因为它不是无损的。",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "注意，虽然蚕食者也会验证数据的兼容性，但这些验证与<<validation>>章节的验证不同。只有`cast'函数在反序列化成功后还会调用<<validation>>章节中的完整验证过程，如果数据无效就会抛出一个错误。",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "当错误发生时，来自序列化和验证的所有函数都会从`@deepkit/type'抛出一个`ValidationError'。",
        "Cast": "Cast",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "反序列化过程中实现了软类型转换。这意味着字符串类型的字符串和数字或字符串类型的数字可以被接受并自动转换。这很有用，例如，当数据通过一个URL被接受并传递给反序列化器时。由于URL总是一个字符串，Deepkit Type仍然会尝试解决Number和Boolean的类型。",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "以下软类型转换已经内置于JSON序列化器中：",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*。Number或Bigint接受String、Number和BigInt。 如果需要转换，它将使用`parseFloat`或`BigInt(x)`。",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*:布尔型接受数字和字符串。0，'0'，'false'被解释为`false'。1，'1'，'真'被解释为`真'。",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*字符串*。字符串接受Number、String、Boolean等。所有非字符串的值都会自动用`String(x)`转换。",
        "Type-Decorators": "Type-Decorators",
        "Integer": "Integer",
        "Mapped": "Mapped",
        "Naming Strategy": "Naming Strategy",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": " UserRepository类有一个HttpClient作为依赖。这个依赖关系本身并不显眼，但UserRepository自己创建了HttpClient，这就有问题了。这一点乍一看很明显，但它有其缺点。如果我们想替换掉HttpClient怎么办？如果我们想在单元测试中测试UserRepository，而不允许真正的HTTP请求出去呢？我们怎么知道这个类甚至使用了HttpClient？",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "除了DI，服务定位器（SL）也是应用IoC原则的一种方式。这通常被认为是与依赖性注入相对应的，因为它请求依赖性而不是接受它们。如果HttpClient在上述代码中被请求如下，它将被称为服务定位模式。",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "想要使用UserRepository的代码还必须提供（注入）它的所有依赖。是每次都要创建HttpClient还是每次都要使用同一个HttpClient，现在由类的用户决定，而不再由类本身决定。它不再像服务定位器那样被要求（从类的角度），或者在最初的例子中，完全由类本身创建。这种反转的流程有各种好处：",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "代码更容易理解，因为所有的依赖关系都是明确可见的。",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "它促进了关注点分离原则，因为UserRepository在有疑问时不再负责自己创建非常复杂的依赖。",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "高层模块不应该从低层模块中导入任何东西。",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "实现应该基于抽象（接口）。",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "这里应该指出，尽管在理论上，依赖反转原则有其优点，但在实践中，它也有很大的缺点。这不仅导致了更多的代码（因为必须编写更多的接口），而且还导致了更多的复杂性（因为现在每个实现都有一个接口用于每个依赖关系）。只有当应用达到一定规模，并且还需要这种灵活性时，这种代价才是值得的。像任何设计模式和原则一样，这个也有它的成本使用因素，在使用之前应该考虑清楚。",
        "Injector API (Low Level)": "Injector API (Low Level)",
        "App API (Deepkit Framework)": "App API (Deepkit Framework)",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "一个稍微复杂的API是`InjectorModule`类，它允许将提供者换成不同的模块，以便在每个模块中创建多个封装的DI容器。这也允许每个模块使用配置类，这使得自动向提供者提供经过验证的配置值更加容易。模块之间可以相互导入，导出提供者，以建立一个层次结构和良好的分离架构。",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "为了默认将所有提供者导出到顶层，即根模块，可以使用选项`forRoot`。",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "一旦使用了Deepkit框架，就可以使用`@deepkit/app` API来定义模块。这是基于模块API的，所以那里的能力也是可用的。此外，还可以使用强大的钩子和定义配置加载器来映射更多的动态架构。",
        "Providers": "提供者",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "默认情况下，所有提供者都被标记为单子，因此在任何时候都只存在一个实例。要在每次提供的时候创建一个新的实例，可以使用`transient`选项。这导致每次都要重新创建类，或者每次都要执行工厂。",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "没有默认值，但仍然是必要的选项，可以用`！`来提供。这迫使模块的用户提供该值，否则将导致错误。",
        "Scopes": "Scopes",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "相反，必须创建一个有范围的DI容器。每次有HTTP请求进来时都会发生这种情况：",
        "*Abstractions/Interfaces*": "*Abstractions/Interfaces*",
        "CLI": "CLI",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "CLI框架允许你基于简单的类轻松注册自己的命令。事实上，它是以`@deepkit/app`为基础的，这个小包只是为了这个目的，也可以在没有Deepkit框架的情况下独立使用。这个包包含了装饰CLI控制器类所需的装饰器。",
        "Argumente": "Arguments",
        "Flags": "Flags",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "可以用`@deepkit/type`的类型装饰器来定义额外的约束。",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "这对简单的用例来说是非常合适的，但随着应用程序的增长，很快就会变得混乱，因为所有输入和输出都必须手动序列化或反序列化并进行验证。还必须考虑到如何从应用程序本身获得对象和服务，如数据库抽象。",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Deepkit的HTTP库利用了TypeScript和依赖注入的力量，迫使开发者在上面放置一个架构，以映射这些强制性功能。串行化/反串行化和任何值的验证都是根据定义的类型自动发生的。此外，它允许通过功能API（如上面的例子）或通过控制器类来定义路由，以涵盖架构的不同需求。",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "为了动态地提供控制器（例如，根据配置选项），可以使用`process`钩子。",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "从所有有名字的路由中，可以通过`Router.resolveUrl()`来请求URL。",
        "Body": "Body",
        "Header": "Header",
        "Stream": "Stream",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "一旦`valid()`返回`false`，指定模型中的值可能处于不正确状态。这意味着验证失败。如果没有使用`HttpBodyValidation`，并且收到了一个不正确的HTTP请求，该请求将被直接中止，函数中的代码将永远不会被执行。",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "HTTP服务器中的验证是一个强制性的功能，因为不值得信任的数据几乎总是被处理的。数据验证的地方越多，服务器就越稳定。HTTP路由中的验证可以方便地通过类型和验证约束来使用，并通过来自`@deepkit/type`的高度优化的验证器进行检查，因此在这方面不存在性能问题。因此，强烈建议使用这些验证能力。",
        "JSON": "JSON",
        "HTML": "HTML",
        "HTTP Errors": "HTTP错误",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "通过抛出各种HTTP错误，可以立即中断HTTP请求的处理，并输出错误的相应HTTP状态。",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "默认情况下，所有的错误都以JSON格式返回给客户端。这个行为可以根据需要在事件系统中的`httpWorkflow.onControllerError'事件下进行调整。参见<<http-events>>一节。",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "错误`HttpAccessDeniedError`是一个特殊情况。一旦它被抛出，HTTP工作流（见<<http-events>>）就不会跳到`controllerError'，而是跳到`accessDenied'。",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "用户定义的HTTP错误可以用`createHttpError'来创建和抛出。",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "为了改变HTTP响应的头，可以在对象`Response`、`JSONResponse`和`HTMLResponse`上调用其他方法。",
        "Redirect": "Redirect",
        "Scope": "Scope",
        "Events": "Events",
        "Sessions": "Sessions",
        "Controller": "Controller",
        "Server": "Server",
        "Client": "Client",
        "Authentication": "认证",
        "Transport Protocol": "传输协议",
        "WebSockets": "WebSockets",
        "TCP": "TCP",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Read Replica": "Read Replica",
        "Primitives": "Primitives",
        "Primary Key": "Primary Key",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Optional / Nullable",
        "Embedded Types": "Embedded Types",
        "Default Values": "Default Values",
        "Default Expressions": "Default Expressions",
        "Complex Types": "复杂类型",
        "Exclude": "排除",
        "Database Specific Column Types": "数据库特定列类型",
        "Session / Unit Of Work": "会话/工作单位",
        "Identity Map": "身份图",
        "Change Detection": "变化检测",
        "Request/Response": "请求/响应",
        "Find": "查找",
        "Filter": "过滤",
        "Equal": "相等",
        "Greater / Smaller": "较大/较小",
        "In": "In",
        "Order": "Order",
        "Pagination": "Pagination",
        "Aggregation": "Aggregation",
        "Join": "Join",
        "Returning": "Returning",
        "Patch": "Patch",
        "Delete": "Delete",
        "Lift": "Lift",
        "One To Many": "One To Many",
        "Many To Many": "Many To Many",
        "One To One": "One To One",
        "Constraints": "Constraints",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "On Delete/Update。RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Table Per Class": "Table Per Class",
        "Single Table Inheritance": "Single Table Inheritance",
        "Collations": "Collations",
        "Batching": "Batching",
        "Caching": "Caching",
        "Query Events": "Query Events",
        "Unit Of Work Events": "Unit Of Work Events",
        "Transactions": "Transactions",
        "Isolations": "Isolations",
        "Locking": "Locking",
        "Optimistic Locking": "Optimistic Locking",
        "Pessimistic Locking": "Pessimistic Locking",
        "Custom Types": "自定义类型",
        "Logging": "记录",
        "Migration": "迁移",
        "Seeding": "播种",
        "Raw Database Access": "原始数据库访问",
        "SQL": "SQL",
        "App Configuration": "App配置",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Publish / Subscribe": "Publish / Subscribe",
        "Template": "Template",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "一个基于服务器端TSX（JJS）的模板引擎。用它可以以一种类型安全的方式生成HTML。",
        "Components": "Components",
        "Function Components": "Function Components",
        "Class Components": "Class Components",
        "Dynamic HTML": "Dynamic HTML",
        "Optimization": "Optimisation",
        "Framework": "Framework",
        "Modules": "Modules",
        "Configuration": "Configuration",
        "Application Server": "Application Server",
        "Logger": "Logger",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Workflow",
        "Testing": "Testing",
        "Debugger": "Debugger",
        "Module": "Modules",
        "Profiler": "Profiler",
        "Deployment": "Deployment",
        "Compiling": "Compiling",
        "Packaging": "Packaging",
        "Docker": "Docker",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "但是，如果在运行时有一个类型系统，这些信息就可以保留下来，这样就可以通过程序读取消息的类型和返回类型。",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit正是让这成为可能。它与TypeScript的编译挂钩，确保所有的类型信息都内置于生成的JavaScript中。像typeOf()这样的函数（不要和运算符typeof混淆，小写的是o）就允许开发者访问它。因此，可以根据这些类型信息来开发库，使开发者可以将已经写好的TypeScript类型用于一系列的应用。",
        "UUID": "UID",
        "`SignedBinaryBigInt` is the same as BinaryBigInt but is able to store negative values as well.": "`SignedBinaryBigInt`与BinaryBigInt相同，但也能存储负值。",
        "Deepkit ORM stores SignedBinaryBigInt as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "Deepkit ORM将SignedBinaryBigInt存储为二进制。二进制有一个额外的前导符号字节，表示为uint：255表示负，0表示零，1表示正",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "Deepkit的许多组件，如HTTP路由器、RPC抽象，以及数据库抽象本身，都内置了验证功能，并自动执行，因此在许多情况下，没有必要手动操作。",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "上面使用的`User'类型的类型保护，最简单的形式如下。请注意，上面解释的与NaN有关的特殊功能并不是其中的一部分，因此这个类型保护并不完全正确。",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "这个代码更容易测试，因为所有的依赖关系都是唯一的，如果有必要，可以很容易地进行修改。",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "代码更加模块化，因为依赖关系可以很容易地交换。",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "另一个变体是将HttpClient依赖关系转移到一个抽象（接口）中，从而不将HTTP库的代码导入UserRepository",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "这被称为依赖性反转原则。UserRepository不再直接依赖一个HTTP库，而是基于一个抽象（接口）。因此，它解决了这个原则中的两个基本目标：",
        "Security": "安全",
        "MySQL": "MySQL",
        "Auto Increment": "自动增量",
        "RegExp": "RegExp",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "通过注入别名和原始提供者令牌的组合，也可以从不包含运行时类型信息的包中提供依赖性。",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "一个函数可以用来为提供者提供一个值。这个函数也可以包含参数，而这些参数又是由DI容器提供的。通过这种方式，可以访问其他依赖性或配置选项。",
        "Grouping AND/OR": "分组 AND/OR",
        "Multitenancy": "多租户",
        "Composite Primary Key": "复合主键",
        "Plugins": "插件",
        "Public Directory": "公共目录",
        "File Structure": "文件结构",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zur Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "在运行时读取类型信息是Deepkit建立其基础的能力。Deepkit库的API在很大程度上是为了尽可能多地使用TypeScript的类型信息，以便尽可能地提高效率。运行时的类型系统意味着类型信息在运行时是可读的，动态类型是可计算的。这意味着，例如，类的所有属性和函数的所有参数和返回类型都可以被读出来。",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save since bigint in JavaScript has an unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the types `BinaryBigInt` and `SignedBinaryBigInt` are available.": "默认情况下，普通的bigint类型在JSON中被序列化为数字（在BSON中为长）。然而，这对可能的保存有限制，因为JavaScript中的bigint有无限的潜在大小，而JavaScript中的数字和BSON中的long是有限的。为了绕过这个限制，可以使用`BinaryBigInt`和`SignedBinaryBigInt`类型。",
        "`BinaryBigInt` is the same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (`abs(x)`).": "`BinaryBigInt`与bigint相同，但在数据库中序列化为无限大小的无符号二进制（而不是大多数数据库的8字节），在JSON中序列化为字符串。负值将被转换为正值（`abs(x)`）。",
        "`SignedBinaryBigInt` is the same as `BinaryBigInt` but is able to store negative values as well. Deepkit ORM stores `SignedBinaryBigInt` as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "SignedBinaryBigInt'与'BinaryBigInt'相同，但也能存储负值。Deepkit ORM将`SignedBinaryBigInt`存储为二进制。二进制有一个额外的前导符号字节，表示为uint：255表示负，0表示零，1表示正。",
        "Siehe <<validation-constraint-types>>.": "见<<验证-约束-类型>>。",
        "Siehe <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "参见<<runtime-types-reflection>>以了解更多相关信息。",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in <<serialisation>> mehr Informationen.": "这段经常看到的代码是一个错误，可能导致程序崩溃或安全漏洞，因为使用了一个在运行时不提供任何安全保障的 \"作为数字 \"的类型铸造。用户可以简单地传递一个字符串作为`limit'，然后程序就会在`limit'中工作，尽管代码的基础是它必须是一个数字。为了在运行时保持这种安全性，有验证器和类型保护器。另外，可以用一个序列化器将 \"limit \"转换为一个数字。这方面的更多信息可以在<<序列化>>中找到。",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "请注意，尽管蚕食者也检查数据的兼容性，但这些验证与<<validation>>中的验证不同。只有 \"cast \"函数在成功反序列化后还会从<<validation>>章节中调用完整的验证过程，如果数据无效会抛出一个错误。",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe <<validation>>.": "另外，`validatedDeserialize`可以用来在反序列化后进行验证。另一种方法是手动调用`validate`或`validates`函数来处理来自`deserialize`函数的反序列化数据，见<<validation>>。",
        "Scoped DI Container haben die Fähigkeit, Werte dynamisch von außen zu setzen. So ist es zum Beispiel bei einem HTTP-Scope einfach möglich, die Objekte HttpRequest und HttpResponse zu setzen.": "范围内的DI容器有能力从外部动态地设置值。例如，在一个HTTP作用域中，很容易设置HttpRequest和HttpResponse对象。",
        "Siehe <<framework-modules>>, um mehr über App Module zu erfahren.": "参见<<framework-modules>>以了解更多关于App模块的信息。",
        "Siehe <<dependency-injection>> für mehr Informationen.": "更多信息请参见<<依赖-注入>>。",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in <<http-validation>> zu finden.": "可以应用`@deepkit/type`中的所有验证类型。关于这一点的更多信息可以在<<http-validation>>中找到。",
        "Siehe <<validation>> für mehr Informationen dazu.": "关于这方面的更多信息，请参见<<验证>>。",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu <<template>>.": "带有TSX的模板引擎变体的优点是，使用的变量会自动进行HTML转义。见<<模板>>。",
        "Siehe <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "参见<<依赖-注入-作用域>>，了解如何将提供者放在`http`作用域中。",
        "Der Decorator in `@http.resolveParameter` gibt dabei an, welche Klasse mit dem `UserResolver` aufgelöst werden soll. Sobald nun die angegebene Klasse `User` als Parameter in der Funktion beziehungsweise Methode angegeben ist, wird der Resolver genutzt, um diese bereitzustellen.": "`@http.resolveParameter`中的装饰器指定了要用`UserResolver`来解决的类。只要指定的类`User`在函数或方法中被指定为参数，解析器就会被用来提供它。",
        "Ist `@http.resolveParameter` an der Klasse angegeben, erhalten all Methoden dieser Klasse diesen Resolver. Der Decorator kann auch pro Methode angewendet werden:": "如果在类中指定了`@http.resolveParameter`，这个类的所有方法都会接收这个解析器。该装饰器也可以按方法应用。",
        "Auch kann die funktionale API genutzt werden:": "也可以使用功能性API。",
        "Das Objekt `User` muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der Benutzer eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle abbildbar sind.": "对象`User'不一定要依赖一个参数。它也可以依赖于会话或HTTP头，只在用户登录时提供。在`RouteParameterResolverContext`中，有很多关于HTTP请求的信息，因此可以映射出很多用例。",
        "RPC steht für Remote Procedure Call und erlaubt es, Funktionen (procedures) auf einem remote Server so aufzurufen als wäre es eine lokale Funktion. Im Gegensatz zu HTTP Client-Server Kommunikation geschieht die Zuordnung nicht über die HTTP-Methode und einer URL, sondern dem Funktionsnamen. Die zu sendenden Daten werden als normale Funktion-Argumente übergeben und das Resultat des Funktionsaufrufes auf dem Server an den Client zurückgesendet.": "RPC是指远程过程调用，允许在远程服务器上调用函数（过程），就像调用本地函数一样。与HTTP客户-服务器通信不同的是，分配不是通过HTTP方法和URL进行的，而是通过函数名称进行的。要发送的数据作为正常的函数参数被传递，服务器上的函数调用结果被发回给客户端。",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion schmaler ist, da weder mit Headern, Pfaden, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es einen speziellen Client benötigt.": "RPC的优点是客户-服务器的抽象比较窄，因为没有使用头文件、路径、查询字符串或类似的东西。缺点是服务器上通过RPC的功能不能被浏览器调用，需要一个特殊的客户端。",
        "Ein Schlüsselfeature von RPC ist, dass die Daten zwischen dem Client und Server automatisch serialisiert und deserialisiert werden. Aus diesem Grund sind meist typen-sichere RPC-Clients möglich. Manche RPC-Frameworks zwingen den Benutzern daher, die Typen (Parameter-Types und Return-Types) in einem bestimmten Format bereitzustellen. Dies kann in Form von einer eigenen DSL wie bei gRPC (Protocol Buffers) und GraphQL mit einem Code-Generator sein oder in Form von einem JavaScript Schema-Builder. Zusätzliche Validierung der Daten kann das RPC-Framework ebenfalls anbieten, wird aber nicht von allen unterstützt.": "RPC的一个关键特征是，客户端和服务器之间的数据被自动序列化和反序列化。由于这个原因，类型安全的RPC客户端通常是可能的。因此，一些RPC框架强迫用户以特定的格式提供类型（参数类型和返回类型）。这可以是自定义DSL的形式，如gRPC（协议缓冲区）和GraphQL的代码生成器，也可以是JavaScript模式生成器的形式。数据的额外验证也可以由RPC框架提供，但不是所有的框架都支持。",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus dem Kapitel <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "在Deepkit RPC中，类型是由TypeScript本身从函数中提取的（见<<runtime-types>>），因此不需要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。一旦定义了<<验证>>章中的额外限制，这些限制也会被自动验证。这使得通过RPC进行的通信极为类型安全和有效。Deepkit RPC中通过`rxjs`对流媒体的支持也使这个RPC框架成为实时通信的合适工具。",
        "Um das Konzept hinter RPC zu veranschaulichen folgender Code:": "为了说明RPC背后的概念，下面的代码。",
        "Eine Methode wie `hello` wird ganz normal innerhalb einer Klasse auf dem Server implementiert und kann dann von einem remote Client aufgerufen werden.": "像 \"hello \"这样的方法通常在服务器上的一个类中实现，然后可以从远程客户端调用。",
        "Da RPC fundamental auf asynchroner Kommunikation basiert, ist die Kommunikation meist über HTTP, kann aber auch über TCP oder WebSockets geschehen. Das bedeutet, dass alle Funktionsaufrufe in TypeScript selbst zu einem `Promise` umgewandelt werden. Mit einem entsprechenden `await` kann das Resultat asynchron empfangen werden.": "由于RPC从根本上是基于异步通信的，所以通信主要是通过HTTP，但也可以通过TCP或WebSockets发生。这意味着TypeScript本身的所有函数调用都被转换为一个`承诺'。有了相应的`await'，可以异步接收结果。",
        "Sobald ein Projekt im Client (meist Frontend) und Server (backend) TypeScript genutzt wird, spricht man von Isomorphic TypeScript. Ein typen-sicheres RPC Framework, das auf TypeScript's Typen basiert, ist dann besonders profitable für ein solches Projekt, da Typen zwischen Client und Server geteilt werden können.": "只要一个项目在客户端（通常是前端）和服务器（后端）使用TypeScript，它就被称为Isomorphic TypeScript。那么，基于TypeScript的类型安全的RPC框架对这样的项目来说是特别有利的，因为类型可以在客户端和服务器之间共享。",
        "Um diesen Vorteil zu nutzen, sollten Typen, die auf beiden Seiten genutzt werden, in eine eigene Datei oder Package ausgelagert werden. Das Importieren auf der jeweiligen Seite fügt diese dann wieder zusammen.": "为了利用这一点，在两边都使用的类型应该被换成一个单独的文件或包。在各自的页面上进行导入，然后再次合并它们。",
        "Das Interface `UserControllerApi` agiert hierbei als Vertrag zwischen Client und Server. Der Server muss dies korrekt implementieren und der Client kann es konsumieren.": "接口`UserControllerApi`在这里充当了客户端和服务器之间的契约。服务器必须正确地实现这一点，客户端可以消费它。",
        "Abwärtskompatiblität kann auf dieselbe Art und Weise umgesetzt werden wie bei einer normalen lokalen API auch: Entweder werden neue Parameter als optional markiert oder es wird eine neue Methode hinzugefügt.": "向后兼容可以用与普通本地API相同的方式实现：要么将新的参数标记为可选，要么添加一个新的方法。",
        "Es ist zwar auch möglich, direkt `UserController` via `import type { UserController } from './server.ts` zu importieren, so hat dies jedoch andere Nachteile wie keine Unterstützung für nominale Typen (was bedeutet, dass Klassen-Instanzen nicht mit `instanceof` geprüft werden können).": "虽然也可以通过`import type { UserController } from './server.ts'直接导入`UserController'，但这有其他缺点，比如不支持名义类型（这意味着类的实例不能用`instanceof'检查）。",
        "Da Deepkit RPC auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit RPC是基于运行时类型的，因此必须正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/rpc` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果这样做成功了，就可以安装`@deepkit/rpc`或Deepkit框架，该框架已经在引擎盖下使用该库。",
        "Zu beachten ist, dass Controller-Klassen in `@deepkit/rpc` auf TypeScript-Decorators basieren und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss": "请注意，`@deepkit/rpc`中的控制器类是基于TypeScript装饰器的，这个功能必须通过`experimentalDecorators`相应启用。",
        "Das Paket `@deepkit/rpc` muss auf dem Server und Client installiert werden, sofern beide ihre eigene `package.json` haben.": "如果服务器和客户端都有自己的`package.json`，则必须安装`@deepkit/rpc`包。",
        "Um über TCP mit dem Server zu kommunizieren, muss das Paket `@deepkit/rpc-tcp` im Client und Server installiert werden.": "要通过TCP与服务器通信，必须在客户端和服务器上安装`@deepkit/rpc-tcp`包。",
        "Für eine WebSocket-Kommunikation braucht es das Paket ebenfalls auf dem Server. Der Client im Browser hingegen nutzt `WebSocket` aus dem offiziellen Standard.": "对于WebSocket通信，它还需要服务器上的包。而浏览器中的客户端则使用官方标准中的 \"WebSocket\"。",
        "Sobald der Client über WebSocket auch in einer Umgebung genutzt werden soll, wo `WebSocket` nicht verfügbar ist (zum Beispiel NodeJS), so wird das Paket `ws` in dem Client benötigt.": "一旦客户端要通过WebSocket在没有`WebSocket`的环境中使用（例如NodeJS），客户端就需要`ws`包。",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend auf einer WebSocket-Kommunikation und der low-level API von `@deepkit/rpc`. Sobald das <<framework>> benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "下面是一个基于WebSocket通信和`@deepkit/rpc`低级API的全功能实例。一旦使用<<framework>>，控制器就会通过应用模块提供，而不需要手动实例化RpcKernel。",
        "_Datei: server.ts_": "文件：server.ts_",
        "_Datei: client.ts_": "档。client.ts_",
        "Das \"Procedure\" in Remote Procedure Call wird auch gerne Action genannt. Eine solche Action wird als Methode in einer Klasse definiert und mit dem `@rpc.action` Decorator markiert. Die Klasse selbst wird dabei als Controller durch den `@rpc.controller` Decorator markiert und einen eindeutigen Namen vergeben. Dieser Name wird dann im Client referenziert, um den korrekten Controller anzusprechen. Es können beliebig viele Controller definiert und registriert werden.": "远程过程调用中的 \"过程 \"也被称为行动。这样的动作被定义为一个类中的方法，并且用`@rpc.action`装饰器来标记。该类本身被`@rpc.controller`装饰器标记为控制器，并分配了一个唯一的名字。然后在客户中引用这个名字，以解决正确的控制器。任何数量的控制器都可以被定义和注册。",
        "Nur Methoden, die auch als `@rpc.action()` markiert sind, können von einem Client angesprochen werden.": "只有那些同时被标记为\"@rpc.action() \"的方法才能被客户端处理。",
        "Typen müssen explizit angeben werden und können nicht inferred werden. Das ist wichtig, da der Serializer genau wissen muss, wie die Typen aussehen, um diese in Binärdaten (BSON) oder JSON umzuwandeln.": "类型必须是明确指定的，不能推断。这一点很重要，因为序列化器需要确切地知道类型是什么，以便将它们转换成二进制数据（BSON）或JSON。",
        "Die Controller-Klassen werden von dem Dependency Injection Container von `@deepkit/injector` verwaltet. Wenn das Deepkit Framework genutzt wird, haben diese Controller automatisch zugriff auf die Provider des Modules, die den Controller bereitstellen.": "控制器类由`@deepkit/injector`的依赖注入容器管理。如果使用Deepkit框架，这些控制器会自动访问提供控制器的模块的提供者。",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden.": "然而，只要手动实例化一个`RpcKernel'，DI容器也可以被传递到那里。",
        "Siehe <<dependency-injection>>, um mehr zu erfahren.": "参见<<依赖性注入>>以了解更多。",
        "Nominal Types": "名义类型",
        "Error Forwarding": "错误转发",
        "Der Vorteil von RPC besteht darin, dass die Client-Server Abstraktion leichtgewichtiger ist, da weder mit Headern, URLs, noch Query-Strings oder Ähnlichem gearbeitet wird. Der Nachteil ist, dass Funktionen auf einem Server via RPC nicht von einem Browser ohne weiteres aufgerufen werden können und es oft einen speziellen Client benötigt.": "RPC的优点是客户端-服务器的抽象更轻，因为没有使用头文件、URL、查询字符串或类似的东西。其缺点是，服务器上通过RPC的功能不能轻易被浏览器调用，往往需要一个特殊的客户端。",
        "Server Controller": "服务器控制器",
        "Client Controller": "客户端控制器",
        "Der normale Flow in RPC ist es, dass der Client Funktionen auf dem Server ausführen kann. Es ist aber in Deepkit RPC auch möglich, dass der Server Funktionen auf dem Client ausführen kann. Um das zu erlauben, kann der Client ebenfalls einen Controller registrieren.": "RPC中的正常流程是，客户可以在服务器上执行功能。然而，在Deepkit RPC中，服务器也有可能对客户端执行功能。为了允许这一点，客户也可以注册一个控制器。",
        "Controller werden in dem Deepkit Framework in dem Dependency Injection Scope `rpc` instantiiert, sodass alle Controller automatisch auf diverse Provider aus diesem Scope zugriff haben. Diese zusätzlichen Provider sind `HttpRequest` (optional), `RpcInjectorContext`, `SessionState`, `RpcKernelConnection`, und `ConnectionWriter`.": "在Deepkit框架中，控制器被实例化在依赖性注入作用域`rpc`中，因此所有的控制器都能自动访问这个作用域中的各种提供者。这些额外的提供者是`HttpRequest`（可选），`RpcInjectorContext`，`SessionState`，`RpcKernelConnection`，和`ConnectionWriter`。",
        "Sobald jedoch ein `RpcKernel` manuell instantiiert wird, kann dort auch ein DI Container übergeben werden. Der RPC Controller wird dann über diesen DI Container instantiiert.": "然而，只要手动实例化一个`RpcKernel'，DI容器也可以被传递到那里。然后，RPC控制器通过这个DI容器被实例化。",
        "Wenn Daten auf dem Client von dem Funktionsaufruf empfangen werden, wurden diese zuvor auf dem Server serialisiert und anschließend auf dem Client deserialisiert. Sind in dem Return-Typ der Funktion nun Klassen genutzt, werden diese im Client rekonstruiert, verlieren jedoch ihre nominale Identität und alle Methoden. Um diesem Verhalten entgegenzuwirken, können Klassen als nominale Typen über eine eindeutige ID registriert werden. Dies sollte für alle Klassen gemacht werden, die in einer RPC-API genutzt werden.": "当客户端收到来自函数调用的数据时，它先前在服务器上被序列化，然后在客户端被反序列化。如果现在在函数的返回类型中使用了类，它们会在客户端被重构，但会失去它们的名义身份和所有方法。为了抵制这种行为，类可以通过一个唯一的ID注册为名义类型。对于所有在RPC API中使用的类都应该这样做。",
        "Um eine Klasse zu registrieren ist das Nutzen von dem Decorator `@entity.name('id')` nötig.": "要注册一个类，必须使用装饰器`@entity.name('id')`。",
        "Sobald diese Klasse nun als Resultat einer Funktion genutzt wird, wird ihre Identität gewahrt.": "只要这个类现在被用作一个函数的结果，它的身份就被保留了。",
        "RPC Funktionen können Fehler werfen. Diese Fehler werden standardmäßig an den Client weitergeleitet und dort erneut geworfen. Wenn eigene Error-Klassen genutzt werden, sollte ihr nominaler Typ aktiviert werden. Siehe dazu <<rpc-nominal-types>>.": "RPC函数可以抛出错误。默认情况下，这些错误被转发到客户端并在那里再次抛出。如果使用了自定义错误类，它们的名义类型应该被启用。见<<rpc-nominal-types>>。",
        "Standardmäßig sind alle RPC Funktionen von jedem Client aus aufrufbar. Auch ist das Feature Peer-To-Peer Kommunikation standardmäßig aktiviert. Um hier genau einstellen zu können, welcher Client was darf, kann die Klasse `RpcKernelSecurity` überschrieben werden.": "默认情况下，所有RPC函数都可以从任何客户端调用。点对点通信功能在默认情况下也被激活。为了能够准确地设置哪个客户被允许做什么，`RpcKernelSecurity'类可以被覆盖。",
        "Um diese zu nutzen wird entweder dem `RpcKernel` eine Instanz davon übergeben:": "要使用这个，要么把它的一个实例传给`RpcKernel`。",
        "Oder im Falle einer Deepkit Framework Anwendung die Klasse `RpcKernelSecurity` mit einem Provider überschrieben.": "或者在Deepkit Framework应用程序的情况下，`RpcKernelSecurity'类被覆盖了一个提供者。",
        "Authentication / Session": "认证/会话",
        "Das Objekt `Session` ist standardmäßig eine anonyme Session, was bedeutet, dass der Client sich nicht authentifiziert hat. Sobald er sich authentifizieren will, wird die Methode `authenticate` aufgerufen.  Das Token, das die `authenticate` Methode erhält, kommt von dem Client und kann einen beliebigen Wert haben.": "对象`session`默认是一个匿名会话，这意味着客户端没有认证自己。一旦它想进行认证，就会调用`authenticate`方法。  `authenticate`方法收到的令牌来自客户端，可以有任何值。",
        "Sobald der Client einen Token setzt, wird die Authentifizierung ausgeführt, sobald die erste RPC Funktion oder manuell `client.connect()` aufgerufen wird.": "一旦客户端设置了一个令牌，只要调用第一个RPC函数或手动`client.connect()`，就会进行认证。",
        "Hier erhält `RpcKernelSecurity.authenticate` das Token `123456789` und kann entsprechend eine andere Session zurückgeben. Diese zurückgegebene Session wird dann an alle anderen Methoden wie der `hasControllerAccess` übergeben.": "这里`RpcKernelSecurity.authenticate`接收到令牌`123456789`并可以相应地返回另一个会话。这个返回的会话将被传递给所有其他的方法，如`hasControllerAccess`。",
        "Controller Access": "控制器访问",
        "Mit der Methode `hasControllerAccess` kann bestimmt werden, ob ein Client eine bestimmte RPC Funktion ausführen darf. Diese Methode wird bei jedem RPC Funktionsaufruf ausgeführt. Gibt diese `false` zurück, ist der Zugriff verweigert und es wird ein Fehler auf dem Client geworfen.": "`hasControllerAccess`方法可用于确定客户端是否被允许执行特定的RPC功能。这个方法在每次RPC函数调用时都会执行。如果它返回 \"false\"，则拒绝访问，并向客户抛出一个错误。",
        "In `RpcControllerAccess` sind mehrere wertvolle Informationen über die RPC Funktion enthalten:": "在`RpcControllerAccess`中，有几条关于RPC函数的有价值的信息。",
        "Gruppen und zusätzliche Daten sind über den Decorator `@rpc.action()` änderbar:": "组和其他数据可以通过装饰器`@rpc.action()`来改变。",
        "Transform Error": "变形误差",
        "Da geworfene Fehler automatisch mit all seinen Informationen wie die Fehlermeldung und auch den Stacktrace dem Client weitergeleitet werden, könnte dies unerwünscht sensitive Informationen veröffentlichen. Um dies zu ändern, kann in der Methode `transformError` der geworfene Fehler abgeändert werden.": "由于抛出的错误会自动转发到客户端，并附上所有信息，如错误信息和堆栈跟踪，这可能会不必要地公布敏感信息。要改变这一点，可以在`transformError`方法中修改抛出的错误。",
        "Beachte, dass sobald der Error in einen generischen `Error` umgewandelt wird, der komplette Stacktrace und die Identität des Errors verloren gehen. Entsprechend kann in dem Client keine `instanceof` checks mehr auf den Error genutzt werden.": "请注意，一旦错误被转换为一般的 \"错误\"，完整的堆栈跟踪和错误的身份就会丢失。因此，在客户端的错误上不能使用`instanceof`检查。",
        "Wird Deepkit RPC zwischen zwei Microservices verwendet, und ist somit der Client und Server unter vollständiger Kontrolle des Entwicklers, so ist ein Transformieren des Errors nur selten nötig. Läuft der Client hingegen in einem Browser bei einem Unbekannten, so sollte in `transformError` genaustens darauf geachtet werden, welche Informationen man preisgeben möchte. Im Zweifel sollte jeder Error mit einem generischen `Error` umgewandelt werden, um so sicherzustellen, dass keine internen Details nach außen gelangen. Das Loggen des Errors würde sich an dieser Stelle dann anbieten.": "如果在两个微服务之间使用Deepkit RPC，并且客户端和服务器因此处于开发者的完全控制之下，那么转变错误就很少有必要。另一方面，如果客户端在一个未知的人的浏览器中运行，那么你应该在`transformError'中非常小心地确定你想披露的信息。如果有疑问，每个错误都应该用一个通用的 \"错误 \"进行转换，以确保没有内部细节被泄露。在这一点上，记录错误将是一个好主意。",
        "Sofern die Deepkit RPC Library direkt benutzt wird, wird die `RpcKernelSecurity` Klasse selbst instantiiert. Benötigt diese Klasse eine Datenbank oder einen Logger, so muss dieser selbst übergeben werden.": "如果直接使用Deepkit RPC库，则要实例化`RpcKernelSecurity`类本身。如果这个类需要一个数据库或一个记录器，这必须被传入本身。",
        "Wenn das Deepkit Framework genutzt wird, wird die Klasse von dem Dependency Injection Container instantiiert und hat so automatisch Zugriff auf alle anderen Provider der Anwendung.": "如果使用Deepkit框架，该类由依赖注入容器实例化，从而自动访问应用程序的所有其他提供者。",
        "Siehe hierzu auch <<dependency-injection>>.": "参见<<依赖性注入>>。",
        "Streaming RxJS": "流动的RxJS",
        "Deepkit RPC unterstützt mehrere Transportprotokolle. WebSockets ist dabei das Protokoll, das die beste Kompatibilität hat (da Browser es unterstützen) und gleichzeitig alle Features wie Streaming unterstützt. TCP ist in der Regel schneller und eignet sich hervorragend für die Kommunikation zwischen Servern (Microservices) oder Nicht-Browser Clients.": "Deepkit RPC支持几种传输协议。WebSockets是兼容性最好的协议（因为浏览器支持它），同时也支持流媒体等所有功能。TCP通常更快，非常适合服务器（微服务）或非浏览器客户端之间的通信。",
        "Deepkit's RPC HTTP Protokoll ist dabei eine Variante, die besonders einfach im Browser zu debuggen ist, da jeder Funktionsaufruf ein HTTP-Request ist, hat jedoch seine Limitierungen wie kein Support für RxJS Streaming.": "Deepkit的RPC HTTP协议是一个变种，在浏览器中特别容易调试，因为每个函数调用都是一个HTTP请求，但也有其局限性，如不支持RxJS流。",
        "TODO: Not implemented yet.": "TODO: 还没有实施。",
        "@deepkit/rpc-tcp `RpcWebSocketServer` and Browser WebSocket or Node `ws` package.": "@deepkit/rpc-tcp `RpcWebSocketServer`和浏览器WebSocket或Node `ws`包。",
        "@deepkit/rpc-tcp `RpcNetTcpServer` and `RpcNetTcpClientAdapter`": "@deepkit/rpc-tcp `RpcNetTcpServer`和`RpcNetTcpClientAdapter`。",
        "Event System": "事件系统",
        "Ein Event-System ermöglicht es Anwendungskomponenten im selben Prozess miteinander zu kommunizieren, indem sie Ereignisse versenden und auf sie hören. Es hilft bei der Modularisierung des Codes, indem Nachrichten zwischen Funktionen gesendet werden, die nicht direkt voneinander wissen.": "事件系统允许同一进程中的应用程序组件通过发送和监听事件来相互通信。它通过在互不相识的函数之间发送消息，帮助将代码模块化。",
        "Die Anwendung oder Library eröffnet dabei die Möglichkeit an einem bestimmten Zeitpunkt der Ausführung zusätzliche Funktionen auszuführen. Diese zusätzlichen Funktionen registrieren sich dabei selbst als sogenannte Event-Listener.": "应用程序或库开启了在某个时间点执行额外功能的可能性。这些额外的函数将自己注册为所谓的事件监听者。",
        "Ein Event kann dabei vielfältig sein:": "一个事件可以是多层面的。",
        "Die Anwendung fährt hoch oder runter.": "申请书上升或下降。",
        "Ein neuer User wurde erstellt oder gelöscht.": "一个新的用户已经被创建或删除。",
        "Eine Error wurde geworfen.": "抛出了一个错误。",
        "Ein neuer HTTP-Request ist hereingekommen.": "有一个新的HTTP请求进来了。",
        "Deepkit Framework und seine Libraries bieten bereits diverse Events an, auf die der Benutzer hören und reagieren kann. Es können jedoch auch beliebig viele eigene Events angelegt werden, um so die Anwendung modular erweiterbar zu machen.": "Deepkit框架及其库已经提供了各种事件，用户可以对其进行监听和反应。然而，可以创建任何数量的自定义事件，使应用程序可以模块化扩展。",
        "Nachfolgend ein Beispiel der Low-Level API von `@deepkit/event`. Wenn Deepkit Framework genutzt wird, geschieht die Registrierung von Event-Listener nicht über `EventDispatcher` direkt sondern über Module.": "下面是`@deepkit/event`的低级API的一个例子。如果使用Deepkit Framework，事件监听器的注册不是直接通过`EventDispatcher'而是通过模块完成的。",
        "Da das Event-System von Deepkit basiert auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit的事件系统是基于运行时类型的，因此有必要正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/event` installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "如果这样做成功了，就可以安装`@deepkit/event`或者已经在引擎盖下使用该库的Deepkit框架。",
        "Zu beachten ist, dass `@deepkit/event` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "请注意，控制器API的`@deepkit/event`是基于TypeScript装饰器的，一旦使用控制器API，就必须用`experimentalDecorators`相应地启用这一功能。",
        "Event Token": "事件标志",
        "Im Mittelpunkt vom Event-System stehen die Event-Tokens. Sie sind Objekte, die die eindeutige Event-ID und den Event-Typen definieren. Über ein Event-Token kann ein Event ausgelöst und auf ein Event gehört werden. Dabei ist konzeptionell derjenige, der den Event eines Event-Tokens auslöst, auch der Besitzer dieses Event-Tokens. Das Event-Token entscheidet entsprechend darüber, welche Daten an dem Event verfügbar sind und ob asynchrone Event-Listener erlaubt werden.": "事件系统的核心是事件令牌。它们是定义唯一事件ID和事件类型的对象。一个事件可以被触发，一个事件可以通过一个事件标记被监听。从概念上讲，触发事件令牌事件的人也是这个事件令牌的所有者。事件标记决定了在事件中哪些数据是可用的，以及是否允许异步事件监听器。",
        "TODO asynchrone": "TODO异步",
        "Event Types": "事件类型",
        "Propagation": "传播",
        "TODO. event.stop()": "TODO.event.stop()",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "由于Deepkit中的CLI程序是基于运行时类型的，因此有必要正确安装`@deepkit/type`。见<<runtime-types-installation>>。",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss, sobald die Controller API verwendet wird.": "请注意，控制器API的`@deepkit/http`是基于TypeScript装饰器的，一旦使用控制器API，就必须用`experimentalDecorators`相应地启用这一功能。",
        "In Deepkit RPC werden die Typen aus den Funktionen von dem TypeScript-Code selbst extrahiert (siehe <<runtime-types>>), sodass es nicht nötig ist, ein Code-Generator zu verwenden oder diese manuell zu definieren. Deepkit unterstützt dabei das automatische Serialisieren und Deserialisieren von Parametern und Resultaten. Sobald zusätzliche Einschränkungen aus <<validation>> definiert sind, werden diese auch automatisch validiert. Dies macht die Kommunikation über RPC extrem typen-sicher und effektiv. Die Unterstützung von Streaming via `rxjs` in Deepkit RPC macht dieses RPC-Framework auch zu einem geeigneten Tool für Echtzeitkommunikation.": "在Deepkit RPC中，函数的类型是从TypeScript代码本身中提取的（见<<runtime-types>>），因此不需要使用代码生成器或手动定义它们。Deepkit支持参数和结果的自动序列化和反序列化。一旦从<<validation>>定义了额外的约束，这些约束也会被自动验证。这使得通过RPC进行的通信极为类型安全和有效。Deepkit RPC中通过`rxjs`对流媒体的支持也使这个RPC框架成为实时通信的合适工具。",
        "Nachfolgend ein voll funktionsfähiges Beispiel basierend WebSockets und der low-level API von `@deepkit/rpc`. Sobald das Deepkit Framework benutzt wird, werden Controller über App-Module bereitgestellt und es wird kein RpcKernel manuell instantiiert.": "下面是一个基于WebSockets和`@deepkit/rpc`的低级API的全功能例子。一旦使用Deepkit框架，控制器就会通过应用模块提供，而不需要手动实例化RpcKernel。"
    },
    "polish": {
        "Einführung": "Wprowadzenie",
        "TypeScript ist JavaScript das skaliert. Eine Sprache, die designt ist, komplexe Anwendungsfälle umzusetzen. Es erlaubt das Schreiben von JavaScript mit Typen, die bei dem Kompilieren geprüft und entfernt werden. Diese dadurch entstehende Typensicherheit erlaubt das einfachere Schreiben und Warten von komplexen Anwendungen. Genau das ist unter anderem, was TypeScript so populär gemacht hat: Es erlaubt das Finden von Fehlern im Code insbesondere in großem Maßstab viel schneller und einfacher als würde das mit reinem JavaScript möglich sein - und arbeitet dabei nicht gegen, sondern mit JavaScript.": "TypeScript to JavaScript, który się skaluje. Język przeznaczony do implementacji złożonych przypadków użycia. Umożliwia ona pisanie języka JavaScript z typami, które są sprawdzane i usuwane w czasie kompilacji. Ten typ bezpieczeństwa pozwala na łatwiejsze pisanie i obsługę złożonych aplikacji. Między innymi to właśnie sprawiło, że język TypeScript stał się tak popularny: Umożliwia on znajdowanie błędów w kodzie, zwłaszcza na dużą skalę, znacznie szybciej i łatwiej niż byłoby to możliwe w przypadku czystego JavaScriptu - i działa raczej z JavaScriptem niż przeciwko niemu.",
        "Deepkit ist TypeScript das skaliert. Ein Framework geschrieben in TypeScript für TypeScript, das designt ist, sehr komplexe Software in TypeScript zu entwickeln. Es bringt viele Design-Muster bekannt aus den Enterprise zu TypeScript und führt komplett neue Features ein, die so nur mit TypeScript’s neuem Typensystem möglich sind, um so die Entwicklungsgeschwindigkeit vor allen in Teams zu erhöhen. Auch kleine Anwendungen können von diesem neuen Ansatz profitieren, da Deepkit viele Libraries für sehr gängige Anwendungsfälle mitbringt, die einzeln oder in Kombination genutzt werden können. Das Framework selbst ist dabei so agil wie möglich und komplex wie nötig designt, um nicht nur schnell erste Ergebnisse zu erhalten, sondern auch langfristig die Entwicklungsgeschwindigkeit aufrechtzuerhalten.": "Deepkit to TypeScript, który się skaluje. Szkielet napisany w języku TypeScript dla języka TypeScript, przeznaczony do tworzenia bardzo złożonego oprogramowania w języku TypeScript. Przenosi on do TypeScriptu wiele wzorców projektowych znanych z języka Enterprise i wprowadza zupełnie nowe funkcje, które są możliwe tylko dzięki nowemu systemowi typów TypeScriptu, aby zwiększyć szybkość tworzenia oprogramowania, zwłaszcza w zespołach. Z tego nowego podejścia mogą skorzystać również małe aplikacje, ponieważ Deepkit zawiera wiele bibliotek dla bardzo typowych przypadków użycia, które można stosować pojedynczo lub w połączeniu. Sam szkielet został zaprojektowany tak, aby był tak zwinny, jak to tylko możliwe, i tak złożony, jak to konieczne, nie tylko po to, aby szybko uzyskać pierwsze wyniki, ale także aby utrzymać szybkość rozwoju w dłuższej perspektywie.",
        "JavaScript ist mittlerweile die größte Entwicklercommunity weltweit und liefert dem Entwickler eine entsprechend große Auswahlmöglichkeit von vielen Libraries und Tools, um die Bedürfnisse eines Projektes abzudecken. Dabei ist es nicht immer ganz einfach, die richtige Library zu finden. Oft unterscheiden sich die Philosophien, API und Code-Qualitäten dieser so stark, dass viel Klebecode und zusätzliche Abstraktionen vom Entwickler eingeführt werden müssen, damit diese Libraries überhaupt untereinander einwandfrei funktionieren. Das Bereitstellen von Kernfunktionen, die so gut wie jedes Projekt benötigt, in schön abstrahierten Libraries zusammengeführt in einem Framework durch eines Herstellers beziehungsweise einer Community hat sich in den letzten Jahrzehnten immer wieder bewährt: Java Spring, PHP Symfony/Laravel, und C++ QT sind nur einige sehr bekannte und erfolgreiche Beispiele dazu.": "JavaScript jest obecnie największą społecznością programistów na świecie i zapewnia programistom odpowiednio duży wybór wielu bibliotek i narzędzi, które mogą zaspokoić potrzeby projektu. Nie zawsze jednak łatwo jest znaleźć odpowiednią bibliotekę. Często filozofie, API i właściwości kodu tych bibliotek różnią się tak bardzo, że programista musi wprowadzić wiele lepkiego kodu i dodatkowych abstrakcji, aby biblioteki te mogły ze sobą poprawnie współpracować. W ostatnich dziesięcioleciach wielokrotnie sprawdzało się dostarczanie podstawowych funkcji, których potrzebuje niemal każdy projekt, w postaci pięknie wyabstrahowanych bibliotek zebranych w ramy przez producenta lub społeczność: Java Spring, PHP Symfony/Laravel i C++ QT to tylko kilka znanych i udanych przykładów.",
        "Diese Frameworks bieten dem Entwickler oft weit verbreitete und jahrzehnte bewährte Konzepte, die in Libraries oder Komponenten umgesetzt sind, um so bequem untereinander harmonierend bedarfsgerecht angewendet werden zu können. Die angebotene Funktionalitäten und Design-Patterns sind dabei nicht gewürfelt, sondern basierend auf mitunter über jahrzehnte alte Konzepte, die sich durch den Kampf im Wettbewerb mit alternativen Ideen bewährt haben.": "Szkielety te często oferują programiście rozpowszechnione i znane od dziesięcioleci koncepcje, które są zaimplementowane w bibliotekach lub komponentach, dzięki czemu można je wygodnie zharmonizować ze sobą i stosować w razie potrzeby. Oferowane funkcje i wzorce projektowe nie są przypadkowe, lecz opierają się na koncepcjach, które niekiedy mają kilkadziesiąt lat i sprawdziły się w konkurencji z alternatywnymi pomysłami.",
        "JavaScript hat über die Jahre hinweg massive Fortschritte verzeichnet, sodass mittlerweile auch immer mehr Design-Muster aus dem Enterprise-Umfeld angewendet werden können. Design-Muster, die sich vermehrt in immer mehr Libraries, Framework, und Tools finden lassen. Dabei hat JavaScript und auch TypeScript jedoch das Problem, dass um viele bewährte Enterprise-Muster effizient anzuwenden, entscheidende Funktionen in der Sprache selbst fehlen. Das heisst nicht, dass diese Design-Muster generell nicht angewendet werden können, sondern dass diese weniger effizient als in anderen aktuellen Sprachen sind.": "JavaScript poczynił na przestrzeni lat ogromne postępy, dzięki czemu można obecnie stosować coraz więcej wzorców projektowych ze środowiska korporacyjnego. Wzorce projektowe, które można znaleźć w coraz większej liczbie bibliotek, frameworków i narzędzi. Jednak JavaScript, a także TypeScript mają ten problem, że aby efektywnie stosować wiele sprawdzonych wzorców korporacyjnych, w samym języku brakuje decydujących funkcji. Nie oznacza to, że tych wzorców projektowych nie można stosować ogólnie, ale że są one mniej wydajne niż w innych obecnych językach.",
        "TypeScript entfernt bei der Kompilierung, sobald TypeScript in JavaScript umgewandelt wird, seine Typeninformationen vollständig, sodass keine Informationen darüber in dem erzeugten JavaScript oder zur Laufzeit existiert. Es ist unstrittig, dass Typen sehr wertvoll während der Entwicklung und beim Prüfen der Korrektheit des Programs sind. Typen haben jedoch auch einen enormen Wert zur Laufzeit. Dieser Wert spiegelt sich da wider, wo zur Laufzeit Daten umgewandelt (konvertiert/serialisiert), Daten validiert, Meta-Informationen an Objekte hinzugefügt, oder Interface-Informationen benötigt werden. Bei diesen und vielen anderen Anwendungsfällen können Typeninformationen zur Laufzeit sehr nützlich sein, da sie den Libraries die notwendigen Informationen zu verfügung stellen, um Funktionalitäten effizient bereitzustellen. Aktuell nutzen viele dieser Anwendungsfälle stattdessen Alternativen, die das Typensystem von TypeScript unvollständig nachahmen und den Entwickler zwingen, Typen auf eine neue Art und Weise zu schreiben, die mit der Syntax von TypeScript nichts mehr zu tun hat. Das Resultat ist, dass TypeScript’s mächtiges Typensystem hier nicht mehr seine Stärke ausspielen kann und weniger ergonomische und weniger effizientere Arbeitsweisen stattdessen genutzt werden müssen.": "TypeScript całkowicie usuwa informacje o swoim typie w czasie kompilacji, gdy TypeScript jest konwertowany na JavaScript, więc w wygenerowanym JavaScripcie ani w czasie wykonywania nie ma o nim żadnych informacji. Nie ulega wątpliwości, że typy są bardzo cenne podczas tworzenia programu i sprawdzania jego poprawności. Jednak typy mają również ogromną wartość w czasie pracy. Wartość ta jest odzwierciedlona, gdy dane są konwertowane/serializowane w czasie wykonywania, dane są walidowane, do obiektów dodawane są metainformacje lub wymagane są informacje o interfejsie. W tych i wielu innych przypadkach użycia informacje o typie mogą być bardzo przydatne w czasie pracy, ponieważ dostarczają bibliotekom informacji niezbędnych do wydajnego działania. Obecnie wiele z tych przypadków użycia korzysta z alternatywnych rozwiązań, które nie do końca naśladują system typów TypeScript i zmuszają programistę do pisania typów w nowy sposób, który nie ma nic wspólnego ze składnią TypeScript. W rezultacie potężny system typów TypeScript nie może już pokazać swojej siły w tym miejscu, a zamiast tego trzeba stosować mniej ergonomiczne i mniej wydajne sposoby pracy.",
        "Deepkit hat einen Type-Compiler entwickelt, der die Typen-Informationen bestehen lässt und es so erlaubt, zur Laufzeit dynamische Typen zu berechnen und existierende Typeninformationen zur Laufzeit auszulesen. Mit diesem Paradigmenwechsel sind komplett neue Arbeitsweisen möglich, die den genannten Anwendungsfällen die benötigten Informationen bereitstellen, die das Entwickeln von komplexer Software radikal vereinfachen, und dem Code mehr Aussagekraft verleiht. Es ist damit zum ersten mal möglich, die volle Stärke und Aussagekraft von TypeScript auch zur Laufzeit zu nutzen.": "Firma Deepkit opracowała kompilator typów, który pozostawia informacje o typach w miejscu, umożliwiając obliczanie typów dynamicznych w czasie wykonywania zadania oraz odczytywanie istniejących informacji o typach w czasie wykonywania zadania. Dzięki tej zmianie paradygmatu możliwe są zupełnie nowe sposoby pracy, które zapewniają informacje wymagane w wyżej wymienionych przypadkach użycia, radykalnie upraszczają tworzenie złożonego oprogramowania i nadają kodowi większą wyrazistość. W ten sposób po raz pierwszy można wykorzystać pełną moc i ekspresyjność języka TypeScript w trybie runtime.",
        "Basierend auf diesem Paradigmenwechsel hat Deepkit eine ganze Reihe von Libraries für Anwendungsfälle entwickelt, die in so gut wie jedem Program zu finden sind: Validierung, Serialisierung, Datenbank Abstraktion, CLI parser, HTTP Router, RPC Framework, Logger, Template-System, Event-System und vieles mehr. Der grundlegende Unterschied zu anderen Libraries ist, dass Typeninformationen im Zentrum der Funktionalität stehen und soviel TypeScript wie möglich zur Laufzeit wiederverwendet werden soll, sodass weniger Boilerplate vom Entwickler geschrieben werden muss und auch komplexen Programmen auf einen Blick anzusehen ist, was sie machen. Eines der Schlüsselfunktionen von TypeScript ist es schließlich, auch komplexem Code einen Ausdruck zu verleihen und Deepkit bringt diese Vorteile der Ausdrucksstärke in die Laufzeit in Form eines mächtigen Frameworks, um nun auch die Applikation-Architektur mit entsprechenden Enterprise-Patterns besser zu skalieren.": "W oparciu o tę zmianę paradygmatu firma Deepkit opracowała cały szereg bibliotek dla przypadków użycia, które można znaleźć w niemal każdym programie: Walidacja, Serializacja, Abstrakcja bazy danych, Parser CLI, Router HTTP, Framework RPC, Logger, System szablonów, System zdarzeń i wiele innych. Zasadnicza różnica w stosunku do innych bibliotek polega na tym, że informacje o typie są podstawą funkcjonalności i jak najwięcej TypeScriptu powinno być ponownie wykorzystywane w czasie działania, tak aby programista musiał pisać mniej szablonów, a nawet złożone programy mogły na pierwszy rzut oka zorientować się, co robią. Wreszcie, jedną z kluczowych cech języka TypeScript jest nadawanie ekspresji nawet złożonemu kodowi, a Deepkit przenosi te zalety ekspresyjności do trybu runtime w postaci potężnego szkieletu, który pozwala teraz lepiej skalować architekturę aplikacji za pomocą odpowiednich wzorców korporacyjnych.",
        "Deepkit besteht dabei aus zwei großen Bereichen: Zum einen die Deepkit Libraries und das Deepkit Framework. Die Deepkit Libraries sind eine ganze Familie alleinstehender TypeScript Libraries (NPM Pakete), die ein Thema gut können und optimiert, gut getestet, sowie ausgelegt sind, sich gegenseitig optimal zu ergänzen. Ein Projekt kann einzelne Deepkit Libraries benutzen, oder das gesamte Deepkit Framework, welches alle Fähigkeiten der Libraries zusammenbringt und durch zusätzliche Tools wie den Debugger ergänzt. Alles zusammen gesehen erlaubt es dem Entwickler komplexe, schnelle, und produktionsbereite Anwendungen zu entwickeln.": "Deepkit składa się z dwóch dużych obszarów: Po pierwsze, biblioteki Deepkit oraz Deepkit Framework. Biblioteki Deepkit to cała rodzina samodzielnych bibliotek TypeScript (pakiety NPM), które są dobre w jednym temacie i są zoptymalizowane, dobrze przetestowane i zaprojektowane tak, aby optymalnie się uzupełniały. W projekcie można korzystać z poszczególnych bibliotek Deepkit lub z całego frameworka Deepkit, który łączy w sobie wszystkie możliwości bibliotek i uzupełnia je o dodatkowe narzędzia, takie jak debugger. Wszystko to razem pozwala programiście tworzyć złożone, szybkie i gotowe do produkcji aplikacje.",
        "Deepkit unterstützt dabei eine ganze Reihe von Anwendungsfällen. Von einfachen Command-Line Tools (CLI Programmen) zu Web-Anwendungen und Micro-Services bis hin zu Desktop- oder Mobile-Anwendungen. Dabei ist der Code so ausgelegt, dass er in jeder bekannten JavaScript-Engine läuft (Browser wie auch NodeJS) und sich wunderbar auch in andere Frameworks wie Angular, React, und Vue integrieren lässt.": "Deepkit obsługuje cały szereg przypadków użycia. Od prostych narzędzi wiersza poleceń (programów CLI), przez aplikacje internetowe i mikrousługi, po aplikacje desktopowe i mobilne. Kod został zaprojektowany tak, aby działał w każdym znanym silniku JavaScript (zarówno w przeglądarce, jak i NodeJS) i może być wspaniale zintegrowany z innymi frameworkami, takimi jak Angular, React i Vue.",
        "Der Anspruch hinter Deepkit Framework ist es Clean-Code, SOLID-Prinzipien, und Enterprise Design-Muster anzuwenden, um entsprechend hohe Code-Qualität nicht nur anbieten zu können, sondern dem User erlauben, diese ebenfalls anzuwenden. Auch versucht Deepkit in seiner Dokumentation und Beispielen dieselben Prinzipien zu bewerben, zwingt den Entwickler jedoch nicht, diese selbst zu verfolgen.": "Założeniem Deepkit Framework jest stosowanie czystego kodu, zasad SOLID oraz wzorców projektowych dla przedsiębiorstw, aby nie tylko zapewnić odpowiednio wysoką jakość kodu, ale także umożliwić użytkownikowi stosowanie tych zasad. Deepkit również stara się promować te same zasady w swojej dokumentacji i przykładach, ale nie zmusza programisty do ich przestrzegania.",
        "High-Performance": "Wysokowydajna strona",
        "Eines der schwierigsten Probleme in der Software-Entwicklung ist es, eine hohe Entwicklungsgeschwindigkeit auch nach Monaten oder Jahren aufrechtzuerhalten, insbesondere, wenn der Code und das Team wachsen. Es gibt viele Frameworks, die einem einen schnellen Einstieg versprechen und mit denen man in kürzester Zeit auch alleine schon komplexere Anwendungen zusammenschraubt. Diese haben jedoch meist gemeinsam das Problem, dass die Entwicklungsgeschwindigkeit drastisch abnimmt umso älter das Projekt oder umso größer das Team wird. Hierbei ist es nicht selten, das selbst nach bereits wenigen Monaten und nur einer Handvoll Entwicklern die Entwicklungsgeschwindigkeit dermaßen einbricht, dass diese auf 1 % der ursprünglichen Geschwindigkeit abfällt.": "Jednym z najtrudniejszych problemów w tworzeniu oprogramowania jest utrzymanie wysokiego tempa rozwoju nawet po miesiącach lub latach, zwłaszcza gdy kod i zespół się rozrastają. Istnieje wiele frameworków, które obiecują szybki start i dzięki którym można w krótkim czasie złożyć bardziej złożone aplikacje. Jednak ich wspólnym problemem jest to, że tempo rozwoju drastycznie spada, im starszy jest projekt lub im większy jest zespół. Nierzadko zdarza się, że już po kilku miesiącach i przy udziale zaledwie kilku programistów tempo rozwoju spada do poziomu 1% pierwotnego tempa.",
        "Um diesem Phänomen entgegenzuwirken ist es notwendig etablierte Design-Patterns anzuwenden und im Voraus das richtige Framework und Libraries zu verwenden. Enterprise Design-Patterns haben sich aus dem Grunde etabliert, da sie auch bei größeren Anwendungen und großen Teams exzellent skalieren. Korrekt angewendet entfalten sie ihre Fähigkeiten besonders dann, wenn ein Projekt über längere Zeit (mehrere Monate bis Jahre) entwickelt werden soll.": "Aby przeciwdziałać temu zjawisku, konieczne jest stosowanie ustalonych wzorców projektowych oraz wcześniejsze użycie odpowiednich frameworków i bibliotek. Wzorce projektowe dla przedsiębiorstw zyskały popularność, ponieważ doskonale skalują się nawet w przypadku większych aplikacji i dużych zespołów. Prawidłowo stosowane ujawniają swoje możliwości zwłaszcza wtedy, gdy projekt ma być realizowany w dłuższym okresie czasu (od kilku miesięcy do lat).",
        "Design-Patterns haben zwar in der Theorie ihre Vorzüge, doch gibt es in der Praxis zu fast jedem Pattern auch seine Nachteile. Diese Nachteile sind unterschiedlich je nach Sprache und Framework ausgeprägt, da die Sprache und das Framework selbst festlegt wie ergonomisch ein Pattern angewendet werden kann. Nur weil ein bestimmtes Pattern in einer Sprache angewendet werden kann, bedeutet das nicht, dass man damit auch automatisch besser und schneller entwickelt.": "Wzorce projektowe mają swoje zalety w teorii, ale w praktyce prawie każdy wzorzec ma też wady. Wady te różnią się w zależności od języka i szkieletu, ponieważ język i szkielet same w sobie decydują o tym, jak ergonomicznie można zastosować dany wzorzec. To, że dany wzorzec może być użyty w danym języku, nie oznacza, że automatycznie czyni on rozwój lepszym i szybszym.",
        "Manche Sprachen sind besser geeignet als andere, um gewisse Patterns anzuwenden. Mit JavaScript oder gar TypeScript selbst sind diverse Design-Patterns zwar oft im Kern nutzbar, doch gibt es hierbei Limitierungen, die die User-Experience und damit Schnelligkeit massiv beeinträchtigen. Zum Beispiel können Typescript-Decorators mit all seinen Eigenheiten notwendig werden, wenn ein Dependency Injection Framework dies so festlegt und darauf basiert.": "Niektóre języki są lepiej przystosowane do stosowania pewnych wzorców niż inne. W JavaScript, a nawet w samym TypeScript, można często stosować różne wzorce projektowe, ale istnieją ograniczenia, które znacznie pogarszają wrażenia użytkownika, a tym samym szybkość działania. Na przykład dekoratory Typescript ze wszystkimi ich osobliwościami mogą stać się niezbędne, jeśli framework wstrzykiwania zależności to określa i jest na nim oparty.",
        "Deepkit stellt mit dem Runtime-Typensystem sicher, dass auf maximal ergonomische Art und so wenig Boilerplate wie möglich diese Design-Patterns angewendet werden können und schaltet damit ihre Kraft erst so richtig frei, sodass die hohe Entwicklungsgeschwindigkeit nicht nur initial, sondern auch langfristig aufrechterhalten wird.": "System typów runtime Deepkit zapewnia, że te wzorce projektowe mogą być stosowane w najbardziej ergonomiczny sposób i przy użyciu jak najmniejszej ilości szablonów, co uwalnia ich potencjał do utrzymania wysokiego tempa rozwoju nie tylko na początku, ale także w dłuższej perspektywie.",
        "Isomorphic TypeScript": "Izomorficzny język TypeScript",
        "Eines der größten Vorteile von TypeScript ist es, dass komplexer Code in vielen Anwendungsfällen besser geschrieben werden kann. Das schließt Frontend, Backend, CLI tools, Mobile und Desktop-Apps, und vieles andere ein. Wenn ein Projekt diese Anwendungsfälle umfasst und fast ausschließlich auf TypeScript setzt, nennt man dies Isomorphic TypeScript. Durch das Verwenden von TypeScript in soviel Code wie möglich kann massiv an Entwicklungsgeschwindigkeit zugelegt werden. So sind folgende Vorteile dann plötzlich vorhanden:": "Jedną z największych zalet języka TypeScript jest to, że złożony kod można pisać lepiej w wielu przypadkach użycia. Obejmuje to frontend, backend, narzędzia CLI, aplikacje mobilne i desktopowe oraz wiele innych. Jeśli projekt obejmuje te przypadki użycia i opiera się prawie wyłącznie na języku TypeScript, nazywa się go izomorficznym TypeScript. Stosowanie języka TypeScript w jak największej ilości kodu może znacznie przyspieszyć proces tworzenia. Wówczas nagle pojawiają się następujące korzyści:",
        "Code kann zwischen den Abteilungen geteilt werden (Frontend, Backend, Microservice, etc).": "Kod może być współdzielony między działami (frontend, backend, mikroserwisy itp.).",
        "Models, Typen und Interfaces": "Modele, typy i interfejsy",
        "Validation": "Walidacja",
        "Business logic": "Logika biznesowa",
        "Ein einheitliches Audit-System eines einzigen Paketmanagers.": "Ujednolicony system audytu pojedynczego menedżera pakietów.",
        "Wiederverwendung von bekannten third-party Libraries in allen Abteilungen.": "Ponowne wykorzystanie znanych bibliotek innych firm we wszystkich działach.",
        "Wissensteilung innerhalb der Teams.": "Dzielenie się wiedzą w ramach zespołów.",
        "Recruitment vereinfacht sich auf eine Gruppe (und auch noch die Größte: JavaScript-Entwickler).": "Rekrutacja jest uproszczona do jednej grupy (i to największej: programistów JavaScript).",
        "Deepkit Framework und sein Runtime-Typensystem sind darauf ausgelegt diese und mehr Vorteile von Isomorphic TypeScript auf das äußerste auszunutzen, so dass seine maximale Kräfte zum Vorschein kommen.": "Deepkit Framework i jego system typów runtime zostały zaprojektowane tak, aby maksymalnie wykorzystać te i inne zalety izomorficznego TypeScriptu, pozwalając mu zabłysnąć swoimi maksymalnymi możliwościami.",
        "Alte Vorgehensweisen wie der Dual-Stack (Frontend und Backend in verschiedenen Sprachen) können hier bei weitem nicht mehr mithalten, da alleine der Kontextswitch zwischen den Sprachen bereits enorm Energie und Zeit kostet. Alle weiteren Vorteile, die bereits erläutert wurden, lässt es sogar zu einem unfairen Vergleichen werden. Ein isomorpher Techstack wie TypeScript ist, richtig angewendet, auf fundamentaler Ebene um ein vielfaches schneller in der Entwicklungszeit als jede Kombination aus einem Dual-Stack für Backend/Frontend wie Java/JavaScript, PHP/JavaScript, oder gar JavaScript/JavaScript. Da eine höhere Entwicklungsgeschwindigkeit auch bedeutet für dieselben Features weniger Zeit zu benötigen, heisst das auch, dass Isomorphic TypeScript bares Geld einspart. Neben all den bereits vorgestellten Vorteilen ist dies das Killer-Argument, um Isomorphic TypeScript in all den nächsten insbesondere kommerziellen Projekten anzuwenden.": "Stare podejścia, takie jak dual stack (frontend i backend w różnych językach), nie są już w stanie dotrzymać kroku, ponieważ samo przełączanie kontekstu między językami kosztuje już ogromną ilość energii i czasu. Wszystkie inne zalety, które zostały już wyjaśnione, sprawiają, że porównanie to jest niesprawiedliwe. Izomorficzny stos technologiczny, taki jak TypeScript, jest na podstawowym poziomie wielokrotnie szybszy w czasie tworzenia oprogramowania niż jakakolwiek kombinacja podwójnego stosu backend/frontend, takiego jak Java/JavaScript, PHP/JavaScript czy nawet JavaScript/JavaScript. Ponieważ większa szybkość opracowywania oznacza również mniej czasu potrzebnego na wykonanie tych samych funkcji, oznacza to również, że Isomorphic TypeScript pozwala zaoszczędzić pieniądze. Oprócz wszystkich przedstawionych już zalet jest to najważniejszy argument przemawiający za stosowaniem Isomorphic TypeScript we wszystkich kolejnych projektach, zwłaszcza komercyjnych.",
        "Runtime Types": "Typy w czasie rzeczywistym",
        "Typeninformationen in TypeScript zur Laufzeit zur Verfügung zu stellen ändert vieles. Es erlaubt neue Arbeitsweisen, die zuvor nur über Umwege oder gar nicht möglich waren. Das Deklarieren von Typen und Schemas ist mittlerweile ein großer Teil moderner Entwicklungsprozessen geworden. So sind GraphQL, Validatoren, ORMs, und Encoder wie zum Beispiel ProtoBuf, und viele mehr darauf angewiesen, Schema-Informationen auch zur Laufzeit zur Verfügung zu haben, um so fundamentale Funktionalitäten überhaupt erst bereitstellen zu können. Diese Tools und Libraries verlangen vom Entwickler teilweise komplett neue Sprachen zu lernen, die sehr spezifisch für den Anwendungsfall entwickelt worden sind. So haben ProtoBuf und GraphQL ihre eigene Deklarationssprache, auch Validatoren basieren oft auf eigene Schema-APIs oder gar JSON-Schema, welches ebenfalls eine eigenständige Art ist, Strukturen zu definieren. Einige davon verlangen bei jeder Änderung das Ausführen von Code-Generatoren, um die Schema-Informationen auch der Laufzeit bereitzustellen. Ein anderes bekanntes Muster ist, experimentelle TypeScript Decorators zu verwenden, um Meta-Informationen an Klassen der Laufzeit zur Verfügung zu stellen.": "Udostępnienie informacji o typie w TypeScript w czasie uruchamiania zmienia wiele rzeczy. Umożliwia to nowe sposoby pracy, które wcześniej były możliwe tylko w okrężny sposób lub wcale. Deklarowanie typów i schematów stało się istotną częścią nowoczesnych procesów programowania. GraphQL, walidatory, ORM-y, kodery takie jak ProtoBuf i wiele innych zależą od posiadania informacji o schemacie dostępnych w czasie pracy, aby zapewnić podstawową funkcjonalność. Te narzędzia i biblioteki wymagają czasem od programisty nauki zupełnie nowych języków, które zostały opracowane specjalnie dla danego przypadku użycia. Na przykład ProtoBuf i GraphQL mają swój własny język deklaracji, a walidatory często opierają się na własnych API schematów lub nawet na schemacie JSON, który również jest niezależnym sposobem definiowania struktur. Niektóre z nich wymagają uruchamiania generatorów kodu za każdym razem, gdy wprowadzana jest zmiana, aby dostarczyć informacje o schemacie również do trybu runtime. Innym znanym wzorcem jest używanie eksperymentalnych dekoratorów TypeScript do dostarczania metainformacji do klas w czasie działania.",
        "Aber ist das alles nötig? TypeScript bietet eine sehr mächtige Sprache, um auch sehr komplexe Strukturen zu beschreiben. Tatsächlich ist TypeScript mittlerweile Touring-Complete, was grob bedeutet, dass theoretisch jede Art von Program in TypeScript abbildbar ist. Natürlich hat dies seine praktischen Grenzen, der wichtige Punkt ist jedoch, dass TypeScript in der Lage ist, jegliche Deklarationsformate wie GraphQL, ProtoBuf, JSON-Schema, und viele andere komplett zu ersetzen. In Kombination mit einem Typensystem zur Laufzeit ist es möglich, all die beschriebenen Tools und deren Anwendungsfälle in TypeScript selbst ohne jeglichen Code-Generator abzudecken. Warum gibt es aber noch keine Lösung, die genau dies erlaubt?": "Ale czy to wszystko jest konieczne? TypeScript oferuje bardzo wydajny język do opisywania nawet bardzo złożonych struktur. W rzeczywistości TypeScript jest obecnie touring-complete, co w przybliżeniu oznacza, że teoretycznie każdy rodzaj programu może być odwzorowany w TypeScript. Oczywiście, ma to swoje praktyczne ograniczenia, ale ważne jest to, że TypeScript jest w stanie całkowicie zastąpić dowolny format deklaracji, taki jak GraphQL, ProtoBuf, JSON Schema i wiele innych. W połączeniu z systemem typów w czasie uruchamiania możliwe jest uwzględnienie wszystkich opisanych narzędzi i ich przypadków użycia w samym języku TypeScript, bez konieczności stosowania generatora kodu. Dlaczego jednak nadal nie ma rozwiązania, które umożliwiałoby właśnie to?",
        "Historisch gesehen ist TypeScript in den letzten Jahren einem massiven Wandel unterzogen worden. Es wurde diverse male komplett neu geschrieben, hat grundlegende Features erhalten, und unterlief eine ganze Reihe von Iterationen und Breaking-Changes. Mittlerweile ist TypeScript jedoch an einem Produkt-Market-Fit angekommen, das die Geschwindigkeit, in der grundlegende Innovationen und Breaking-Changes passieren, stark verlangsamt. TypeScript hat sich bewährt und gezeigt, wie ein äußerst charmantes Typensystem für eine hochdynamische Sprache wie JavaScript auszusehen hat. Der Markt hat diesen Vorstoß dankend angenommen und eine neue Äre in der Entwicklung mit JavaScript eingeleitet.": "W ciągu ostatnich kilku lat język TypeScript przeszedł ogromną transformację. Został on kilkakrotnie całkowicie przepisany, otrzymał podstawowe funkcje oraz przeszedł wiele iteracji i zmian. W międzyczasie TypeScript osiągnął jednak takie dopasowanie do rynku produktów, które znacznie spowalnia tempo wprowadzania fundamentalnych innowacji i przełomowych zmian. TypeScript sprawdził się i pokazał, jak powinien wyglądać bardzo uroczy system typów dla bardzo dynamicznego języka, jakim jest JavaScript. Rynek z wdzięcznością przyjął ten postęp i zapoczątkował nową erę w rozwoju JavaScript.",
        "Genau dann ist der richtige Zeitpunkt gekommen, Tools auf der Sprache selbst in fundamentaler Ebene aufzusetzen, um so das oben beschriebene möglich zu machen. Deepkit möchte der Anstoß sein, um über jahrzehnte bewährte Design-Muster aus dem Enterprise von Sprachen wie Java und PHP nicht nur fundamental zu TypeScript zu bringen, sondern in einer neuen und besseren Art, die nicht gegen, sondern mit JavaScript arbeitet. Durch Typeninformationen zur Laufzeit sind diese nun zum ersten Mal nicht nur prinzipiell möglich, sondern erlauben ganz neue viel einfacherer Design-Muster, die mit Sprachen wie Java und PHP nicht möglich sind. TypeScript selbst hat hier das Fundament gelegt, um mit ganz neue Ansätzen in starker Kombination mit Bewährtem dem Entwickler das Leben beträchtlich zu vereinfachen.": "To jest właśnie dobry moment, aby na poziomie podstawowym zbudować narzędzia na bazie samego języka, które umożliwią realizację powyższych założeń. Deepkit chce być impulsem do przeniesienia sprawdzonych przez dziesięciolecia wzorców projektowych z takich języków jak Java i PHP nie tylko zasadniczo do TypeScript, ale w nowy i lepszy sposób, który działa nie przeciwko, ale z JavaScriptem. Dzięki informacji o typie w czasie wykonywania, po raz pierwszy są one nie tylko zasadniczo możliwe, ale także umożliwiają tworzenie zupełnie nowych, znacznie prostszych wzorców projektowych, które nie są możliwe w językach takich jak Java czy PHP. Sam język TypeScript położył tutaj fundamenty pod znaczne ułatwienie życia programisty dzięki zupełnie nowym podejściom w połączeniu ze sprawdzonymi rozwiązaniami.",
        "Typeninformationen zur Laufzeit auszulesen ist die Fähigkeit auf die Deepkit in seinem Fundament aufsetzt. Die API der Deepkit Libraries sind maßgeblich darauf ausgerichtet, soviel TypeScript Typeninformation wie möglich zu verwenden, um so effizient wie möglich zu sein. Typensystem zur Laufzeit bedeutet, dass Typeninformationen zu Laufzeit auslesbar und dynamische Typen berechenbar sind. Das heisst, dass zum Beispiel bei Klassen alle Eigenschaften und bei Funktionen alle Parameter und Return-Typen ausgelesen werden können.": "Odczytywanie informacji o typie w czasie wykonywania aplikacji to umiejętność, na której Deepkit buduje swoje podstawy. Interfejs API bibliotek Deepkit jest w dużej mierze ukierunkowany na wykorzystanie jak największej ilości informacji o typach w języku TypeScript w celu uzyskania jak największej wydajności. System typów w czasie wykonywania oznacza, że informacja o typie jest czytelna w czasie wykonywania, a typy dynamiczne są obliczalne. Oznacza to na przykład, że można odczytywać wszystkie właściwości klas oraz wszystkie parametry i typy zwrotne funkcji.",
        "Nehmen wir als Beispiel diese Funktion:": "Weźmy na przykład tę funkcję:",
        "In JavaScript selbst können mehrere Informationen zu Laufzeit ausgelesen werden. Zum Beispiel der Name der Funktion (sofern nicht mit einem Minimizer abgeändert wurde):": "W samym języku JavaScript można odczytać kilka informacji w czasie wykonywania. Na przykład nazwa funkcji (jeśli nie została zmieniona za pomocą minimalizatora):",
        "Zum anderen kann die Anzahl der Parameter ausgelesen werden:": "Z drugiej strony, można odczytać liczbę parametrów:",
        "Mit ein bisschen mehr Code kann auch ausgelesen werden, wie die Parameter heissen. Das ist jedoch ohne einen rudimentären JavaScript-Parser oder RegExp auf log.toString() nicht ohne weiteres zu bewerkstelligen, sodass ab hier schon schluss ist. Da TypeScript die obige Funktion wie folgt in JavaScript übersetzt:": "Przy użyciu nieco większej ilości kodu można również odczytać nazwy parametrów. Jednak nie da się tego zrobić bez podstawowego parsera JavaScript lub RegExp na log.toString(), więc na tym koniec. Ponieważ TypeScript tłumaczy powyższą funkcję na język JavaScript w następujący sposób:",
        "sind die Informationen, dass `message` vom Typ string und der Return-Typ vom Type `void` ist nicht mehr verfügbar. Diese Informationen wurden unwiderruflich von TypeScript zerstört.": "informacja, że `message` jest typu string, a typ zwracany jest typu `void`, nie jest już dostępna. Informacje te zostały nieodwracalnie zniszczone przez język TypeScript.",
        "Mit einem Typensystem zur Laufzeit können jedoch diese Informationen überleben, so dass man die Typen von message und den Return-Typ programmatisch auslesen kann.": "Jednak dzięki systemowi typów w czasie wykonywania programu informacje te mogą zostać zachowane, dzięki czemu typy komunikatów i typ zwracany można odczytać programowo.",
        "Deepkit macht genau das möglich. Es hängt sich in die Kompilierung von TypeScript ein und stellt sicher, dass alle Typeninformationen in dem generierten JavaScript eingebaut sind. Funktionen wie typeOf() (nicht zu verwechseln mit dem operator typeof, mit kleinem o) erlauben dem Entwickler dann darauf zuzugreifen. Es können daher auch Libraries entwickelt werden, die auf diesen Typeninformationen basieren und so dem Entwickler es erlauben, bereits geschriebene TypeScript Typen für eine ganze Palette von Anwendungsmöglichkeiten zu verwenden.": "Deepkit właśnie to umożliwia. Podłącza się on do kompilacji TypeScript i zapewnia, że wszystkie informacje o typie są wbudowane w generowany JavaScript. Funkcje takie jak typeOf() (nie mylić z operatorem typeof, z małą literą o) umożliwiają programiście dostęp do tych danych. Można zatem tworzyć biblioteki oparte na tych informacjach o typach, co pozwala programiście wykorzystać już napisane typy TypeScript do wielu różnych zastosowań.",
        "Installation": "Instalacja",
        "Um Deepkit's Runtime Typessystem zu installieren werden zwei Pakete benötigt. Der Typen-Compiler in `@deepkit/type-compiler` und die dazu nötige Runtime in `@deepkit/type`. Der Typen-Compiler kann dabei in `package.json` _devDependencies_ installiert werden, da er nur zur Build-Zeit benötigt wird.": "Aby zainstalować system typu runtime Deepkit, potrzebne są dwa pakiety. Kompilator typów w `@deepkit/type-compiler` oraz niezbędny runtime w `@deepkit/type`. Kompilator typów można zainstalować w pliku `package.json` _devDependencies_, ponieważ jest on potrzebny tylko w czasie kompilacji.",
        "Laufzeit Typeninformationen werden standardmäßig nicht generiert. Es muss `\"reflection\": true` in der Datei `tsconfig.json` gesetzt werden, um es in allen Dateien im gleichen Ordner dieser Datei oder in allen Unterordnern zu aktivieren. Wenn Decorators verwenden werden sollen, muss `\"experimentalDecorators\": true` in der `tsconfig.json` aktiviert werden. Dies ist nicht unbedingt erforderlich, um mit `@deepkit/type` zu arbeiten, aber für bestimmte Funktionen anderen Deepkit Libraries und in `@deepkit/framework` notwendig.": "Informacje o typie Runtime Type nie są domyślnie generowane. Musi być ustawiona `\"reflection\": true` w pliku `tsconfig.json`, aby włączyć ją we wszystkich plikach w tym samym folderze tego pliku lub we wszystkich podfolderach. Jeśli mają być używane dekoratory, `\"experimentalDecorators\": true` musi być włączone w pliku `tsconfig.json`. Nie jest to ściśle niezbędne do pracy z `@deepkit/type`, ale jest konieczne dla pewnych funkcji innych bibliotek deepkit oraz w `@deepkit/framework`.",
        "_Datei: tsconfig.json_": "Plik: tsconfig.json_",
        "Type compiler": "Kompilator typów",
        "TypeScript selbst erlaubt es nicht, den Typen-Compiler über eine `tsconfig.json` zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt oder ein Build-System wie Webpack mit _ts-loader_ zu benutzen. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird (dies geschieht über NPM install hooks).": "Sam TypeScript nie pozwala na konfigurowanie kompilatora typów za pomocą pliku `tsconfig.json`. Konieczne jest albo bezpośrednie użycie API kompilatora TypeScript, albo systemu budowania, takiego jak Webpack z _ts-loader_. Aby uniknąć tej niedogodności dla użytkowników Deepkit, kompilator typów Deepkit automatycznie instaluje się w `node_modules/typescript`, gdy zainstalowany jest `@deepkit/type-compiler` (odbywa się to za pomocą haków instalacyjnych NPM).",
        "Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert _tsc_, Angular, webpack, _ts-node_, und einige andere Tools automatisch mit dem Deepkit Typen-Compiler.": "Dzięki temu wszystkie narzędzia budujące, które mają dostęp do lokalnie zainstalowanego TypeScriptu (tego w `node_modules/typescript`), będą miały automatycznie włączony kompilator typów. Dzięki temu _tsc_, Angular, webpack, _ts-node_ i niektóre inne narzędzia automatycznie współpracują z kompilatorem typów Deepkit.",
        "Falls der Typen-Compiler nicht erfolgreich automatisch installiert werden konnte (weil zum Beispiel NPM install hooks deaktiviert sind), kann dies manuell mit folgendem Kommando nachgeholt werden:": "Jeśli kompilator typów nie mógł zostać zainstalowany automatycznie (na przykład dlatego, że haki instalacyjne NPM są wyłączone), można to zrobić ręcznie za pomocą następującego polecenia:",
        "Beachten Sie, dass `deepkit-type-install` ausführt werden muss, wenn die lokale Typescript-Version aktualisiert wurde (zum Beispiel, wenn sich die Typescript-Version in package.json geändert hat und `npm install` ausgeführt wird).": "Zauważ, że `deepkit-type-install` musi być wykonany, jeśli lokalna wersja typescript została zaktualizowana (na przykład, jeśli wersja typescript w package.json zmieniła się i `npm install` został wykonany).",
        "Webpack": "Webpack",
        "Wenn der Typen-Compiler in einem Webpack-Build verwenden werden solle, kann dies mit dem Paket `ts-loader` (oder jedem anderen Typescript-Loader, der die Registrierung von Transformatoren unterstützt) tun.": "Jeśli kompilator typów ma być użyty w kompilacji webpacka, można to zrobić za pomocą pakietu `ts-loader` (lub dowolnego innego, który obsługuje rejestrację transformatorów).",
        "_Datei: webpack.config.js_": "Plik: webpack.config.js_",
        "Typen-Decorators": "Dekoratorzy typu",
        "Typen-Decorators sind normale TypeScript-Typen, die Meta-Informationen beinhalten, um zur Laufzeit das Verhalten diverser Funktionen zu verändern. Deepkit liefert bereits einige Typen-Decorators mit, die einige Anwendungsfälle abdecken. So kann zum Beispiel eine Klassen-Eigenschaft als Primary-Key, als Referenz, oder Index markiert werden. Die Datenbank Library kann diese Information zur Laufzeit nutzen, um so die korrekten SQL Queries ohne vorherige Code-Generation zu erstellen.": "Dekoratory typów to zwykłe typy TypeScript, które zawierają metainformacje umożliwiające zmianę zachowania różnych funkcji w czasie wykonywania. Deepkit udostępnia już pewne dekoratory typów, które obejmują niektóre przypadki użycia. Na przykład właściwość klasy może być oznaczona jako klucz główny, referencja lub indeks. Biblioteka bazy danych może wykorzystać te informacje w czasie pracy, aby utworzyć poprawne zapytania SQL bez wcześniejszego generowania kodu.",
        "Es können auch Validator-Einschränkungen wie zum Beispiel `MaxLength`, `Maximum`, oder `Positive` an einen beliebigen Typen hinzugefügt werden. Auch kann dem Serializer mitgeteilt werden, wie ein bestimmter Wert zu serialisieren bzw deserialisieren ist. Zusätzlich ist es möglich, komplett eigene Type-Decorators zu erstellen und zur Laufzeit auszulesen, um so sehr individuell das Typensystem zur Laufzeit zu verwenden.": "Do każdego typu można także dodać ograniczenia walidatora, takie jak `MaxLength`, `Maximum` czy `Positive`. Można również powiedzieć serializatorowi, w jaki sposób ma serializować lub deserializować określoną wartość. Ponadto możliwe jest tworzenie całkowicie niestandardowych dekoratorów typów i odczytywanie ich w czasie wykonywania, co pozwala na bardzo indywidualne korzystanie z systemu typów w czasie wykonywania.",
        "Deepkit kommt mit einer ganzen Reihe von Typen-Decorators, die alle direkt aus `@deepkit/type` benutzt werden können. Sie sind designt, nicht aus mehreren Libraries zu kommen, um so Code nicht direkt an eine bestimmte Library wie zum Beispiel Deepkit RPC oder Deepkit Database zu koppeln. Das erlaubt das einfachere Wiederverwenden von Typen, auch im Frontend, obwohl zum Beispiel Datenbank Typen-Decorators genutzt werden.": "Deepkit posiada cały zestaw dekoratorów typów, z których wszystkie mogą być używane bezpośrednio z `@deepkit/type`. Zostały one zaprojektowane tak, aby nie pochodziły z wielu bibliotek, aby nie wiązać kodu bezpośrednio z konkretną biblioteką, taką jak Deepkit RPC czy Deepkit Database. Pozwala to na łatwiejsze ponowne wykorzystanie typów, nawet we frontendzie, mimo że używane są na przykład dekoratory typów baz danych.",
        "Folgend ist eine Liste von vorhandenen Type-Decorators. Der Validator und Serializer von `@deepkit/type` und `@deepkit/bson` sowie Deepkit Database von `@deepkit/orm` nutzten diese Informationen unterschiedlich. Siehe die entsprechenden Kapitel, um mehr darüber zu erfahren.": "Poniżej znajduje się lista istniejących dekoratorów typów. Walidator i serializator `@deepkit/type` i `@deepkit/bson` oraz baza danych Deepkit z `@deepkit/orm` używały tej informacji w różny sposób. Więcej informacji na ten temat można znaleźć w odpowiednich rozdziałach.",
        "Integer/Float": "Integer/Float",
        "Integer und Floats sind als Basis als `number` definiert und hat mehrere Untervarianten:": "Liczby całkowite i zmiennoprzecinkowe są zdefiniowane jako `number` i mają kilka podwariantów:",
        "Hier ist zur Laufzeit die `id` des Users eine Number, wird jedoch in der Validierung und Serialisierung als Integer interpretiert.": "W tym przypadku `id` użytkownika jest liczbą w czasie pracy, ale jest interpretowany jako liczba całkowita podczas sprawdzania poprawności i serializacji.",
        "Das heisst, dass hier zum Beispiel keine Floats in Validation genutzt werden dürfen und der Serializer Floats automatisch in Integer umwandeln.": "Oznacza to, że na przykład w walidacji nie można używać liczb zmiennoprzecinkowych, a serializator automatycznie konwertuje liczby zmiennoprzecinkowe na całkowite.",
        "Die Untertypen können genauso benutzt werden und sind sinnvoll, wenn ein bestimmter Nummernbereich erlaubt werden soll.": "Podtypy mogą być używane w ten sam sposób i są przydatne, jeśli ma być dozwolony pewien zakres liczb.",
        "Float": "Float",
        "UUID": "UUID",
        "UUID v4 wird in der Datenbank in der Regel als Binary abgespeichert und in JSON als String.": "UUID v4 jest zwykle przechowywany w bazie danych jako liczba binarna, a w JSON jako ciąg znaków.",
        "MongoID": "MongoID",
        "Marks this field as ObjectId for MongoDB. Resolves as a string. Is stored in the MongoDB as binary.": "Oznacza to pole jako ObjectId dla MongoDB. Rozwiązuje się jako ciąg znaków. Jest przechowywany w MongoDB w postaci binarnej.",
        "Bigint": "Bigint",
        "Per default the normal bigint type serializes as number in JSON (and long in BSON). This has however limitation in what is possible to save as bigint in JavaScript has a unlimited potential size, where numbers in JavaScript and long in BSON are limited. To bypass this limitation the BinaryBigInt is available.": "Domyślnie zwykły typ bigint serializuje się jako number w JSON (i long w BSON). Ma to jednak ograniczenia w tym, co można zapisać, ponieważ bigint w JavaScript ma nieograniczony potencjalny rozmiar, podczas gdy liczby w JavaScript i long w BSON są ograniczone. Aby obejść to ograniczenie, można skorzystać z funkcji BinaryBigInt.",
        "Same as bigint but serializes to unsigned binary with unlimited size (instead of 8 bytes in most databases) in databases and string in JSON. Negative values will be converted to positive (abs(x)).": "To samo co bigint, ale serializuje się do unsigned binary o nieograniczonym rozmiarze (zamiast 8 bajtów w większości baz danych) w bazach danych i do łańcucha w JSON. Wartości ujemne zostaną zamienione na dodatnie (abs(x)).",
        "Deepkit ORM stores BinaryBigInt as a binary field.": "Deepkit ORM przechowuje BinaryBigInt jako pole binarne.",
        "`SignedBinaryBigInt` is the same as BinaryBigInt but is able to store negative values as well.": "SignedBinaryBigInt\" jest taki sam jak \"BinaryBigInt\", ale może również przechowywać wartości ujemne.",
        "Deepkit ORM stores SignedBinaryBigInt as binary. The binary has an additional leading sign byte and is represented as an uint: 255 for negative, 0 for zero, or 1 for positive.": "Deepkit ORM przechowuje SignedBinaryBigInt w postaci binarnej. Liczba binarna ma dodatkowy bajt ze znakiem wiodącym i jest reprezentowana jako liczba uint: 255 dla wartości ujemnej, 0 dla zera lub 1 dla wartości dodatniej.",
        "MapName": "MapName",
        "To change the name of a property in the serialization.": "Aby zmienić nazwę właściwości w serializacji.",
        "Group": "Grupa",
        "Properties can be grouped together. For serialization you can for example exclude a group from serialization. See the chapter Serialization for more information.": "Właściwości można łączyć w grupy. W przypadku serializacji można na przykład wykluczyć grupę z serializacji. Więcej informacji na ten temat można znaleźć w rozdziale Serializacja.",
        "Data": "Dane",
        "Each property can add additional meta-data that can be read via the Reflection API. See <<runtime-types-reflection>> for more information.": "Każda właściwość może zawierać dodatkowe metadane, które można odczytać za pomocą interfejsu API Reflection. Zobacz <<runtime-types-reflection>>, aby uzyskać więcej informacji.",
        "Excluded": "Wyłączone",
        "Each property can be excluded from the serialization process for a specific target.": "Każdą właściwość można wykluczyć z procesu serializacji dla określonego celu.",
        "Embedded": "Wbudowana strona",
        "Marks the field as an embedded type.": "Oznacza pole jako typ wbudowany.",
        "It's possible to change the prefix (which is per default the property name).": "Istnieje możliwość zmiany prefiksu (który domyślnie jest nazwą właściwości).",
        "Entity": "Podmiot",
        "To annotate interfaces with entity information. Only used in the database context.": "Aby nadać interfejsom adnotacje z informacjami o encji. Używane tylko w kontekście bazy danych.",
        "InlineRuntimeType": "InlineRuntimeType",
        "TODO": "TODO",
        "ResetDecorator": "ResetDecorator",
        "Database": "Baza danych",
        "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.": "TODO: PrimaryKey, AutoIncrement, Reference, BackReference, Index, Unique, DatabaseField.",
        "Siehe dazu Kapitel Validation <<validation-constraint-types>>.": "Patrz rozdział Walidacja <<validation-constraint-types>>.",
        "Benutzerdefinierte Type-Decorators": "Dekoratorzy typów niestandardowych",
        "Ein Typen-Decorator kann wie folgt definiert werden:": "Dekorator typu można zdefiniować w następujący sposób:",
        "Als Konvention ist definiert, dass ein Typen-Decorator ein Object-Literal mit einem einzigen optionalen Property `__meta` ist, das ein Tuple als Typ hat. Der erste Eintrag in diesem Tuple ist sein eindeutiger Name und alle weiteren Tuple Einträge beliebige Optionen. So kann ein Typen-Decorator mit zusätzlichen Optionen ausgestattet werden.": "Zwyczajowo dekorator typu jest definiowany jako literał obiektu z pojedynczą opcjonalną właściwością `__meta`, której typem jest tuple. Pierwszy wpis w tej krotce jest jej unikalną nazwą, a wszystkie kolejne wpisy w krotce są dowolnymi opcjami. W ten sposób dekorator typu można wyposażyć w dodatkowe opcje.",
        "Genutzt wird der Typen-Decorator mit dem Intersection-Operator `&`. Es können beliebig viele Typen-Decorators an einem Typen genutzt werden.": "Dekorator typu jest używany z operatorem przecięcia `&`. Na jednym typie można zastosować dowolną liczbę dekoratorów typu.",
        "Ausgelesen können die Typen-Decorators über die Typen-Objekte von `typeOf<T>()` und `metaAnnotation`:": "Dekoratory typu można odczytać za pomocą obiektów typu `typeOf<T>()` i `metaAnnotation`:",
        "Das Resultat in `annotation` ist entweder ein Array mit Optionen, wenn der Typen-Decorator `myAnnotation` genutzt wurde oder `undefined` wenn nicht. Hat der Typen-Decorator zusätzliche Optionen wie in `AnnotationOption` zu sehen, sind die übergebenen Werte in dem Array zu finden.": "Wynik w `annotation` jest albo tablicą opcji, jeśli użyto dekoratora typu `myAnnotation`, albo `undefined`, jeśli nie. Jeśli dekorator typu ma dodatkowe opcje widoczne w `AnnotationOption`, przekazane wartości należy umieścić w tablicy.",
        "Bereits mitgelieferte Typen-Decorators wie `MapName`, `Group`, `Data`, etc haben ihre eigenen Annotation-Objekt:": "Dostarczone już dekoratory typu, takie jak `MapName`, `Group`, `Data` itp. mają swoje własne obiekty adnotacji:",
        "Siehe das Kapitel <<runtime-types-reflection>>, um mehr darüber zu erfahren.": "Aby dowiedzieć się więcej na ten temat, zobacz rozdział <<runtime-types-reflection>>.",
        "External Classes": "Klasy zewnętrzne",
        "Since TypeScript does not include type information per default, imported types/classes from other packages (that did not use @deepkit/type-compiler) will not have type information available.": "Ponieważ TypeScript domyślnie nie zawiera informacji o typie, typy/klasy importowane z innych pakietów (które nie użyły @deepkit/type-compiler) nie będą miały dostępnych informacji o typie.",
        "To annotate types for an external class, use `annotateClass` and make sure this function is executed in the bootstrap phase of your application before the imported class is used somewhere else.": "Aby przypisać typy do zewnętrznej klasy, należy użyć `annotateClass` i upewnić się, że funkcja ta jest wykonywana w fazie bootstrap aplikacji, zanim zaimportowana klasa zostanie użyta gdzie indziej.",
        "`MyExternalClass` can now be used in serialization functions and in the reflection API.": "Klasa MyExternalClass` może być teraz używana w funkcjach serializacji oraz w interfejsie API refleksji.",
        "To following shows how to annotate generic classes:": "Poniżej przedstawiono sposób tworzenia adnotacji do klas generycznych:",
        "Reflection": "Odbicie",
        "Um mit den Typeninformationen selbst direkt zu arbeiten, gibt es dabei zwei grundlegende Varianten: Type-Objekte und Reflection-Klassen. Die Reflection-Klassen werden weiter unten behandelt. Die Funktion `typeOf` gibt Typen-Objekte zurück, die ganz simple object literals sind. Es beinhaltet immer ein `kind` welches eine Nummer ist und mittels dem Enum `ReflectionKind` seine Bedeutung erlangt. `ReflectionKind` ist in dem Paket `@deepkit/type` wie folgt definiert:": "W celu bezpośredniej pracy z informacjami o typie istnieją dwa podstawowe warianty: Obiekty typu i klasy Reflection. Klasy refleksji zostały omówione poniżej. Funkcja `typeOf` zwraca obiekty typu, które są bardzo prostymi literałami obiektów. Zawsze zawiera on `kind`, który jest liczbą i otrzymuje swoje znaczenie za pomocą enum `ReflectionKind`. Klasa `ReflectionKind` jest zdefiniowana w pakiecie `@deepkit/type` w następujący sposób:",
        "Es gibt eine ganze Reihe von möglichen Typen-Objekten, die zurückgegeben werden können. Die einfachsten sind dabei `never`, `any`, `unknown`, `void, null,` und `undefined`, welche wie folgt dargestellt werden:": "Istnieje wiele możliwych typów obiektów, które mogą zostać zwrócone. Najprostsze z nich to `never`, `any`, `unknown`, `void, null,` i `undefined`, które są reprezentowane w następujący sposób:",
        "Die Nummer 0 zum Beispiel ist der erste Eintrag des `ReflectionKind` Enums, in diesem Fall `never`, die Nummer 1 der zweite Eintrag, hier `any`, und so weiter. Entsprechend sind primitive Typen wie `string`, `number`, `boolean` wie folgt dargestellt:": "Na przykład numer 0 jest pierwszym wpisem enum `ReflectionKind`, w tym przypadku `never`, numer 1 jest drugim wpisem, tutaj `any`, i tak dalej. Odpowiednio, typy prymitywne takie jak `string`, `number`, `boolean` są reprezentowane w następujący sposób:",
        "Diese recht simplen Typen haben keine weiteren Informationen an dem Typen-Objekt, da sie direkt als Typen-Argument zu `typeOf` übergeben wurden. Werden jedoch Typen über Typen-Aliase übergeben, sind zusätzliche Informationen an dem Typen-Objekt zu finden.": "Te dość proste typy nie mają żadnych dalszych informacji o obiekcie typu, ponieważ zostały przekazane bezpośrednio jako argument typu do `typeOf`. Jeśli jednak typy są przekazywane za pomocą aliasów typów, dodatkowe informacje można znaleźć w obiekcie typu.",
        "In diesem Fall ist der Name des Type-Alias `Title` ebenfalls vorhanden. Ist ein Type-Alias ein Generic, werden die übergebenen Typen ebenfalls an dem Typen-Objekt verfügbar.": "W tym przypadku dostępna jest również nazwa aliasu typu `Title`. Jeśli alias typu jest generyczny, przekazane typy stają się również dostępne w obiekcie typu.",
        "Ist der übergebene Type das Ergebnis eines Index-Access Operators, ist der Container und der Index-Type vorhanden:": "Jeśli przekazany typ jest wynikiem działania operatora dostępu do indeksu, to kontener i typ indeksu są obecne:",
        "Interfaces und Object-Literals sind beide als Reflection.objectLiteral ausgegeben und beinhalten die Properties und Methoden in dem `types` array.": "Interfejsy i obiekty literalne są wyprowadzane jako Reflection.objectLiteral i zawierają właściwości i metody w tablicy `types`.",
        "Index Signatures sind ebenfalls in dem `types` array.": "Sygnatury indeksów znajdują się również w tablicy `types`.",
        "Klassen sind ähnliche zu Object Literals und haben ihre Properties und Methods ebenfalls unter einem `types` array zusätzlich zu `classType` welches eine Referenz auf die Klasse selbst ist.": "Klasy są podobne do literałów obiektów i również posiadają swoje właściwości i metody w tablicy `types`, oprócz `classType`, która jest referencją do samej klasy.",
        "Beachte, dass der Type von Reflection.propertySignature zu Reflection.property und Reflection.methodSignature zu Reflection.method geändert wurde. Da Properties und Methoden an Klassen zusätzliche Attribute aufweisen, sind diese Informationen ebenfalls abrufbar. Letztere beinhalten zusätzlich `visibility`, `abstract`, und `default`.": "Zwróć uwagę, że typ Reflection.propertySignature został zmieniony na Reflection.property, a Reflection.methodSignature na Reflection.method. Ponieważ właściwości i metody klas mają dodatkowe atrybuty, informacje te można również pobierać. Te ostatnie zawierają dodatkowo `visibility`, `abstract` i `default`.",
        "Typen-Objekte von Klassen beinhalten nur die Properties und Methoden der Klasse selbst und nicht der Super-Klassen. Das ist konträr zu Typen-Objekten von interfaces/object-literals, welche alle property signatures und method signatures aller Elternteile aufgelöst in `types` haben. Um die Property und Methoden der Super-Klassen aufzulösen, kann entweder ReflectionClass und dessen `ReflectionClass.getProperties()` (siehe nachfolgende Abschnitte) oder `resolveTypeMembers()` von `@deepkit/type` genutzt werden.": "Obiekty typu klasy zawierają tylko właściwości i metody samej klasy, a nie jej nadklas. Jest to przeciwieństwo obiektów typu interfejsów/obiektów-literałów, które mają wszystkie sygnatury właściwości i sygnatury metod wszystkich rodziców rozwiązane w `typach`. Aby rozwiązać właściwości i metody nadklas, można użyć albo ReflectionClass i jego `ReflectionClass.getProperties()` (zobacz następne sekcje) albo `resolveTypeMembers()` z `@deepkit/type`.",
        "Es gibt eine ganze Hülle und Fülle von Typen-Objekten. So zum Beispiel für literal, template literals, promise, enum, union, array, tuple, und viele mehr. Um herauszufinden, welche es alle gibt und welche Informationen bereitstehen, empfiehlt es sich `Type` von `@deepkit/type` zu importieren. Es ist ein `union` mit allen Möglichen Subtypes wie z.b. TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass, und viele mehr. Dort ist dann die genaue Struktur zu finden.": "Istnieje cała gama obiektów typu. Na przykład literał, literał szablonu, obietnica, enum, unia, tablica, tuple i wiele innych. Aby dowiedzieć się, które z nich istnieją i jakie informacje są dostępne, zaleca się zaimportowanie `Type` z `@deepkit/type`. Jest to `union` ze wszystkimi możliwymi podtypami, takimi jak TypeAny, TypeUnknonwn, TypeVoid, TypeString, TypeNumber, TypeObjectLiteral, TypeArray, TypeClass i wiele innych. Tam też można znaleźć dokładną strukturę.",
        "Type Cache": "Typ Pamięć podręczna",
        "Type-Objekte sind für Type-Aliase, Funktionen, und Klassen gecached sobald keine Generic-Argument übergeben ist. Das heisst konkret, dass ein Aufruf zu `typeOf<MyClass>()` immer das selbe Objekt zurückgibt.": "Obiekty typu są buforowane dla aliasów typów, funkcji i klas, gdy tylko nie zostanie przekazany żaden argument generyczny. Oznacza to, że wywołanie funkcji `typeOf<MyClass>()` zawsze zwraca ten sam obiekt.",
        "Sobald jedoch eine Generic-Type benutzt wird, werden immer neue Objekte erzeugt, selbst wenn der übergebene Typen immer dasselbe ist. Das ist so, da theoretisch unendlich viele Kombinationen möglich sind und so ein Cache effektiv ein Memory-Leak darstellen würde.": "Jednak gdy tylko zostanie użyty typ generyczny, zawsze tworzone są nowe obiekty, nawet jeśli przekazywany typ jest zawsze taki sam. Dzieje się tak dlatego, że teoretycznie możliwa jest nieskończona liczba kombinacji, a taka pamięć podręczna stanowiłaby w praktyce wyciek pamięci.",
        "Sobald ein Typ jedoch in einen rekursiven Typen mehrfach instantiiert wird, ist dieser gecacht. Die Dauer des Cache ist allerdings nur auf den Moment der Berechnung des Types limitiert und ist danach nicht mehr existent. Auch ist zwar das Type-Objekt gecacht, doch wird eine neue Referenz zurückgegeben und ist nicht das exakt selbe Objekt.": "Jednak gdy tylko typ jest instancjonowany kilka razy w typie rekurencyjnym, jest on buforowany. Jednak czas trwania pamięci podręcznej jest ograniczony tylko do momentu obliczenia typu, a później już nie istnieje. Ponadto, mimo że obiekt typu jest buforowany, zwracana jest nowa referencja, która nie jest dokładnie tym samym obiektem.",
        "`MyType<string>` ist gecacht solange `Object` berechnet wird. Die PropertySignature von `a` und `b` haben dadurch zwar denselben `type` aus dem Cache, sind jedoch nicht dasselbe Type-Objekt.": "MyType<string>` jest buforowany tak długo, jak długo obliczany jest `Object`. PropertySignature `a` i `b` mają więc ten sam `typ` z pamięci podręcznej, ale nie są tym samym obiektem Type.",
        "Alle nicht-root Type-Objekte haben eine parent Eigenschaft, welche in der Regel auf den umschließenden Elternteil zeigen. Dies ist wertvoll, um zum Beispiel herauszufinden, ob ein Type bestandteil eines union ist oder nicht.": "Wszystkie obiekty typu niebędące typami głównymi mają właściwość parent, która zwykle wskazuje na otaczającego rodzica. Jest to przydatne na przykład w celu sprawdzenia, czy dany typ jest częścią unii, czy nie.",
        "`Ref 1` zeigt dabei auf das eigentliche union Type-Objekt.": "Ref 1\" wskazuje na rzeczywisty obiekt typu unii.",
        "Bei zwischengespeicherten Type-Objekten wie oben exemplarisch aufgezeigt, sind die `parent` Eigenschaften nicht immer die echten Elternteile. So zum Beispiel bei einer Klasse, die mehrfach genutzt wird, zeigen zwar unmittelbaren Typen in `types` (TypePropertySignature und TypeMethodSignature) auf das korrekte TypeClass, aber die `type` dieser Signature-Typen zeigen auf die Signature-Typen des TypeClass des Cache-Eintrages. Das ist wichtig zu wissen, um so nicht unendlich die parent-Struktur auszulesen, sondern nur der unmittelbare Elternteil. Die Tatsache, dass der parent nicht unendliche Genauigkeit hat, ist Performance-Gründen geschuldet.": "W przypadku obiektów typu buforowanego, jak pokazano na powyższym przykładzie, właściwości `parent` nie zawsze są prawdziwymi rodzicami. Na przykład w przypadku klasy, która jest używana wielokrotnie, mimo że typy bezpośrednie w `types` (TypePropertySignature i TypeMethodSignature) wskazują na właściwą klasę TypeClass, to `type` tych typów sygnatur wskazuje na typy sygnatur klasy TypeClass buforowanego wpisu. Warto o tym wiedzieć, aby nie odczytywać w nieskończoność struktury nadrzędnej, lecz tylko bezpośrednią strukturę nadrzędną. Fakt, że rodzic nie ma nieskończonej precyzji, wynika z przyczyn wydajnościowych.",
        "JIT Cache": "Pamięć podręczna JIT",
        "Im weiteren Verlauf werden einige Funktionen und Features beschrieben, die oft auf die Type-Objekte basieren. Um einige davon performant umzusetzen, braucht es einen JIT-Cache (just in time) pro Type-Objekt. Die kann via `getJitContainer(type)` bereitgestellt werden. Diese Funktion gibt ein simples Objekt zurück, auf den beliebig Daten gespeichert werden können. Solange keine Referenz auf das Objekt gehalten wird, löscht es sich automatisch durch den GC sobald das Type-Objekt selbst auch nicht mehr referenziert wird.": "W dalszej części opisano niektóre funkcje i właściwości, które często bazują na obiektach typu. Aby zaimplementować niektóre z nich w sposób wydajny, potrzebna jest pamięć podręczna JIT (just in time) dla każdego typu obiektu. Można to zrobić za pomocą polecenia `getJitContainer(type)`. Ta funkcja zwraca prosty obiekt, na którym można zapisać dowolne dane. Dopóki nie jest przechowywana żadna referencja do tego obiektu, jest on automatycznie usuwany przez GC, gdy tylko obiekt typu przestanie być obiektem odniesienia.",
        "Reflection-Klassen": "Klasy refleksji",
        "Zusätzlich zu der `typeOf<>()` Funktion gibt es diverse Reflection-Klassen, die eine OOP-Alternative zu den Type-Objekten bieten. Die Reflection-Klassen sind nur für Klassen, Interface/Object-literale und Funktionen und deren direkte Unter-Typen (Properties, Methods, Parameter) vorhanden. Alle tieferen Typen müssen wieder mit den Type-Objekten ausgelesen werden.": "Oprócz funkcji `typeOf<>()` istnieją różne klasy refleksji, które stanowią alternatywę OOP dla obiektów typu. Klasy refleksji są dostępne tylko dla klas, literałów interfejsów/obiektów i funkcji oraz ich bezpośrednich podtypów (właściwości, metod, parametrów). Wszystkie głębsze typy muszą być ponownie odczytane za pomocą obiektów typu.",
        "Typeninformation empfangen": "Informacje o typie odbiornika",
        "Um selbst Funktionen bereitzustellen, die auf Typen operieren, kann es nützlich sein, dem User anzubieten, einen Typen manuell zu übergeben. Zum Beispiel könnte bei einer Validierungsfunktion es sinnvoll sein, als ersten Type-Argument den zu wünschenden Typen bereitzustellen und als erstes Funktionsargument die zu validierende Daten.": "W celu zapewnienia funkcji operujących na typach przydatne może być zaoferowanie użytkownikowi ręcznego podania typu. Na przykład w funkcji sprawdzania poprawności przydatne może być podanie żądanego typu jako pierwszego argumentu typu oraz danych, które mają być sprawdzone jako pierwszego argumentu funkcji.",
        "Damit diese Funktion den Typ `string` erhält, muss es dieses dem Typen-Compiler mitteilen.": "Aby funkcja mogła otrzymać typ `string`, musi to zakomunikować kompilatorowi typów.",
        "`ReceiveType` mit der Referenz auf den ersten Typenargumenten `T` signalisiert dem Typen-Compiler, dass jeder Aufruf zu `validate` den Type an zweiter Stelle (da `type` an zweiter Stelle deklariert ist) stellen soll. Um zur Laufzeit dann die Informationen auszulesen, wird die Funktion `resolveReceiveType` genutzt.": "`ReceiveType` z referencją do pierwszego argumentu typu `T` sygnalizuje kompilatorowi typów, że każde wywołanie `validate` powinno umieścić typ na drugim miejscu (ponieważ `type` jest zadeklarowany na drugim miejscu). Aby odczytać te informacje w czasie pracy, używana jest funkcja `resolveReceiveType`.",
        "Es ist nützlich, das Ergebnis derselben Variable zuzuweisen, um nicht unnötig eine neue anzulegen. In `type` ist nun entweder ein Typen-Objekt abgelegt oder es wird ein Fehler geworfen, wenn zum Beispiel kein Typen-Argument übergeben wurde, Deepkit's Typen-Compiler nicht richtig installiert wurde, oder das Emitieren von Typeninformationen nicht aktiviert ist (siehe dazu die Sektion Installation weiter oben).": "Warto przypisać wynik do tej samej zmiennej, aby niepotrzebnie nie tworzyć nowej. W `type` jest teraz albo przechowywany obiekt typu, albo wyrzucany jest błąd, jeśli na przykład nie został przekazany żaden argument typu, kompilator typów Deepkita nie został poprawnie zainstalowany lub emitowanie informacji o typie nie jest włączone (zobacz sekcję dotyczącą instalacji powyżej).",
        "Bytecode": "Bytecode",
        "Um im Detail zu lernen, wie Deepkit die Typeninformationen im JavaScript enkodiert und ausliest, ist dieses Kapitel gedacht. Es erklärt, wie die Typen konkret in Bytecode umgewandelt, im JavaScript emittiert, und anschließen zur Laufzeit interpretiert werden.": "Ten rozdział jest przeznaczony do szczegółowego zapoznania się z tym, jak Deepkit koduje i odczytuje informacje o typie w języku JavaScript. Wyjaśnia, w jaki sposób typy są faktycznie konwertowane na kod bajtowy, emitowane w JavaScript, a następnie interpretowane w czasie wykonywania.",
        "Typen-Compiler": "Kompilator typów",
        "Der Type-Compiler (in @deepkit/type-compiler) ist dafür Verantwortlich, die definierten Typen in den TypeScript Dateien auszulesen und in ein Bytecode zu kompilieren. Dieser Bytecode hat alles, was nötig ist, um die Typen in der Laufzeit auszuführen.": "Kompilator typów (w @deepkit/type-compiler) jest odpowiedzialny za odczytywanie zdefiniowanych typów w plikach TypeScript i kompilowanie ich do postaci kodu bajtowego. Ten kod bajtowy zawiera wszystko, co jest potrzebne do wykonania typów w trybie runtime.",
        "Zum Zeitpunkt dieses Buches ist der Type-Compiler ein sogenannter TypeScript Transformer. Dieser Transformer ist ein Plugin für den TypeScript Compiler selbst und wandelt ein TypeScript AST (Abstract Syntax Tree) in ein anderen TypeScript AST um. Deepkit's Typen-Compiler liest in diesem Prozess den AST aus, produziert den dazugehörigen Bytecode, und fügt diesen in den AST ein.": "W chwili pisania tego tekstu kompilator typów jest tak zwanym transformatorem języka TypeScript. Transformator ten jest wtyczką do samego kompilatora TypeScript i konwertuje drzewo składni abstrakcyjnej (AST) języka TypeScript na inne drzewo składni TypeScript. W tym procesie kompilator typów Deepkit odczytuje AST, tworzy odpowiedni kod bajtowy i wstawia go do AST.",
        "TypeScript selbst erlaubt es nicht, dieses Plugin aka Transformer über eine tsconfig.json zu konfigurieren. Es ist entweder nötig, die TypeScript Compiler API direkt zu benutzen, oder ein Buildsystem wie Webpack mit `ts-loader`. Um diesen unangenehmen Weg den Benutzern von Deepkit zu ersparen, installiert sich der Deepkit Typen-Compiler automatisch selbst in `node_modules/typescript` sobald `@deepkit/type-compiler` installiert wird. Dies macht es möglich, dass alle Buildtools, die auf das lokal installierte TypeScript (das in `node_modules/typescript`) zugreifen, automatisch den Typen-Compiler aktiviert haben. Dadurch funktioniert tsc, Angular, webpack, ts-node, und einige andere Tools automatisch mit Deepkit's Typen-Compiler.": "Sam TypeScript nie pozwala na skonfigurowanie tego pluginu aka transformatora za pomocą tsconfig.json. Konieczne jest albo bezpośrednie użycie API kompilatora TypeScript, albo systemu budowania, takiego jak Webpack z `ts-loader`. Aby uniknąć tej niedogodności dla użytkowników Deepkit, kompilator typów Deepkit automatycznie instaluje się w `node_modules/typescript`, gdy zainstalowany jest `@deepkit/type-compiler`. Dzięki temu wszystkie narzędzia budujące, które mają dostęp do lokalnie zainstalowanego TypeScriptu (tego w `node_modules/typescript`), będą miały automatycznie włączony kompilator typów. Dzięki temu tsc, Angular, webpack, ts-node i niektóre inne narzędzia automatycznie współpracują z kompilatorem typów Deepkit.",
        "Ist das automatische Ausführen von NPM install scripts nicht aktiviert und wird so das lokal installierte Typescript nicht modifiziert, so muss dieser Prozess manuell ausgeführt werden, sofern man das möchte. Alternative kann auch der Typen-Compiler manuell in einen Buildtool wie zum Beispiel webpack genutzt werden. Siehe dazu die Sektion Installation weiter oben.": "Jeśli nie włączono automatycznego wykonywania skryptów instalacyjnych NPM i nie zmodyfikowano lokalnie zainstalowanego skryptu, proces ten należy w razie potrzeby wykonać ręcznie. Kompilatora typów można też użyć ręcznie w narzędziu budującym, takim jak webpack. Patrz rozdział Instalacja powyżej.",
        "Bytecode Encoding": "Kodowanie bajtkodu",
        "Der Bytecode ist eine Folge von Befehlen für eine Virtuelle Maschine und ist im JavaScript selbst als Array mit Referenzen und String (dem eigentlichen Bytecode) enkodiert.": "Kod bajtowy jest sekwencją poleceń dla maszyny wirtualnej i jest zakodowany w samym JavaScripcie jako tablica z referencjami i ciągiem znaków (właściwy kod bajtowy).",
        "Die vorhandenen Befehle selbst sind jeweils ein Byte groß und in `@deepkit/type-spec` als `ReflectionOp` Enum zu finden. Zum Zeitpunkt dieses Buches ist der Befehlssatz über 81 Befehle gross.": "Same istniejące komendy mają rozmiar jednego bajtu i można je znaleźć w `@deepkit/type-spec` jako enumy `ReflectionOp`. W chwili pisania tego tekstu zestaw poleceń liczy ponad 81 poleceń.",
        "Eine Folge von Befehlen wird enkodiert als einen String um Speicherplatz zu sparen. So wird ein Typ `string[]` als Bytecode Program `[string, array]` konzeptionell dargestellt, welches die Bytes `[5, 37]` hat und mit folgendem Algorithmus enkodiert:": "Sekwencja poleceń jest zakodowana jako ciąg znaków, co pozwala zaoszczędzić pamięć. Tak więc typ `string[]` jest konceptualizowany jako program bajtowy `[string, array]`, który ma bajty `[5, 37]` i jest kodowany według następującego algorytmu:",
        "Entsprechend wird aus einer 5 ein `&`-Zeichen und aus einer 37 ein `F`-Zeichen. Zusammen wird daraus `&F` und in Javascript als `['&F']` emittiert.": "Odpowiednio, 5 staje się znakiem `&`, a 37 staje się znakiem `F`. Razem tworzą one `&F` i są emitowane w języku Javascript jako `['&F']`.",
        "Um Namenskonflikte vorzubeugen, erhält jeder Typ ein \"__Ω\" als Prefix. Für jeden explizit definierten Typen, der exportiert oder von einem exportierten Typen genutzt wird, wird ein Bytecode  das JavaScript emittiert. Auch Klassen und Funktionen erhalten einen Bytecode direkt als Eigenschaft.": "Aby zapobiec konfliktom nazw, każdy typ otrzymuje \"_Ω\" jako prefiks. Dla każdego jawnie zdefiniowanego typu, który jest eksportowany lub używany przez typ eksportowany, JavaScript emituje kod bajtowy. Klasy i funkcje również otrzymują kod bajtowy bezpośrednio jako właściwość.",
        "Virtuelle Maschine": "Maszyna wirtualna",
        "Eine virtuelle Maschine (in `@deepkit/type` die Klasse Processor) zur Laufzeit ist dafür zuständig den encodierten Bytecode zu dekodieren und auszuführen. Sie gibt immer ein Typen-Objekt zurück, siehe weiter oben die Sektion Reflection.": "Maszyna wirtualna (w `@deepkit/type` klasa Processor) w trybie runtime jest odpowiedzialna za dekodowanie i wykonywanie zakodowanego bajtkodu. Zwraca ona zawsze obiekt typu, patrz rozdział Refleksja powyżej.",
        "Validation ist der Prozess um Daten auf Korrektheit zu prüfen. Korrektheit ist dann gegeben, wenn der Typ der Richtige ist und zusätzliche definierte Einschränkungen erfüllt sind. Dabei unterscheidet Deepkit generell zwischen Typenvalidierung und die Validierung von zusätzlichen Einschränkungen.": "Walidacja to proces sprawdzania poprawności danych. Poprawność jest zapewniona, jeśli typ jest poprawny i spełnione są dodatkowe zdefiniowane ograniczenia. W pakiecie Deepkit zasadniczo rozróżnia się walidację typu i walidację dodatkowych ograniczeń.",
        "Es wird immer dann Validation benutzt, wenn Daten aus einer Quelle stammen, die als unsicher gilt. Unsicher bedeutet, dass keine garantierten Annahmen über die Typen oder Inhalte der Daten getroffen werden können und somit die Daten buchstäblichen jeden beliebigen Wert zur Laufzeit haben könnte.": "Walidację stosuje się zawsze wtedy, gdy dane pochodzą ze źródła, które uważa się za niepewne. Niepewność oznacza, że nie można przyjąć żadnych gwarantowanych założeń dotyczących typów lub zawartości danych, a zatem dane te mogą mieć dosłownie dowolną wartość w czasie wykonywania zadania.",
        "So sind Daten aus Usereingaben generell als nicht sicher einzustufen. Daten aus einem HTTP-Request (query parameter, body), CLI-Argumente, oder einer eingelesenen Datei müssen validiert werden. Wenn eine Variable als Nummer deklariert ist, muss sich auch eine Nummer darin befinden, ansonsten kann das Program abstürzen oder eine Sicherheitslücke entstehen.": "Na przykład dane wprowadzane przez użytkowników nie są na ogół uważane za bezpieczne. Dane z żądania HTTP (parametr zapytania, treść), argumenty CLI lub wczytany plik muszą zostać zweryfikowane. Jeśli zmienna jest zadeklarowana jako liczba, musi się w niej znajdować również liczba, w przeciwnym razie program może się zawiesić lub może wystąpić luka w zabezpieczeniach.",
        "In einem Controller einer HTTP-Route zum Beispiel ist somit oberstes Gebot, jede Usereingabe (query parameter, body) zu prüfen. Hierbei ist besonders im Umfeld von TypeScript zu beachten, dass keine Type-Casts verwenden werden, da diese fundamental unsicher sind.": "Na przykład w kontrolerze trasy HTTP najważniejszym priorytetem jest sprawdzenie każdego wejścia użytkownika (parametru zapytania, ciała). Szczególnie w środowisku TypeScript nie należy używać rzutowania typów, ponieważ jest ono z gruntu niebezpieczne.",
        "Dieser oft gesehene Code stellt ein Fehler da, der zum Programmabsturz oder zu einer Sicherheitslücke führen kann, da ein Type-Cast `as number` verwendet wurde, der keinerlei Sicherheiten zur Laufzeit bereitstellt. Der User kann als `limit` einfach einen String übergeben und das Program würde dann mit einem String in `limit` arbeiten, obwohl der Code darauf basiert, dass es eine Nummer sein muss. Um diese Sicherheit zur Laufzeit zu erhalten gibt es Validatoren und Type-Guards. Auch könnte ein Serializer benutzt werden, um `limit` in eine Nummer umzuwandeln. Hierzu findet sich in dem Kapitel <<serialisation>> mehr Informationen.": "Ten często spotykany kod jest błędem, który może doprowadzić do awarii programu lub powstania luki w zabezpieczeniach, ponieważ użyto rzutowania typu `jak liczba`, które nie zapewnia żadnego bezpieczeństwa w czasie wykonywania programu. Użytkownik może po prostu przekazać łańcuch jako `limit`, a program będzie wtedy pracował z łańcuchem w `limit`, chociaż kod opiera się na tym, że musi to być liczba. Aby zachować to bezpieczeństwo w czasie pracy, stosuje się walidatory i strażniki typów. Można też użyć serializera do konwersji `limit` na liczbę. Więcej informacji na ten temat można znaleźć w rozdziale <<serializacja>>.",
        "Validation ist essenzieller Bestandteil jeder Anwendung und sollte besser einmal zuviel als einmal zu wenig genutzt werden. Deepkit stellt viele Validationsoptionen bereit und hat eine high-performance Implementierung, sodass sich in den allermeisten Fällen kein Gedanke um die Ausführungszeit gemacht werden muss. Nutzen Sie soviel Validation wie möglich, im Zweifel einmal mehr, um auf der sicheren Seite zu stehen.": "Walidacja jest niezbędnym elementem każdej aplikacji i lepiej jest ją stosować raz za często niż raz za rzadko. Deepkit udostępnia wiele opcji walidacji i ma wydajną implementację, więc w większości przypadków nie trzeba się martwić o czas wykonania. Użyj jak najwięcej walidacji, a w razie wątpliwości użyj więcej, aby się zabezpieczyć.",
        "Dabei haben viele Komponenten von Deepkit wie z.b. der HTTP-Router, die RPC-Abstraktion, aber auch die Datenbank Abstraktion selbst Validation eingebaut und wird automatisch ausgeführt, sodass es in vielen Fällen nicht nötig ist, dies manuell zu machen.": "Wiele komponentów Deepkit, takich jak router HTTP, abstrakcja RPC, ale także sama abstrakcja bazy danych, ma wbudowaną walidację, która jest wykonywana automatycznie, tak że w wielu przypadkach nie ma potrzeby wykonywania jej ręcznie.",
        "In den dazugehörigen Kapiteln (<<cli>>, <<http>>, <<rpc>>, <<database>>) ist genaustens erklärt, wann eine Validation automatisch geschieht. Stellen Sie dabei sicher, dass Ihnen bekannt ist, an welchen Stellen Einschränkungen beziehungsweise Typen definieren werden müssen und nutzen Sie kein `any`, damit diese Validierungen automatisch gut und sicher funktionieren. So können Sie sich eine ganze Menge manueller Arbeit sparen, um den Code sauber und sicher zu halten.": "W odpowiednich rozdziałach (<<cli>>, <<http>>, <<rpc>>, <<database>>) szczegółowo wyjaśniono, kiedy walidacja odbywa się automatycznie. Upewnij się, że wiesz, gdzie należy zdefiniować ograniczenia lub typy i nie używaj `każdego`, aby te walidacje działały dobrze i bezpiecznie automatycznie. Dzięki temu można zaoszczędzić wiele pracy ręcznej związanej z utrzymaniem czystości i bezpieczeństwa kodu.",
        "Benutzung": "Użyj strony",
        "Die Basisfunktion des Validators ist es, ein Wert auf seinen Typ zu prüfen. Zum Beispiel ob eine Wert ein String ist. Dabei geht es nicht darum, was der String beinhaltet, sondern lediglich um seinen Typ. Typen gibt es viele in Typescript: string, number, boolean, bigint, objects, classes, interface, generics, mapped types, und viele mehr. Durch TypeScripts mächtiges Typensystem sind eine große Vielzahl von unterschiedlichsten Typen vorhanden.": "Podstawową funkcją walidatora jest sprawdzanie wartości pod kątem jej typu. Na przykład, czy wartość jest ciągiem znaków. Nie chodzi o to, co zawiera łańcuch, lecz tylko o jego typ. W typie skryptu istnieje wiele typów: string, number, boolean, bigint, obiekty, klasy, interfejsy, generics, typy mapowane i wiele innych. Dzięki rozbudowanemu systemowi typów w języku Typescript dostępna jest duża liczba różnych typów.",
        "In JavaScript selbst können primitive Typen mit dem `typeof` operator analysiert werden. Für komplexere Typen wie interfaces, mapped types, oder generische Set/Map ist das nicht mehr so einfach möglich und es wird eine Validator-Library wie zum Beispiel `@deepkit/type` nötig. Deepkit ist dabei die einzige Lösung, die es erlaubt, alle TypenScript Typen direkt ohne Umwege zu validieren.": "W samym języku JavaScript typy prymitywne można analizować za pomocą operatora `typeof`. W przypadku bardziej złożonych typów, takich jak interfejsy, typy odwzorowane czy generic set/map, nie jest to już możliwe i konieczna jest biblioteka walidatorów, taka jak `@deepkit/type`. Deepkit jest jedynym rozwiązaniem, które umożliwia bezpośrednią walidację wszystkich typów TypesScript bez konieczności korzystania z objazdów.",
        "Der Type von `username` ist String. Sofern ein Validator prüfen soll, ob die Variable `username` ein String ist, kann das mit JavaScript selbst einfach bewerkstelligt werden.": "Typ `username` to string. Jeśli walidator ma sprawdzić, czy zmienna `username` jest ciągiem znaków, można to łatwo zrobić za pomocą samego JavaScriptu.",
        "Die Funktion `isString` kann somit als Typenvalidator angesehen werden. In JavaScript selbst wird es dabei allerdings bereits schwieriger wenn Nummern geprüft werden sollen. So gibt es Besonderheiten, wie NaN (\"Not a Number\") wenn eine invalide Zeichenkette in eine Nummer umgewandelt wird.": "Funkcja `isString` może być zatem postrzegana jako walidator typów. W samym języku JavaScript staje się to jednak trudniejsze, gdy trzeba sprawdzić liczby. Istnieją specjalne funkcje, takie jak NaN (\"Not a Number\"), gdy nieprawidłowy ciąg znaków jest przekształcany na liczbę.",
        "Der Operator `typeof` gibt dabei Number zurück, obwohl es sich um den Wert NaN (\"Not a Number\") handelt, welcher buchstäblich aussagt, keine Nummer sein zu wollen. Ab hier müssen bereits besondere zusätzlichen Prüfungungen wie `isNaN()` unternommen werden und es bietet sich schnell an, externe Libraries wie Deepkit zu verwenden, die diese Besonderheiten automatisch berücksichtigen.": "Operator `typeof` zwraca liczbę, choć jest to wartość NaN (\"Not a Number\"), która dosłownie mówi, że nie chce być liczbą. Od tego momentu należy przeprowadzać specjalne dodatkowe kontrole, takie jak `isNaN()`, i szybko staje się oczywiste, że należy korzystać z zewnętrznych bibliotek, takich jak Deepkit, które automatycznie uwzględniają te osobliwości.",
        "In Deepkit kann eine Typevalidierung entweder über die Funktion `validate`, `is`, oder `assert` unternommen werden. Die Funktion `is` ist dabei ein sogenannter Type-Guard und `assert` eine Type-Assertion. Beide werden erst in der nächsten Sektion erklärt.": "W Deepkit, walidacja typu może być przeprowadzona za pomocą funkcji `validate`, `is` lub `assert`. Funkcja `is` jest tzw. strażnikiem typu, a `assert` jest asercją typu. Obie te kwestie zostaną wyjaśnione w następnym rozdziale.",
        "Die Funktion `validate` gibt ein Array von gefundenen Fehlern und bei Erfolg ein leeres Array zurück. Jeder Eintrag in diesem Array beschreibt dabei den genaue Fehlercode und die Fehlermeldung sowie auch den Pfad sobald komplexere Typen wie Objekte oder Arrays validiert werden.": "Funkcja `validate` zwraca tablicę znalezionych błędów, a w przypadku powodzenia - pustą tablicę. Każdy wpis w tej tablicy opisuje dokładny kod błędu oraz komunikat o błędzie, a także ścieżkę, gdy tylko sprawdzane są bardziej złożone typy, takie jak obiekty lub tablice.",
        "Die Benutzung aller drei Funktionen geschieht grob auf die selbe Weise. So wird als ersten Typenargument der Typ angegeben beziehungsweise referenziert und als erstes Funktionsargument die Daten übergeben.": "Wszystkie trzy funkcje są wykorzystywane w mniej więcej taki sam sposób. Typ jest określany lub przywoływany jako pierwszy argument typu, a dane są przekazywane jako pierwszy argument funkcji.",
        "Wird mit komplexeren Typen wie Klassen oder Interfaces gearbeitet, kann das Array auch mehrere Einträge beinhalten.": "Podczas pracy z bardziej złożonymi typami, takimi jak klasy lub interfejsy, tablica może również zawierać kilka wpisów.",
        "Der Validator unterstützt dabei auch tiefe rekursive Typen. Pfade werden dann mit einem Punkt getrennt angegeben.": "Walidator obsługuje również typy głęboko rekursywne. Ścieżki są następnie oddzielane kropką.",
        "Nutzen Sie dabei die Vorteile, die TypeScript ihnen bietet. So können komplexere Typen wie ein `User` an mehreren Stellen wiederverwendet werden, ohne diesen immer wieder erneut zu deklarieren. Ist zum Beispiel ein `User` ohne seine `id` zu valideren, können TypeScript Utitilies genutzt werden, um schnell und effizient abgeleitete Untertypen zu erstellen. Ganz im Sinne von DRY (Don't Repeat Yourself).": "Wykorzystaj zalety, jakie oferuje Ci język TypeScript. Na przykład bardziej złożone typy, takie jak `user`, mogą być używane w wielu miejscach bez konieczności ich wielokrotnego deklarowania. Na przykład, jeśli `user` ma być walidowany bez jego `id`, można użyć narzędzi TypeScript do szybkiego i efektywnego tworzenia podtypów pochodnych. W duchu zasady DRY (Don't Repeat Yourself - nie powtarzaj się).",
        "Deepkit hat als einziges großes Framework die Möglichkeit, auf TypeScripte Typen auf diese Art und Weise zur Laufzeit zuzugreifen. Möchten Sie Typen in Frontend und Backend nutzen, können Typen in eine eigene Datei ausgelagert werden und so überall importiert werden. Nutzen Sie diese Möglichkeit zu Ihrem Vorteil, um den Code effizient und sauber zu halten.": "Deepkit jest jedynym dużym frameworkiem, który może w ten sposób uzyskiwać dostęp do typów TypeScripts w czasie uruchamiania. Jeśli typy mają być używane zarówno we front-endzie, jak i w backendzie, można je przenieść do osobnego pliku i w ten sposób importować wszędzie. Skorzystaj z tej opcji, aby zachować wydajność i czystość kodu.",
        "Ein Type-Cast (konträr zur Type-Guard) in TypeScript ist kein Konstrukt zur Laufzeit, sondern wird nur im Typensystem selbst behandelt. Es ist keine sichere Variante, um unbekannten Daten einen Typ zuzuweisen.": "Rzutowanie typu (w przeciwieństwie do strażnika typu) w TypeScripcie nie jest konstrukcją wykonywaną w czasie rzeczywistym, lecz jest obsługiwane w samym systemie typów. Nie jest to bezpieczny sposób przypisywania typu do nieznanych danych.",
        "Der Code `as string` ist dabei nicht sicher. Die Variable `data` könnte buchstäblichen jeden Wert haben, so zum Beispiel `{username: 123}`, or gar `{}`, und hätte zur Folge, dass `username` nicht ein String ist, sondern etwas völlig anderes und daher der Code `username.startsWith('@')` zu einem Fehler führen wird, so dass im schlimmsten Fall das Programm abstürzt. Um zur Laufzeit garantiert festzustellen, dass `data` hier eine Eigenschaft `username` mit dem Type String hat, müssen Type-Guards verwendet werden.": "Kod `as string` nie jest bezpieczny. Zmienna `data` może mieć dosłownie dowolną wartość, na przykład `{username: 123}`, lub nawet `{}`, i spowoduje, że `username` nie będzie ciągiem znaków, lecz czymś zupełnie innym, a zatem kod `username.startsWith('@')` spowoduje błąd, tak że w najgorszym przypadku program się zawiesi. Aby zagwarantować, że `data` posiada właściwość `username` o typie string, należy użyć strażników typu.",
        "Type-Guards sind Funktionen, die TypeScript einen Hinweis darüber geben, welche Type die übergeben Daten zur Laufzeit garantiert haben. Mit diesem Wissen ausgestattet, verfeinert (\"narrowed\") TypeScript dann den Typ im weiteren Codeverlauf.  Aus zum Beispiel `any` kann somit ein String, oder ein anderer Typ auf eine sichere Weise gemacht werden.": "Strażnicy typów to funkcje, które podpowiadają TypeScriptowi, jakiego typu mają być przekazywane dane w czasie wykonywania. Zaopatrzony w tę wiedzę TypeScript udoskonala (\"zawęża\") typ w dalszym toku kodu.  Na przykład `any` można zamienić na łańcuch lub inny typ w bezpieczny sposób.",
        "Wenn also Daten vorliegen, von denen der Typ nicht bekannt ist (`any` oder `unknown`), hilft ein Type-Guard diesen basierend auf den Daten selbst genauer sicher einzugrenzen. Dabei ist der Type-Guard nur so sicher wie seine Implementieren. Machen Sie dabei einen Fehler, kann das schwere Folgen nach sich ziehen, da fundamentale Annahmen sich plötzlich als unwahr herausstellen.": "Jeśli istnieją dane, których typ nie jest znany (`każdy` lub `nieznany`), strażnik typu pomaga zawęzić je bardziej precyzyjnie na podstawie samych danych. Jednak strażnik typu jest tak bezpieczny, jak jego implementacja. Jeśli popełnisz błąd, może to mieć poważne konsekwencje, ponieważ podstawowe założenia nagle okażą się nieprawdziwe.",
        "Type-Guard": "Typ-Guard",
        "Ein Type-Guard auf den obige genutzten Typen `User` könnte in einfachster Form wie folgt aussehen. Zu beachten ist, dass die obigen erklärten Besonderheiten mit NaN hier nicht Bestandteil sind und somit dieser Type-Guard nicht ganz korrekt ist.": "Strażnik typu na wyżej wymienionym typie `User` może wyglądać w najprostszej postaci następująco. Należy zauważyć, że wyjaśnione powyżej specjalne właściwości NaN nie są częścią tego typu i dlatego nie jest on w pełni poprawny.",
        "Ein Type-Guard gibt immer ein Boolean zurück und wird in der Regel direkt in einer If-Bedienung genutzt.": "Strażnik typu zawsze zwraca wartość logiczną i jest zwykle używany bezpośrednio w operacji If.",
        "Für jeden Type-Guard eine eigene Funktion zu schreiben, besonders für komplexere Typen, und diese dann immer wieder anzupassen, wenn ein Typ sich verändert, ist äußerst mühsam, fehleranfällig, und nicht effizient. Daher bietet Deepkit die Funktion `is` an, welche automatisch für jeden beliebigen TypeScript Typen einen Type-Guard bereitstellt. Diese berücksichtigt dann auch automatisch Besonderheiten wie das oben erwähnte Problem mit NaN. Die Funktion `is` macht dabei dasselbe wie `validate`, nur gibt sie statt einem Array von Fehler schlicht ein Boolean zurück.": "Pisanie osobnej funkcji dla każdego zabezpieczenia typu, zwłaszcza dla bardziej złożonych typów, a następnie dostosowywanie jej za każdym razem, gdy zmienia się typ, jest niezwykle żmudne, podatne na błędy i nieefektywne. Dlatego Deepkit oferuje funkcję `is`, która automatycznie zapewnia ochronę typu dla dowolnego typu TypeScript. W ten sposób automatycznie uwzględnia się cechy szczególne, takie jak wspomniany wyżej problem z NaN. Funkcja `is` robi to samo co `validate`, ale zamiast tablicy błędów zwraca po prostu boolean.",
        "Ein öfter aufzufindendes Pattern ist, bei fehlerhafter Validierung direkt ein Fehler zurückzugeben, sodass nachfolgender Code nicht ausgeführt wird. Das kann an diversen Stellen genutzt werden, ohne den kompletten Flow des Codes abzuändern.": "Częściej spotykanym wzorcem jest zwracanie błędu bezpośrednio w przypadku błędnej walidacji, tak aby nie był wykonywany kolejny kod. Można to wykorzystać w różnych miejscach, nie zmieniając całego przepływu kodu.",
        "Alternativ kann eine TypeScript type assertion verwenden werden. Die Funktion `assert` wirft automatisch einen Fehler, wenn die gegebenen Daten nicht auf einen Typen korrekt validiert. Die spezielle Signatur der Funktion, welche TypeScript type assertions auszeichnet, hilft TypeScript dabei, die übergebene Variable automatisch zu verfeinern (\"narrowing\").": "Alternatywnie można użyć asercji typu TypeScript. Funkcja `assert` automatycznie wyrzuca błąd, jeśli podane dane nie są poprawnie zweryfikowane do typu. Specjalna sygnatura funkcji, która wyróżnia asercje typu TypeScript, pomaga TypeScriptowi automatycznie zawęzić przekazywaną zmienną.",
        "Nutzen Sie auch hier die Vorteile, die TypeScript ihnen bietet. Typen können wiederverwendet oder durch diverse TypeScript Funktionen angepasst werden.": "Skorzystaj z zalet, jakie TypeScript oferuje również tutaj. Typy można ponownie wykorzystać lub dostosować za pomocą różnych funkcji języka TypeScript.",
        "Error Reporting": "Zgłaszanie błędów",
        "Die Funktionen `is`, `assert` und `validates` geben ein Boolean als Resultat zurück. Um genaue Informationen über fehlgeschlagenen Validations-Regeln zu erhalten, kann die Funktion `validate` benutzt werden. Sie gibt ein leeres Array zurück, wenn alles erfolgreich validiert wurde. Bei Fehlern enthält das Array ein oder mehrere Einträge mit folgender Struktur:": "Funkcje `is`, `assert` i `validates` zwracają jako wynik wartość logiczną. Aby uzyskać dokładne informacje o nieudanych regułach walidacji, można użyć funkcji `validate`. Zwraca pustą tablicę, jeśli wszystko zostało pomyślnie zwalidowane. Jeśli wystąpią błędy, tablica zawiera jeden lub więcej wpisów o następującej strukturze:",
        "Die Funktion erhält als erstes Typen-Argument ein beliebigen TypeScript Typ und als erstes Argument die zu validierende Daten.": "Funkcja otrzymuje dowolny typ TypeScript jako pierwszy argument typu oraz dane do sprawdzenia jako pierwszy argument.",
        "Es können hierbei auch komplexe Typen wie Interfaces, Klassen, oder Generics benutzt werden.": "Można również stosować typy złożone, takie jak interfejsy, klasy lub generyczne.",
        "Einschränkungen": "Ograniczenia",
        "Zusätzlich zum Prüfen der Typen können weitere beliebige Einschränkungen an einen Typen hinzugefügt werden. Das Prüfen von diesen zusätzlichen Inhalts-Einschränkungen erfolgt automatisch, nachdem die Typen selbst geprüft wurden. Dies geschieht in allen Validierungsfunktionen wie `validate`, `is`, and `assert`. Eine Einschränkung kann dabei zum Beispiel sein, dass ein String eine bestimmte minimale oder maximale Länge haben muss.": "Oprócz sprawdzania typów, do typu można dodać dowolne inne ograniczenia. Sprawdzanie tych dodatkowych ograniczeń treści odbywa się automatycznie po sprawdzeniu samych typów. Odbywa się to we wszystkich funkcjach walidacji, takich jak `validate`, `is` i `assert`. Ograniczenie może polegać na przykład na tym, że ciąg znaków musi mieć określoną minimalną lub maksymalną długość.",
        "Diese Einschränkungen werden über die Typen-Decorators an den eigentlichen Typen hinzugefügt. Dabei gibt es eine ganze Vielzahl von Dekorationen, die genutzt werden können. Eigene Decorators können bei erweitertem Bedarf nach Belieben selbst definiert und genutzt werden.": "Ograniczenia te są dodawane do typów rzeczywistych za pomocą dekoratorów typów. Istnieje cała gama dekoratorów, z których można korzystać. Można zdefiniować własne dekoratory i używać ich zgodnie z potrzebami w przypadku rozszerzonych potrzeb.",
        "Mit `&` können beliebig viele Typen-Decorators an den eigentlichen Typ hinzugefügt werden. Das Ergebnis, hier `Username`, kann dann in allen Validierungsfunktionen aber auch in anderen Typen genutzt werden.": "Za pomocą `&` do typu rzeczywistego można dodać dowolną liczbę dekoratorów typu. Wynik, tutaj `username`, może być następnie użyty we wszystkich funkcjach walidacyjnych, ale także w innych typach.",
        "Die Funktion `validate` gibt dabei nützliche Fehlermeldungen, die von den Einschränkungen kommen.": "Funkcja `validate` podaje użyteczne komunikaty o błędach, które wynikają z ograniczeń.",
        "Diese Informationen können zum Beispiel wunderbar auch an einem Formular automatisch dargestellt und mittels des `code` übersetzt werden. Durch den vorhandenen Pfad bei Objekten und Arrays können so Felder in einem Formular den passenden Fehler rausfiltern und anzeigen.": "Informacje te mogą być na przykład automatycznie wyświetlane na formularzu i tłumaczone za pomocą \"kodu\". Dzięki istniejącej ścieżce dla obiektów i tablic, pola formularza mogą być filtrowane i wyświetlane z odpowiednim błędem.",
        "Ein oft nützlicher Anwendungsfall ist auch eine E-Mail mit einer RegExp-Einschränkung zu definieren. Einmal den Typ definiert, kann er überall benutzt werden.": "Często przydatnym przypadkiem jest także definiowanie wiadomości e-mail z ograniczeniem RegExp. Po zdefiniowaniu typu można go używać w dowolnym miejscu.",
        "Es können beliebig viele Einschränkungen hinzugefügt werden.": "Można dodać dowolną liczbę ograniczeń.",
        "Constraint Types": "Typy ograniczeń",
        "Validate&lt;typeof myValidator&gt;": "Validate&lt;typeof myValidator&gt;",
        "Validierung mitteils einer benutzerdefinierten Validierungsfunktion. Siehe nächste Sektion Benutzerdefinierte Validator für mehr Informationen.": "Walidacja przy użyciu niestandardowej funkcji walidatora. Więcej informacji można znaleźć w następnej sekcji Walidator niestandardowy.",
        "Pattern&lt;typeof myRegexp&gt;": "Pattern&lt;typeof myRegexp&gt;",
        "Defines a regular expression as validation pattern. Usually used for E-Mail validation or more complex content validation.": "Określa wyrażenie regularne jako wzorzec sprawdzania poprawności. Zazwyczaj używane do sprawdzania poprawności wiadomości e-mail lub bardziej złożonej walidacji zawartości.",
        "Alpha": "Alfa",
        "Validation for alpha characters (a-Z).": "Walidacja dla znaków alfa (a-Z).",
        "Alphanumeric": "Alfanumeryczne",
        "Validation for alpha and numeric characters.": "Walidacja dla znaków alfanumerycznych i numerycznych.",
        "Ascii": "Ascii",
        "Validation for ASCII characters.": "Walidacja dla znaków ASCII.",
        "Decimal&lt;number, number&gt;": "Liczba dziesiętna&lt;liczba, liczba&gt;",
        "Validation for string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.": "Walidacja łańcucha reprezentującego liczbę dziesiętną, np. 0,1, .3, 1,1, 1,00003, 4,0 itd.",
        "MultipleOf&lt;number&gt;": "MultipleOf&lt;number&gt;",
        "Validation of numbers that are a multiple of given number.": "Sprawdzanie poprawności liczb, które są wielokrotnością podanej liczby.",
        "MinLength&lt;number&gt;, MaxLength&lt;number&gt;": "MinDługość&lt;liczba&gt;, MaxDługość&lt;liczba&gt;",
        "Validation for min/max length for arrays or strings.": "Walidacja minimalnej/maksymalnej długości tablic lub łańcuchów.",
        "Includes&lt;'any'&gt; Excludes&lt;'any'&gt;": "Obejmuje&lt;'any'&gt; Excludes&lt;'any'&gt;",
        "Validation for an array item or sub string being included/excluded": "Walidacja uwzględniania/wykluczania elementu tablicy lub podłańcucha",
        "Minimum&lt;number&gt;, Maximum&lt;number&gt;": "Minimalna&lt;liczba&gt;, Maksymalna&lt;liczba&gt;;",
        "Validation for a value being minimum or maximum given number. Same as `>=` and `&lt;=`.": "Walidacja, czy wartość jest minimalną lub maksymalną podaną liczbą. Tak samo jak `>=` i `&lt;=`.",
        "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;": "ExclusiveMinimum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;, ExclusiveMaximum&lt;number&gt;",
        "Same as minimum/maximum but excludes the value itself. Same as `>` and `<`.": "To samo co minimum/maksimum, ale nie obejmuje samej wartości. Tak samo jak `>` i `<`.",
        "Positive, Negative, PositiveNoZero, NegativeNoZero": "Dodatni, Ujemny, DodatniNieZero, UjemnyNieZero.",
        "Validation for a value being positive or negative.": "Walidacja wartości dodatniej lub ujemnej.",
        "BeforeNow, AfterNow": "Przed teraz, Po teraz",
        "Validation for a date value compared to now (new Date)..": "Walidacja dla wartości daty w stosunku do teraz (nowa data)...",
        "Email": "E-mail:",
        "Simple regexp validation of emails via `/^\\S+@\\S+$/`. Is automatically a `string`, so no need to do `string & Email`.": "Prosta walidacja regexp wiadomości e-mail za pomocą `/^\\S+@\\S+$/`. Jest automatycznie `stringiem`, więc nie trzeba robić `string & Email`.",
        "integer": "liczba całkowita",
        "Ensures that the number is a integer in the correct range. Is automatically a `number`, so no need to do `number & integer`.": "Sprawdza, czy podana liczba jest liczbą całkowitą w odpowiednim zakresie. Jest automatycznie `number`, więc nie trzeba robić `number & integer`.",
        "See Special types: integer/floats for more information": "Więcej informacji można znaleźć w części Typy specjalne: integer/floats.",
        "Benutzerdefinierte Validator": "Walidator niestandardowy",
        "Wenn die eingebauten Validatoren nicht ausreichen, können eigene Validierungsfunktionen erstellt und über den `Validate`-Decorator verwendet werden.": "Jeśli wbudowane walidatory nie są wystarczające, można utworzyć własne funkcje walidacji i używać ich za pomocą dekoratora `Validate`.",
        "Beachten Sie, dass Ihre benutzerdefinierte Validierungsfunktion ausgeführt wird, nachdem alle eingebauten Typen-Validierungen aufgerufen wurden. Wenn ein Validator fehlschlägt, werden alle nachfolgenden Validatoren für den aktuellen Typen ausgelassen. Pro Typen ist nur ein Fehler möglich.": "Zwróć uwagę, że niestandardowa funkcja walidacji jest wykonywana po wywołaniu wszystkich wbudowanych walidatorów typów. Jeśli walidator zakończy się niepowodzeniem, wszystkie kolejne walidatory dla bieżącego typu są pomijane. W każdym typie może wystąpić tylko jedna awaria.",
        "Generic Validator": "Walidator ogólny",
        "In der Validator-Funktion ist das Typen-Objekt verfügbar, das verwendet werden kann, um weitere Informationen über den Typen zu erhalten, der den Validator verwendet. Es gibt auch eine Möglichkeit, eine beliebige Validator-Option zu definieren, die an den Validate-Typen übergeben werden muss und den Validator konfigurierbar macht. Mit diesen Informationen und ihren übergeordneten Referenzen können leistungsfähige generische Validatoren erstellt werden.": "W funkcji walidatora dostępny jest obiekt Type, za pomocą którego można uzyskać więcej informacji o typie, który korzysta z walidatora. Istnieje także możliwość zdefiniowania dowolnej opcji walidatora, która musi być przekazana do typu walidacji, co czyni walidator konfigurowalnym. Dzięki tym informacjom i ich referencjom nadrzędnym można tworzyć potężne walidatory generyczne.",
        "Serialisation": "Serializacja",
        "Serialisierung ist der Prozess der Umwandlung von Datentypen in ein Format, das sich beispielsweise für den Transport oder die Speicherung eignet. Die Deserialisierung ist der Prozess, der dies wieder rückgängig macht. Dies geschieht verlustfrei, d. h. die Daten können in und aus einem Serialisierungsziel konvertiert werden, ohne dass Datentypinformationen oder die Daten selbst verloren gehen.": "Serializacja to proces przekształcania typów danych w format odpowiedni np. do transportu lub przechowywania. Deserializacja to proces cofania tego procesu. Odbywa się to bezstratnie, tzn. dane mogą być konwertowane do i z obiektu serializacji bez utraty informacji o typie danych lub samych danych.",
        "In JavaScript erfolgt die Serialisierung normalerweise zwischen JavaScript-Objekten und JSON. JSON unterstützt nur String, Number, Boolean, Objekte und Arrays. JavaScript hingegen unterstützt viele weitere Typen wie BigInt, ArrayBuffer, typisierte Arrays, Date, benutzerdefinierte Klasseninstanzen und viele mehr. Um nun JavaScript-Daten mit JSON an einen Server zu übertragen, benötigen Sie einen Serialisierungsprozess (auf dem Client) und einen Deserialisierungsprozess (auf dem Server), oder umgekehrt, wenn der Server Daten als JSON an den Client sendet. Die Verwendungen von `JSON.parse` und `JSON.stringify` ist dabei oft nicht ausreichend, da diese nicht verlustfrei arbeitet.": "W języku JavaScript serializacja odbywa się zwykle między obiektami JavaScript i JSON. JSON obsługuje tylko łańcuchy, liczby, symbole booleańskie, obiekty i tablice. Z drugiej strony, JavaScript obsługuje wiele innych typów, takich jak BigInt, ArrayBuffer, tablice typowane, Date, instancje klas niestandardowych i wiele innych. Teraz, aby przesłać dane JavaScript do serwera przy użyciu JSON, potrzebny jest proces serializacji (na kliencie) i deserializacji (na serwerze) lub odwrotnie, jeśli serwer wysyła dane do klienta jako JSON. Użycie `JSON.parse` i `JSON.stringify` często nie jest wystarczające, ponieważ nie jest bezstratne.",
        "Dieser Serialisierungsprozess ist bei nicht trivialen Daten unbedingt notwendig, da JSON selbst schon bei Basistypen wie einem Datum seine Informationen verliert. Ein `new Date` wird schließlich als String in JSON serialisiert:": "Ten proces serializacji jest absolutnie konieczny w przypadku nietrywialnych danych, ponieważ JSON traci informacje nawet w przypadku podstawowych typów, takich jak data. Nowa data jest ostatecznie serializowana jako ciąg znaków w JSON:",
        "Wie zu sehen ist, ist das Ergebnis von JSON.stringify ein JSON string. Deserialisiert man dieses nun wieder mit JSON.parse, erhält man nicht ein `Date` Objekt, sondern einen String.": "Jak widać, wynikiem działania polecenia JSON.stringify jest łańcuch JSON. Po ponownej deserializacji za pomocą JSON.parse nie otrzymamy obiektu `date`, lecz ciąg znaków.",
        "Zwar gibt es diverse Workarounds, um JSON.parse das Deserialisieren von Date-Objekten beizubringen, so sind diese jedoch fehleranfällig und wenig performant. Um das typen-sichere Serialisieren und Deserialisieren für diesen Fall und vielen anderen Typen zu ermöglichen, ist ein Serialisierungsprozess notwendig.": "Chociaż istnieją różne obejścia pozwalające nauczyć JSON.parse deserializacji obiektów danych, są one podatne na błędy i nie działają dobrze. Aby umożliwić bezpieczną dla typu serializację i deserializację dla tego przypadku i wielu innych typów, konieczny jest proces serializacji.",
        "Es sind vier Hauptfunktionen verfügbar: `serialize`, `cast`/`deserialize` und `validatedDeserialize`. Unter der Haube dieser Funktionen wird der global verfügbare JSON-Serializer von `@deepkit/type` standardmäßig verwendet, es kann jedoch auch ein eigenes Serialisierungsziel genutzt werden.": "Dostępne są cztery główne funkcje: `serialize`, `cast`/`deserialize` i `validatedDeserialize`. Pod maską tych funkcji domyślnie używany jest globalnie dostępny serializator JSON z `@deepkit/type`, ale można też użyć własnego celu serializacji.",
        "Deepkit Type unterstützt benutzerdefinierte Serialisierungsziele, ist aber bereits mit einem mächtigen JSON-Serialisierungsziel ausgestattet, der Daten als JSON-Objekte serialisiert und anschließend mit JSON.stringify korrekt und sicher als JSON umgewandelt werden kann. Mit `@deepkit/bson` kann auch BSON als Serialisierungsziel verwendet werden. Wie ein eigenes Serialisierungsziel erstellt werden kann (zum Beispiel für einen Datenbanktreiber), kann in der Sektion <<serialisation-custom-serialiser>> erfahren werden.": "Deepkit Type obsługuje niestandardowe cele serializacji, ale jest już wyposażony w wydajny cel serializacji JSON, który serializuje dane jako obiekty JSON, a następnie może być poprawnie i bezpiecznie przekonwertowany na JSON za pomocą JSON.stringify. Dzięki `@deepkit/bson`, BSON może być również używany jako cel serializacji. Jak utworzyć niestandardowy cel serializacji (na przykład dla sterownika bazy danych), można dowiedzieć się w sekcji <<serializacja-niestandardowy-serializator>>.",
        "Zu beachten ist, dass obwohl Serializer auch Daten auf ihre Kompatibilität geprüft werden, sind diese Validierungen anders als die Validierung in dem Kapitel <<validation>>. Lediglich die Funktion `cast` ruft nach dem erfolgreichen Deserialisieren auch den vollen Validierungsprozess aus dem Kapitel <<validation>> auf, und wirft einen Fehler, wenn die Daten nicht valide sind.": "Należy pamiętać, że mimo iż serializatory również sprawdzają dane pod kątem zgodności, walidacje te różnią się od walidacji opisanej w rozdziale <<walidacja>>. Tylko funkcja `cast` wywołuje również pełny proces walidacji z rozdziału <<validation>> po udanej deserializacji i wyrzuca błąd, jeśli dane nie są poprawne.",
        "Alternativ kann auch `validatedDeserialize` verwendet werden, um nach dem Deserialisieren zu validieren. Eine weitere Alternative ist manuelle die Funktionen `validate` oder `validates` auf deserialisierte Daten von der Funktion `deserialize` aufzurufen, siehe dazu Kapitel <<validation>>.": "Alternatywnie, do walidacji po deserializacji można użyć polecenia `validatedDeserialize`. Inną alternatywą jest ręczne wywołanie funkcji `validate` lub `validates` na zdeserializowanych danych z funkcji `deserialize`, zobacz rozdział <<walidacja>>.",
        "Alle Funktionen aus der Serialisierung und Validation werfen bei Fehlern ein `ValidationError` aus `@deepkit/type`.": "Wszystkie funkcje z serializacji i walidacji rzucają `ValidationError` z `@deepkit/type` w przypadku błędów.",
        "Cast": "Odlew",
        "Todo": "Todo",
        "Deserialisierung": "Deserializacja",
        "Die Funktion `deserialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in den entsprechenden angegebenen Typen um. Der JSON-Serializer erwartet dabei ein JSON-Objekt, das heisst: String, Number, Boolean, Objekt, oder Array. Dies erhält man in der Regel aus einem JSON.parse Aufruf.": "Funkcja `deserialize` domyślnie konwertuje przesyłane dane za pomocą serializatora JSON na odpowiednie, określone typy. Serializator JSON oczekuje obiektu JSON, tj. ciągu znaków, liczby, booleanu, obiektu lub tablicy. Zazwyczaj uzyskuje się go za pomocą wywołania JSON.parse.",
        "Wenn dabei bereits der richtige Datentyp übergeben wird (zum Beispiel bei `created` ein Date-Objekt), dann wird dieser genommen wie er ist.": "Jeśli został już przekazany prawidłowy typ danych (na przykład obiekt Date w przypadku `created`), to jest on traktowany tak, jak jest.",
        "Es kann als ersten Typenargument nicht nur eine Klasse, sondern jeder TypeScript Typ angegeben werden. So können auch Primitives oder sehr komplexe Typen übergeben werden:": "Jako pierwszy argument typu można podać nie tylko klasę, ale także dowolny typ TypeScript. W ten sposób można również przekazywać prymitywy lub bardzo złożone typy:",
        "Weiche Typenkonvertierung": "Konwersja typu miękkiego",
        "In dem Deserialisierungsprozess ist eine weiche Typenkonvertierung implementiert. Das bedeutet, dass String und Number für String-Typen oder eine Number für einen String-Typen akzeptiert und automatisch umgewandelt werden kann. Dies ist zum Beispiel nützlich, wenn Daten über eine URL angenommen und an den Deserializer übergeben werden. Da es sich bei der URL immer um einen String handelt, versucht Deepkit Type, die Typen dennoch für Number und Boolean aufzulösen.": "W procesie deserializacji wykonywana jest miękka konwersja typów. Oznacza to, że można zaakceptować i automatycznie przekonwertować ciąg znaków i liczbę na typ łańcuchowy lub liczbę na typ łańcuchowy. Jest to przydatne na przykład wtedy, gdy dane są przyjmowane za pośrednictwem adresu URL i przekazywane do deserializatora. Ponieważ adres URL jest zawsze ciągiem znaków, Deepkit Type nadal próbuje rozwiązać typy Number i Boolean.",
        "Folgende weichen Typenkonvertierungen sind in dem JSON-Serializer eingebaut:": "W serializator JSON wbudowane są następujące konwersje typów miękkich:",
        "*number|bigint*: Number oder Bigint akzeptieren String, Number, und BigInt. Es werden `parseFloat` oder `BigInt(x)` bei einer notwendigen Umwandlung genutzt.": "*number|bigint*: Number lub Bigint akceptują String, Number i BigInt. `parseFloat` lub `BigInt(x)` są używane w przypadku konieczności dokonania konwersji.",
        "*boolean*: Boolean akzeptiert Number and String. 0, '0', 'false' wird interpretiert als `false`. 1, '1', 'true' wird interpretiert als `true`.": "*boolean*: Boolean akceptuje Number i String. 0, '0', 'false' jest interpretowane jako `false`. 1, '1', 'true' jest interpretowane jako `true`.",
        "*string*: String akzeptiert Number, String, Boolean, und viele mehr. Alle Nicht-String Werte werden automatisch mit `String(x)` umgewandelt.": "*string*: String akceptuje opcje Number, String, Boolean i wiele innych. Wszystkie wartości nie będące łańcuchami są automatycznie konwertowane za pomocą `String(x)`.",
        "Das Weiche Umwandeln kann auch deaktiviert werden:": "Konwersję miękką można również wyłączyć:",
        "Es wird bei invaliden Daten dann nicht versucht diese umzuwandeln und stattdessen eine Fehlermeldung geworfen.": "W przypadku nieprawidłowych danych nie jest podejmowana próba ich konwersji, a zamiast tego wyświetlany jest komunikat o błędzie.",
        "Serialisierung": "Serializacja",
        "Die Funktion `serialize` wandelt die übergebenen Daten per default mit dem JSON-Serializer in ein JSON Objekt um, das heisst: String, Number, Boolean, Objekt, oder Array. Das Ergebnis davon kann dann sicher mittels JSON.stringify in ein JSON umgewandelt werden.": "Funkcja `serialize` domyślnie konwertuje przekazane dane za pomocą serializatora JSON na obiekt JSON, czyli: String, Number, Boolean, Object lub Array. Wynik tej operacji można następnie bezpiecznie przekształcić w JSON za pomocą JSON.stringify.",
        "Type-Decorators": "Typ-Dekoratory",
        "Integer": "Integer",
        "Mapped": "Mapowany",
        "Naming Strategy": "Strategia nazewnictwa",
        "Benutzerdefinierter Serializer": "Serializator niestandardowy",
        "Dependency Injection": "Wstrzykiwanie zależności",
        "Dependency Injection (DI) ist ein Design-Pattern, bei dem Klassen und Funktionen ihre Abhängigkeiten _empfangen_. Es folgt dem Prinzip von Inversion of Control (IoC, zu Deutsch \"Umkehrung der Steuerung\") und hilft dabei vor allem komplexen Code besser zu separieren, um so die Testbarkeit, Modularität, und Übersichtlichkeit deutlich zu verbessern. Zwar gibt es noch andere Design-Patterns wie zum Beispiel den Service-Locator Pattern, um das Prinzip von IoC anzuwenden, jedoch hat sich DI als dominantes Pattern vor allem in Enterprise-Software etabliert.": "Wstrzykiwanie zależności (Dependency Injection, DI) to wzorzec projektowy, w którym klasy i funkcje _odbierają_ swoje zależności. Jest ona zgodna z zasadą odwrócenia kontroli (IoC) i pomaga lepiej rozdzielić złożony kod w celu znacznej poprawy testowalności, modularności i przejrzystości. Chociaż istnieją inne wzorce projektowe, takie jak wzorzec lokalizatora usług, które stosują zasadę IoC, DI stał się dominującym wzorcem, zwłaszcza w oprogramowaniu dla przedsiębiorstw.",
        "Um das Prinzip von IoC zu veranschaulichen nachfolgend ein Beispiel:": "Aby zilustrować zasadę działania IoC, podajemy przykład:",
        "Die Klasse UserRepository hat dabei einen HttpClient als Abhängigkeit. Diese Abhängigkeit an sich ist nichts Auffälliges, allerdings ist problematisch, dass UserRepository den HttpClient selbst erstellt. Dies ist auf den ersten Blick naheliegend, hat jedoch seine Nachteile: Was, wenn wir den HttpClient austauschen möchten? Was, wenn wir UserRepository in einem Unit-Test testen wollen, ohne dass echte HTTP-Anfragen herausgehen dürfen? Woher wissen wir, dass die Klasse überhaupt einen HttpClient benutzt?": "Klasa UserRepository ma zależność HttpClient. Ta zależność sama w sobie nie rzuca się w oczy, ale problematyczne jest to, że UserRepository samo tworzy HttpClienta. Jest to oczywiste na pierwszy rzut oka, ale ma swoje wady: Co zrobić, jeśli chcemy zastąpić klienta HttpClient? Co zrobić, jeśli chcemy przetestować UserRepository w teście jednostkowym, nie pozwalając na wysyłanie prawdziwych żądań HTTP? Skąd wiemy, że klasa w ogóle używa HttpClient?",
        "Inversion of Control": "Odwrócenie kontroli",
        "Im Gedanke von Inversion of Control (IoC) ist folgende alternative Variante, die den HttpClient als explizite Abhängigkeit im Constructor setzt (auch bekannt als Constructor-Injection).": "W myśli Inversion of Control (IoC) jest następujący alternatywny wariant, który ustawia HttpClient jako jawną zależność w konstruktorze (znany również jako wstrzykiwanie konstruktora).",
        "Nun ist nicht mehr UserRepository dafür verantwortlich den HttpClient anzulegen, sondern der User von UserRepository. Das ist Inversion of Control (IoC). Die Steuerung wurde umgedreht bzw. invertiert. Ganz konkret wendet dieser Code Dependency Injection an, denn Abhängigkeiten werden empfangen (injiziert) und nicht mehr selbst angelegt oder angefordert. Dependency Injection ist dabei nur eine Variante IoC anzuwenden.": "Teraz to już nie UserRepository jest odpowiedzialne za tworzenie HttpClient, lecz użytkownik UserRepository. Jest to odwrócenie kontroli (IoC). Sterowanie zostało odwrócone lub odwrócone. W szczególności kod ten wykorzystuje wstrzykiwanie zależności, ponieważ zależności są odbierane (wstrzykiwane), a nie tworzone lub żądane. Wstrzykiwanie zależności to tylko jeden z wariantów zastosowania IoC.",
        "Service Locator": "Lokalizator usług",
        "Neben DI ist auch Service Locator (SL) eine Möglichkeit, das IoC Prinzip anzuwenden. Dies gilt gemeinhin als das Gegenstück zu Dependency Injection, da es Abhängigkeiten anfordert und nicht empfängt. Würde HttpClient im obigen Code wie folgt angefordert werden, würde man von einem Service Locator Pattern sprechen.": "Oprócz DI, sposobem na zastosowanie zasady IoC jest także Service Locator (SL). Jest to powszechnie uważane za odpowiednik wstrzykiwania zależności (Dependency Injection), ponieważ żąda ono zależności, a nie je otrzymuje. Gdyby w powyższym kodzie zażądać HttpClient w następujący sposób, można by mówić o wzorcu lokalizatora usług.",
        "Die Funktion `locator.getHttpClient` kann dabei einen ganz beliebigen Namen tragen. Alternativen wären zum Beispiel Funktionsaufrufe wie `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` oder ein Container-Aufruf wie `container.get(HttpClient)`. Ein Import eines Globals ist eine etwas andere Variante eines Service Locators, bei dem das Module-System selbst als Locator benutzt wird:": "Funkcja `locator.getHttpClient` może mieć dowolną nazwę. Alternatywą mogą być, na przykład, wywołania funkcji takich jak `useContext(HttpClient)`, `getHttpClient()`, `await import(\"client\"),` lub wywołanie kontenera takie jak `container.get(HttpClient)`. Import globalny jest nieco inną odmianą lokalizatora usług, w której jako lokalizatora używa się samego systemu modułów:",
        "Alle diese Varianten haben gemeinsam, dass sie die Abhängigkeit HttpClient explizit anfordern. Dieses Anfordern kann nicht nur an Properties als Default-Value geschehen, sondern auch irgendwo mitten im Code. Da mitten im Code bedeutet, dass es nicht Bestandteil eines Typen-Interfaces ist, ist die Nutzung des HttpClients versteckt. Abhängig der Variante wie der HttpClient angefordert wird, kann es mitunter sehr schwer oder komplett unmöglich sein, diesen durch eine andere Implementierung auszutauschen. Vor allem im Bereich von Unit-Tests und zwecks Übersichtlichkeit kann es hier zu Schwierigkeiten kommen, sodass der Service Locator mittlerweile in bestimmten Situationen als ein Anti-Pattern eingestuft wird.": "Wszystkie te warianty mają tę wspólną cechę, że jawnie żądają zależności HttpClient. Żądanie to może wystąpić nie tylko we właściwościach jako wartość domyślna, ale także gdzieś w środku kodu. Ponieważ w środku kodu oznacza to, że nie jest on częścią interfejsu typu, użycie HttpClient jest ukryte. W zależności od wariantu żądania HttpClient, zastąpienie go inną implementacją może być czasami bardzo trudne lub całkowicie niemożliwe. Szczególnie w obszarze testów jednostkowych i dla jasności, mogą pojawić się tu trudności, tak że lokalizator usług jest obecnie klasyfikowany jako anty-wzorzec w pewnych sytuacjach.",
        "Bei Dependency Injection wird nichts angefordert, sondern es wird explizit vom Nutzer bereitgestellt beziehungsweise von dem Code empfangen. Wie im Beispiel von Inversion of Control zu sehen, ist dort bereits das Dependency Injection Pattern angewendet worden. Konkret ist dort Constructor-Injection zu sehen, da die Abhängigkeit im Constructor deklariert ist. So muss UserRepository nun wie folgt genutzt werden.": "W przypadku metody Dependency Injection nic nie jest żądane, lecz jest jawnie dostarczane przez użytkownika lub odbierane przez kod. Jak widać na przykładzie Inversion of Control, wzorzec wstrzykiwania zależności został już tam zastosowany. W szczególności można tu zaobserwować wstrzykiwanie konstruktora, ponieważ zależność jest zadeklarowana w konstruktorze. Zatem UserRepository musi być teraz używane w następujący sposób.",
        "Der Code, der UserRepository verwenden will, muss auch all seine Abhängigkeiten bereitstellen (injizieren). Ob HttpClient dabei jedes Mal neu erstellt oder jedes Mal derselbe genutzt werden soll, entscheidet nun der User der Klasse und nicht mehr die Klasse selbst. Es wird nicht mehr (aus der Sicht der Klasse) wie beim Service-Locator angefordert oder bei dem initialen Beispiel komplett selbst erstellt. Dieses Invertieren des Flows hat diverse Vorteile:": "Kod, który chce używać UserRepository, musi także dostarczyć (wstrzyknąć) wszystkie jego zależności. O tym, czy HttpClient powinien być tworzony za każdym razem od nowa, czy też za każdym razem powinien być używany ten sam, decyduje teraz użytkownik klasy, a nie sama klasa. Nie jest już ona żądana (z punktu widzenia klasy), jak w przypadku lokalizatora usług, ani - w początkowym przykładzie - tworzona całkowicie przez samą klasę. Takie odwrócenie przepływu ma wiele zalet:",
        "Der Code ist einfacher zu verstehen, da alle Abhängigkeiten explizit sichtbar sind.": "Kod jest łatwiejszy do zrozumienia, ponieważ wszystkie zależności są wyraźnie widoczne.",
        "Der Code ist einfacher zu testen, da alle Abhängigkeiten eindeutig sind und bei Bedarf einfach abgeändert werden können.": "Kod jest łatwiejszy do testowania, ponieważ wszystkie zależności są jasne i w razie potrzeby można je łatwo zmienić.",
        "Der Code ist modularer, da Abhängigkeiten einfach ausgetauscht werden können.": "Kod jest bardziej modularny, ponieważ zależności można łatwo wymieniać.",
        "Es fördert das Separation of Concern Prinzip, da UserRepository nicht mehr dafür verantwortlich ist, im Zweifel sehr komplexe Abhängigkeiten selbst zu erstellen.": "Promuje to zasadę separacji interesów, ponieważ UserRepository nie jest już odpowiedzialne za samodzielne tworzenie bardzo złożonych zależności w razie wątpliwości.",
        "Aber ein offensichtlicher Nachteil kann auch direkt erkannt werden: Muss ich nun wirklich alle Abhängigkeiten wie den HttpClient selbst anlegen bzw. verwalten? Ja und Nein. Ja, es gibt viele Fälle, in denen es völlig legitim ist, die Abhängigkeiten selbst zu verwalten. Eine gute API zeichnet sich dadurch aus, dass Abhängigkeiten nicht ausufern und die Nutzung selbst dann noch angenehm ist. Bei vielen Applikationen oder komplexen Libraries kann dies durchaus der Fall sein. Um eine sehr komplexe low-level API mit vielen Abhängigkeiten vereinfacht dem Nutzer bereitzustellen, sind Facades wunderbar geeignet.": "Jednak oczywistą wadę można dostrzec również bezpośrednio: Czy naprawdę muszę sam tworzyć lub zarządzać wszystkimi zależnościami, takimi jak HttpClient? Tak, istnieje wiele przypadków, w których samodzielne zarządzanie zależnościami jest całkowicie uzasadnione. Dobre API charakteryzuje się tym, że zależności nie wymykają się spod kontroli, a nawet wtedy są przyjemne w użyciu. Może się tak zdarzyć w przypadku wielu aplikacji lub złożonych bibliotek. Fasady znakomicie nadają się do udostępniania użytkownikowi w uproszczony sposób bardzo złożonego, niskopoziomowego interfejsu API z wieloma zależnościami.",
        "Dependency Injection Container": "Kontener wstrzykiwania zależności",
        "Für komplexere Applikationen ist es hingegen nicht nötig alle Abhängigkeiten selbst zu verwalten, denn genau dafür ist ein sogenannter Dependency Injection Container da. Dieser legt nicht nur alle Objekte automatisch an, sondern \"injiziert\" die Abhängigkeiten auch ganz automatisch, sodass ein manueller \"new\" Aufruf nicht mehr notwendig ist. Dabei gibt es diverse Arten des Injizierens wie zum Beispiel Constructor-Injection, Method-Injection, oder Property-Injection. So sind auch komplizierte Konstruktionen mit vielen Abhängigkeiten einfach zu verwalten.": "W przypadku bardziej złożonych aplikacji nie jest jednak konieczne samodzielne zarządzanie wszystkimi zależnościami, ponieważ do tego właśnie służy tzw. kontener wstrzykiwania zależności (ang. dependency injection container). W ten sposób nie tylko automatycznie tworzone są wszystkie obiekty, ale także automatycznie \"wstrzykiwane\" są zależności, dzięki czemu nie jest już konieczne ręczne wywoływanie polecenia \"nowy\". Istnieją różne typy wstrzykiwania, takie jak wstrzykiwanie konstruktora, wstrzykiwanie metody lub wstrzykiwanie właściwości. Ułatwia to zarządzanie nawet skomplikowanymi konstrukcjami z wieloma zależnościami.",
        "Ein Dependency Injection Container (auch DI Container oder IoC Container genannt) bringt Deepkit in `@deepkit/injector` mit oder bereits fertig integriert über App-Module in dem Deepkit Framework. Der obige Code würde mittels eines Low-Level API aus dem Paket `@deepkit/injector` wie folgt aussehen.": "Kontener Dependency Injection (nazywany również kontenerem DI lub kontenerem IoC) jest dostarczany z Deepkitem w `@deepkit/injector` lub jest już zintegrowany poprzez moduły aplikacji we frameworku Deepkit. Powyższy kod wyglądałby tak, gdyby użyto niskopoziomowego API z pakietu `@deepkit/injector`.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Statt mit \"new UserRepository\" liefert der Container eine Instanz von UserRepository mittels `get(UserRepository)` zurück. Um den Container statisch zu initialisieren wird der Funktion `InjectorContext.forProviders` eine Liste von Providern übergeben (in diesem Fall einfach die Klassen).": "Obiektem `injector` jest w tym przypadku kontener wstrzykujący zależności. Zamiast używać \"new UserRepository\", kontener zwraca instancję UserRepository używając `get(UserRepository)`. Aby statycznie zainicjować kontener, do funkcji `InjectorContext.forProviders` przekazywana jest lista dostawców (w tym przypadku są to po prostu klasy).",
        "Da sich bei DI alles um das Bereitstellen von Abhängigkeiten handelt, wird dem Container die Abhängigkeiten bereitgestellt (englisch \"provided\"), daher der Fachbegriff \"Provider\". Es gibt diverse Arten von Provider: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Alle zusammen erlauben es sehr flexible Architekturen mit einem DI container abzubilden.": "Ponieważ DI polega na dostarczaniu zależności, zależności są dostarczane do kontenera, stąd termin techniczny \"dostawca\". Istnieją różne typy dostawców: ClassProvider, ValueProvider, ExistingProvider, FactoryProvider. Wszystkie te elementy razem pozwalają na odwzorowanie bardzo elastycznych architektur za pomocą kontenera DI.",
        "Alle Abhängigkeiten zwischen den Providern werden automatisch aufgelöst und sobald ein `injector.get()` Aufruf stattfindet, werden die Objekte und Abhängigkeiten angelegt, gecacht, und korrekt entweder als Constructor-Argument (Constructor-Injection) übergeben, als Property (Property-Injection) gesetzt, oder einem Methoden-Aufruf (Method-Injection) übergeben.": "Wszystkie zależności między dostawcami są automatycznie rozwiązywane i gdy tylko pojawi się wywołanie `injector.get()`, obiekty i zależności są tworzone, buforowane i poprawnie przekazywane jako argument konstruktora (wstrzyknięcie konstruktora), ustawiane jako właściwość (wstrzyknięcie właściwości) lub przekazywane do wywołania metody (wstrzyknięcie metody).",
        "Um nun den HttpClient mit einem anderen auszutauschen, kann ein anderer Provider (hier der ValueProvider) für HttpClient definiert werden:": "Aby zamienić HttpClient na inny, można zdefiniować dla HttpClient innego dostawcę (tutaj ValueProvider):",
        "Sobald nun UserRepository mittels `injector.get(UserRepository)` angefordert wird, erhält es das AnotherHttpClient Objekt. Alternativ kann hier auch sehr gut ein ClassProvider genutzt werden, sodass alle Abhängigkeiten von AnotherHttpClient ebenfalls vom DI Container verwaltet werden.": "Gdy tylko UserRepository zostanie zażądane przez `injector.get(UserRepository)`, otrzymuje obiekt AnotherHttpClient. Alternatywnie można tutaj również użyć ClassProvider, dzięki czemu wszystkie zależności AnotherHttpClient będą również zarządzane przez kontener DI.",
        "Alle Arten von Providern werden in der Sektion <<dependency-injection-providers>> aufgelistet und erklärt.": "Wszystkie typy dostawców są wymienione i wyjaśnione w sekcji <<dependency-injection-providers>>.",
        "An dieser Stelle sei zu erwähnen, dass Deepkit's DI Container nur mit Runtime Typen von Deepkit funktioniert. Das bedeutet, dass jeder Code, der Klassen, Typen, Interfaces, und Funktionen beinhaltet durch den Deepkit Type Compiler kompiliert werden muss, um so die Typeninformationen zur Laufzeit zur Verfügung zu haben. Siehe dazu das Kapitel <<runtime-types>>.": "Należy tutaj wspomnieć, że kontener DI firmy Deepkit działa tylko z typami runtime firmy Deepkit. Oznacza to, że każdy kod zawierający klasy, typy, interfejsy i funkcje musi zostać skompilowany przez Deepkit Type Compiler, aby informacje o typach były dostępne w czasie wykonywania. Więcej informacji na ten temat można znaleźć w rozdziale <<runtime-types>>.",
        "Dependency Inversion": "Inwersja zależności",
        "Das Beispiel von UserRepository unter Inversion of Control zeigt auf, dass UserRepository von einer niedrigeren Ebene, nämlich einer HTTP library, abhängt. Zusätzlich wird eine konkrete Implementierung (Klasse) statt einer Abstraktion (Interface) als Abhängigkeit deklariert. Dies mag auf den ersten Blick den Objekt-Orientierten Paradigmen entsprechen, kann aber insbesondere in komplexen und grossen Architekturen zu Problemen führen.": "Przykład UserRepository z Inversion of Control pokazuje, że UserRepository zależy od niższego poziomu, a mianowicie od biblioteki HTTP. Ponadto jako zależność deklaruje się konkretną implementację (klasę), a nie abstrakcję (interfejs). Na pierwszy rzut oka może się wydawać, że odpowiada to paradygmatom obiektowym, ale może to prowadzić do problemów, zwłaszcza w przypadku złożonych i dużych architektur.",
        "Eine alternative Variante wäre es, wenn die Abhängigkeit HttpClient in eine Abstraktion (Interface) überführt wird und so kein Code von einer HTTP-Library in UserRepository importiert wird.": "Alternatywnym wariantem byłoby przeniesienie zależności od HttpClient do abstrakcji (interfejsu) i tym samym nie importowanie kodu z biblioteki HTTP do UserRepository.",
        "Dies wird Dependency Inversion Prinzip genannt. UserRepository hat keine Abhängigkeit mehr direkt zu einer HTTP library und basiert stattdessen auf einer Abstraktion (Interface). Es löst damit zwei fundamentale Ziele in diesem Prinzip:": "Jest to tzw. zasada inwersji zależności. UserRepository nie jest już bezpośrednio zależne od biblioteki HTTP, a zamiast tego opiera się na abstrakcji (interfejsie). Rozwiązuje w ten sposób dwa podstawowe cele tej zasady:",
        "High-Level Module sollen nichts aus low-level Modulen importieren.": "Moduły wysokopoziomowe nie powinny importować niczego z modułów niskopoziomowych.",
        "Implementierungen sollen auf Abstraktionen (Interfaces) basieren.": "Implementacje powinny być oparte na abstrakcjach (interfejsach).",
        "Das Zusammenführen der beiden Implementierungen (UserRepository mit einer HTTP-Library) kann nun über den DI Container geschehen.": "Połączenie obu implementacji (UserRepository z biblioteką HTTP) może być teraz wykonane za pomocą kontenera DI Container.",
        "Da Deepkit's DI container in der Lage ist, abstrakte Abhängigkeiten (Interfaces) wie hier von HttpClientInterface aufzulösen, erhält UserRepository automatisch die Implementierung von HttpClient, da HttpClient das Interface HttpClientInterface implementiert hat. Dies geschieht entweder, indem HttpClient ganz konkret HttpClientInterface implementiert (`class HttpClient implements HttpClientInterface`), oder dadurch, dass HttpClient's API schlicht kompatibel zu HttpClientInterface ist.": "Ponieważ kontener DI firmy Deepkit potrafi rozwiązywać abstrakcyjne zależności (interfejsy), takie jak HttpClientInterface, UserRepository automatycznie otrzymuje implementację HttpClient, ponieważ HttpClient zaimplementował interfejs HttpClientInterface. Można to zrobić albo przez HttpClient specjalnie implementując interfejs HttpClientInterface (`class HttpClient implements HttpClientInterface`), albo przez API HttpClienta, które jest po prostu zgodne z interfejsem HttpClientInterface.",
        "Sobald HttpClient seine API abändert (zum Beispiel die Methode `get` entfernt) und so nicht mehr kompatibel zu HttpClientInterface ist, wirft der DI Container einen Fehler (\"die Abhängigkeit HttpClientInterface wurde nicht bereitgestellt\").": "Gdy tylko HttpClient zmieni swoje API (na przykład usunie metodę `get`) i tym samym nie będzie już kompatybilny z HttpClientInterface, kontener DI wyrzuci błąd (\"zależność HttpClientInterface nie została dostarczona\").",
        "Hier ist der User, der beide Implementierungen zusammenbringen will, in der Pflicht eine Lösung zu finden. Als Beispiel könnte hier dann eine Adapter-Klasse registriert werden, die HttpClientInterface implementiert und die Methoden-Aufrufe korrekt an HttpClient weiterleitet.": "W tym przypadku użytkownik, który chce połączyć obie implementacje, jest zobowiązany do znalezienia rozwiązania. Na przykład można tu zarejestrować klasę adaptera, która implementuje interfejs HttpClientInterface i poprawnie przekazuje wywołania metod do HttpClient.",
        "Hier sei zu beachten, dass obwohl in Theorie das Dependency Inversion Prinzip seine Vorteile hat, so hat es in der Praxis auch erhebliche Nachteile. So führt es nicht nur zu mehr Code (da mehr Interfaces geschrieben werden müssen), sondern auch zu mehr Komplexität (da jede Implementierung für jede Abhängigkeit nun ein Interface hat). Dieser zu zahlende Preis lohnt sich erst dann, wenn die Applikation eine gewisse Größe erreicht hat und diese Flexibilität auch gebraucht wird. Wie jedes Design-Pattern und Prinzip hat auch dieses seinen Kosten-Nutzung-Faktor, welche vor seiner Anwendung durchdacht sein sollte.": "Należy zauważyć, że chociaż w teorii zasada odwrócenia zależności ma swoje zalety, w praktyce ma też istotne wady. Prowadzi to nie tylko do zwiększenia ilości kodu (ponieważ trzeba napisać więcej interfejsów), ale także do większej złożoności (ponieważ każda implementacja ma teraz interfejs dla każdej zależności). Ta cena jest opłacalna dopiero wtedy, gdy aplikacja osiągnie pewien rozmiar i potrzebna jest elastyczność. Jak każdy wzorzec projektowy i zasada, także ta ma swój współczynnik kosztu do użycia, który należy przemyśleć przed jej zastosowaniem.",
        "Design-Patterns sollen nicht für jeden noch so simplen Code pauschal und blind genutzt werden. Sind jedoch die Voraussetzungen wie zum Beispiel einer komplexen Architektur, grossen Applikationen, oder eines skalierendes Teams gegeben, entfaltet Dependency Inversion und andere Design-Patterns erst seine wahre Stärke.": "Wzorce projektowe nie powinny być stosowane na ślepo i powszechnie nawet w najprostszym kodzie. Jeśli jednak spełnione są warunki wstępne, takie jak złożona architektura, duże aplikacje lub skalowalny zespół, odwracanie zależności i inne wzorce projektowe dopiero wtedy ujawniają swoją prawdziwą siłę.",
        "Da Dependency Injection in Deepkit auf den Runtime Types basiert, ist es notwendig `@deepkit/type` bereits korrekt installiert zu haben.": "Ponieważ Dependency Injection w Deepkit opiera się na typach Runtime, konieczne jest, aby `@deepkit/type` był już poprawnie zainstalowany.",
        "Falls dies erfolgreich geschehen ist, kann `@deepkit/injector` selbst installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Jeśli to się powiedzie, `@deepkit/injector` może zostać zainstalowany sam lub framework Deepkit, który już używa biblioteki pod maską.",
        "Sobald die Library installiert ist, kann die API davon direkt benutzt werden.": "Po zainstalowaniu biblioteki można bezpośrednio korzystać z jej interfejsu API.",
        "Um Dependency Injection nun zu benutzen, gibt es drei Möglichkeiten.": "Aby użyć teraz metody Dependency Injection, można skorzystać z trzech możliwości.",
        "Injector API (Low Level)": "API wtryskiwacza (poziom niski)",
        "Module API": "Interfejs API modułu",
        "App API (Deepkit Framework)": "Interfejs API aplikacji (struktura Deepkit)",
        "Wenn `@deepkit/injector` ohne das Deepkit Framework benutzt werden soll, empfehlen sich die ersten zwei Varianten.": "Jeśli `@deepkit/injector` ma być używany bez Deepkit Framework, zalecane są dwa pierwsze warianty.",
        "Injector API": "API wtryskiwacza",
        "Die Injector API wurde bereits in der Einführung zu Dependency Injection kennengelernt. Es zeichnet sich durch eine sehr einfache Benutzung mittels einer einzigen Klasse `InjectorContext` aus, die einen einzigen DI Container anlegt und ist besonders geeignet für einfachere Anwendungen ohne Module.": "Interfejs API Injector został już przedstawiony we wprowadzeniu do Wstrzykiwania zależności. Charakteryzuje się bardzo prostą obsługą za pomocą pojedynczej klasy `InjectorContext`, która tworzy pojedynczy kontener DI i jest szczególnie przydatna w prostszych aplikacjach bez modułów.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Die Funktion `InjectorContext.forProviders` nimmt dabei ein Array von Providern entgegen. Siehe die Sektion <<dependency-injection-providers>>, um zu erfahren, welche Werte übergeben werden können.": "W tym przypadku obiekt `injector` jest kontenerem wstrzykiwania zależności. Funkcja `InjectorContext.forProviders` pobiera tablicę dostawców. Zobacz sekcję <<dependency-injection-providers>>, aby dowiedzieć się, jakie wartości można przekazywać.",
        "Eine etwas komplexere API ist die `InjectorModule` Klasse, welche es erlaubt, die Provider in unterschiedlichen Modulen auszulagern, um so mehrere encapsulated DI Container per Module zu erstellen. Auch erlaubt dies das Verwenden von Konfiguration-Klassen per Module, welche es vereinfacht, Konfigurationswerte automatisch validiert den Providern bereitzustellen. Module können sich untereinander importieren, Provider exportieren, um so eine Hierarchie und schön separierte Architektur aufzubauen.": "Nieco bardziej złożonym interfejsem API jest klasa `InjectorModule`, która umożliwia przechowywanie dostawców w różnych modułach w celu utworzenia wielu zamkniętych kontenerów DI na moduł. Umożliwia to również stosowanie klas konfiguracyjnych dla poszczególnych modułów, co ułatwia automatyczne dostarczanie sprawdzonych wartości konfiguracyjnych do dostawców. Moduły mogą się wzajemnie importować i eksportować dostawców, tworząc hierarchię i ładnie odseparowaną architekturę.",
        "Diese API sollte genutzt werden, wenn die Applikation komplexer ist und nicht das Deepkit Framework genutzt wird.": "Tego interfejsu API należy używać, jeśli aplikacja jest bardziej złożona i nie jest wykorzystywany framework Deepkit.",
        "Das `injector` Objekt ist in diesem Fall der Dependency Injection Container. Es können Provider in unterschiedliche Module aufgesplittet werden und dann mittels Module-Imports diese in unterschiedlichen Stellen wieder importiert werden. So entsteht eine natürliche Hierarchie, die die Hierarchie der Anwendung bzw. Architektur abbildet.": "Obiektem `injector` jest w tym przypadku kontener wstrzykujący zależności. Dostawców można podzielić na różne moduły, a następnie zaimportować w różnych miejscach za pomocą importu modułów. W ten sposób powstaje naturalna hierarchia, która odzwierciedla hierarchię aplikacji lub architektury.",
        "Dem InjectorContext sollte dabei immer das oberste Modul in der Hierarchie gegeben werden, auch Root-Module oder App-Module genannt. Der InjectorContext hat hierbei dann nur einen vermittelnden Auftrag: Aufrufe auf `injector.get()` werden schlicht an das Root-Modul weitergeleitet. Es können jedoch auch Provider aus nicht-root Modulen erhalten werden, in dem man das Modul als zweites Argument übergibt.": "Moduł InjectorContext powinien być zawsze przypisany do najwyższego modułu w hierarchii, zwanego również modułem głównym lub modułem aplikacji. InjectorContext ma wtedy tylko zadanie pośredniczące: wywołania funkcji `injector.get()` są po prostu przekazywane do modułu głównego. Dostawców można jednak uzyskać także z modułów niebędących modułami root, przekazując moduł jako drugi argument.",
        "All nicht-root Module sind per default verschlossen (\"encapsulated\"), sodass alle Provider in diesem Modul nur ihm selbst zur Verfügung stehen. Soll ein Provider auch anderen Modulen zur Verfügung stehen, muss dieser Provider exportiert werden. Durch das Exportieren wandert der Provider in das Eltern-Modul der Hierarchie und kann so genutzt werden.": "Wszystkie moduły niebędące modułami root są domyślnie hermetyzowane, dzięki czemu wszyscy dostawcy w tym module są dostępni tylko dla niego samego. Jeżeli provider ma być dostępny także dla innych modułów, musi zostać wyeksportowany. Dzięki eksportowi dostawca zostaje przeniesiony do modułu nadrzędnego w hierarchii i może być używany.",
        "Um alle Provider per default auf die oberste Ebene, dem Root-Module, zu exportieren, kann die Option `forRoot` genutzt werden. Dadurch können alle Provider von allen anderen Modulen genutzt werden.": "Aby domyślnie wyeksportować wszystkich dostawców do najwyższego poziomu, czyli modułu głównego, można użyć opcji `forRoot`. Dzięki temu wszyscy dostawcy mogą być wykorzystywani przez wszystkie inne moduły.",
        "App API": "API aplikacji",
        "Sobald das Deepkit Framework benutzt wird, werden Module mit der `@deepkit/app` API definiert. Diese basiert auf der Module API, sodass die Fähigkeiten von dort ebenfalls verfügbar sind. Zusätzlich ist es möglich mit mächtigen Hooks zu arbeiten sowie Konfiguration-Loader zu definieren, um so noch dynamischere Architekturen abzubilden.": "Po użyciu frameworka Deepkit moduły definiuje się za pomocą interfejsu API `@deepkit/app`. Jest on oparty na interfejsie API modułu, więc dostępne są także jego możliwości. Ponadto możliwe jest korzystanie z zaawansowanych haków i definiowanie mechanizmów ładowania konfiguracji w celu odwzorowania jeszcze bardziej dynamicznych architektur.",
        "In dem Kapitel <<framework-modules>> ist näheres hierzu beschrieben.": "W rozdziale <<framework-modules>> opisano to bardziej szczegółowo.",
        "Providers": "Dostawcy",
        "In dem Dependency Injection Container gibt es mehrere Möglichkeiten Abhängigkeiten bereitzustellen. Die einfachste Variante ist dabei einfach die Angabe einer Klasse. Dies ist auch als short ClassProvider bekannt.": "Istnieje kilka sposobów dostarczania zależności w kontenerze Dependency Injection. Najprostszym wariantem jest po prostu określenie klasy. Jest to również tzw. krótki ClassProvider.",
        "Dies stellt einen speziellen Provider dar, da lediglich die Klasse spezifiziert wird. Alle anderen Provider müssen als Object-Literal angegeben werden.": "Jest to specjalny dostawca, ponieważ określona jest tylko klasa. Wszyscy inni dostawcy muszą być określeni jako literały obiektów.",
        "Standardmäßig sind alle Provider als Singleton markiert, sodass zu jedem Zeitpunkt nur eine Instanz existiert. Um bei jedem Bereitstellen eine neue Instanz anzulegen, kann die Option `transient` genutzt werden. Dies führt dazu, dass Klassen jedes Mal neu erstellt werden oder Factories jedes Mal neu ausgeführt werden.": "Domyślnie wszyscy dostawcy są oznaczeni jako singleletons, czyli w danym momencie istnieje tylko jedna instancja. Aby utworzyć nową instancję za każdym razem, gdy jest ona przekazywana, można użyć opcji `transient`. Spowoduje to, że za każdym razem będą tworzone klasy lub będą wykonywane fabryki.",
        "ClassProvider": "ClassProvider",
        "Neben dem short ClassProvider gibt es auch den regulären ClassProvider, welches ein Object-Literal statt einer Klasse ist.": "Oprócz krótkiego ClassProvider istnieje również zwykły ClassProvider, który jest literałem obiektu, a nie klasą.",
        "Dies ist Äquivalent zu diesen beiden:": "Jest to równoważne z tymi dwoma:",
        "Es kann genutzt werden, um einen Provider mit einer anderen Klasse auszutauschen.": "Można go użyć do wymiany dostawcy z inną klasą.",
        "In diesem Beispiel wird die Klasse `OtherUserRepository` nun ebenfalls in dem DI Container verwaltet und all seine Abhängigkeiten automatisch aufgelöst.": "W tym przykładzie klasa `OtherUserRepository` jest teraz również zarządzana w kontenerze DI, a wszystkie jej zależności są automatycznie rozwiązywane.",
        "ValueProvider": "ValueProvider",
        "Statische Werte können mit diesem Provider bereitgestellt werden.": "W przypadku tego dostawcy można podać wartości statyczne.",
        "Da nicht nur Klassen-Instanzen als Abhängigkeiten bereitgestellt werden können, kann als `useValue` ein beliebiger Wert angegeben werden. Als Provider-Token könnte auch ein Symbol oder ein Primitive (string, number, boolean) genutzt werden.": "Ponieważ nie tylko instancje klas mogą być przekazywane jako zależności, jako `useValue` można podać dowolną wartość. Jako token dostawcy można również użyć symbolu lub elementu pierwotnego (ciąg znaków, liczba, boolean).",
        "Primitive Provider-Tokens müssen mit dem Inject-Typen als Abhängigkeit deklariert werden.": "Tokeny dostawcy prymitywnego muszą być zadeklarowane z typem wtrysku jako zależnością.",
        "Mit der Kombination aus einem Inject-Alias und primitive Provider-Tokens können auch Abhängigkeiten aus Paketen bereitgestellt, die keine Runtime-Typeninformationen beinhalten.": "Dzięki połączeniu aliasu inject i prymitywnych tokenów dostawcy, zależności mogą być również dostarczane z pakietów, które nie zawierają informacji o typie runtime.",
        "Und dann auf der Nutzerseite wie folgt deklariert werden:": "Następnie należy je zadeklarować po stronie użytkownika w następujący sposób:",
        "ExistingProvider": "ExistingProvider",
        "Es kann eine Weiterleitung zu einem bereits definierten Provider definiert werden.": "Można zdefiniować przekierowanie do już zdefiniowanego dostawcy.",
        "FactoryProvider": "FactoryProvider",
        "Es kann eine Funktion genutzt werden, um einen Wert für den Provider bereitzustellen. Diese Funktion kann auch Parameter beinhalten, die wiederum von dem DI Container bereitgestellt werden. So sind andere Abhängigkeiten oder Konfiguration-Optionen zugreifbar.": "Funkcji można użyć do podania wartości dla dostawcy. Funkcja ta może również zawierać parametry, które z kolei są przekazywane przez kontener DI. W ten sposób można uzyskać dostęp do innych zależności lub opcji konfiguracyjnych.",
        "InterfaceProvider": "InterfaceProvider",
        "Neben Klassen und Primitives können auch Abstraktionen (Interfaces) bereitgestellt werden. Dies geschieht über die Funktion `provide` und ist dann besonders sinnvoll, wenn der zu bereitstellende Wert keine Typeninformationen beinhaltet.": "Oprócz klas i prymitywów można również udostępniać abstrakcje (interfejsy). Odbywa się to za pomocą funkcji `provide` i jest szczególnie przydatne, gdy przekazywana wartość nie zawiera żadnych informacji o typie.",
        "Wenn mehrere Provider das Interface Connection implementiert haben, wird der letzte Provider genutzt.": "Jeśli kilku dostawców zaimplementowało interfejs Połączenie, używany jest ostatni dostawca.",
        "Als Argument für provide() sind alle anderen Provider möglich.": "Wszystkie inne providery są możliwe jako argumenty funkcji provide().",
        "Constructor/Property Injection": "Wstrzykiwanie konstruktora/właściwości",
        "In den meisten Fällen wird Constructor-Injection verwendet. Alle Abhängigkeiten werden dabei als Constructor-Argumente angegeben und werden vom DI Container automatisch injiziert.": "W większości przypadków stosuje się wstrzykiwanie konstruktora. Wszystkie zależności są określane jako argumenty konstruktora i są automatycznie wstrzykiwane przez kontener DI.",
        "Optionale Abhängigkeiten sollten als solche gekennzeichnet werden, da sonst ein Fehler ausgelöst werden könnte, wenn kein Provider gefunden werden kann.": "Zależności opcjonalne powinny być oznaczone jako takie, w przeciwnym razie może zostać wywołany błąd, jeśli nie zostanie znaleziony żaden dostawca.",
        "Eine Alternative zur Constructor-Injection ist die Property-Injection. Diese wird in der Regel verwendet, wenn die Abhängigkeit optional oder der Constructor sonst zu voll ist. Die Properties werden automatisch zugewiesen, sobald die Instanz erstellt ist (und damit der Constructor ausgeführt wurde).": "Alternatywą dla wstrzykiwania konstruktora jest wstrzykiwanie właściwości. Jest to zwykle stosowane, gdy zależność jest opcjonalna lub konstruktor jest z innych powodów zbyt pełny. Właściwości są przypisywane automatycznie, gdy tylko instancja zostanie utworzona (a więc gdy zostanie wykonany konstruktor).",
        "Konfiguration": "Konfiguracja",
        "Der Dependency Injection Container erlaubt auch das Injizieren von Konfigurationsoptionen. Diese Configuration-Injection kann via Constructor-Injection oder Property-Injection empfangen werden.": "Kontener Dependency Injection umożliwia także wstrzykiwanie opcji konfiguracyjnych. Taki zastrzyk konfiguracji można otrzymać poprzez wstrzyknięcie konstruktora lub właściwości.",
        "Die Module API unterstützt dabei das Definieren einer Konfiguration-Definition, welche eine reguläre Klasse ist. Durch das Bereitstellen solch einer Klasse mit Properties agiert jedes Property als Konfiguration-Option. Durch die Art und Weise wie in TypeScript Klassen definiert werden können, erlaubt dies das Definieren eines Types und Default-Values pro Property.": "Interfejs API modułu obsługuje definicję konfiguracji, która jest zwykłą klasą. Dzięki wyposażeniu takiej klasy we właściwości każda z nich pełni rolę opcji konfiguracyjnej. Ze względu na sposób definiowania klas w języku TypeScript, pozwala to na określenie typu i wartości domyślnych dla każdej właściwości.",
        "Die Konfigurationsoptionen `domain` und `debug` können nun ganz bequem typen-sicher in Providern genutzt werden.": "Opcje konfiguracyjne `domain` i `debug` mogą być teraz wygodnie używane w bezpiecznych typach dostawców.",
        "Die Werte der Optionen selbst können über `configure()` gesetzt werden.": "Wartości samych opcji można ustawić za pomocą funkcji `configure()`.",
        "Optionen, die keinen Default-Value haben, aber trotzdem notwendig sind, können mit einem `!` versehen werden. Dies zwingt den User des Modules dazu, den Wert bereitzustellen, da ansonsten es zu einem Fehler kommt.": "Opcje, które nie mają wartości domyślnej, a mimo to są niezbędne, można podać za pomocą znaku `!`. Zmusza to użytkownika modułu do podania wartości, w przeciwnym razie zostanie wyświetlony błąd.",
        "Auch können alle Serialization und Validation Typen aus den vorherigen Kapiteln <<validation>> und <<serialisation>> genutzt werden, um so sehr detailliert festzulegen, welchen Typ und inhaltliche Einschränkungen eine Option haben muss.": "Ponadto, wszystkie typy serializacji i walidacji z poprzednich rozdziałów <<walidacja>> i <<serializacja>> mogą być użyte do bardzo szczegółowego określenia ograniczeń typu i zawartości, jakie musi mieć opcja.",
        "Injection": "Wtrysk",
        "Konfigurationsoptionen können wie bereits gezeigt wie andere Abhängigkeiten sicher und einfach durch den DI Container injiziert werden. Als einfachste Methode ist das Referenzieren einer einzigen Option mittels dem Index-Access Operators:": "Opcje konfiguracyjne, podobnie jak inne zależności, mogą być bezpiecznie i łatwo wstrzykiwane przez kontener DI, jak pokazano wcześniej. Najprostszą metodą jest odwołanie się do pojedynczej opcji za pomocą operatora dostępu do indeksu:",
        "Es können Konfigurationsoptionen nicht nur einzeln, sondern auch als Gruppe referenziert werden. Hierzu wird der TypeScript Utility-Typ `Partial` genutzt:": "Do opcji konfiguracyjnych można odwoływać się nie tylko pojedynczo, ale także grupowo. Do tego celu służy typ użytkowy TypeScript `Partial`:",
        "Um alle Konfigurationsoptionen zu erhalten, kann auch die Konfigurationsklasse direkt referenziert werden:": "Aby uzyskać wszystkie opcje konfiguracyjne, można również bezpośrednio odwołać się do klasy konfiguracji:",
        "Es wird jedoch empfohlen nur die Konfigurationsoptionen zu referenzieren, die auch wirklich genutzt werden. Das vereinfacht nicht nur Unit-Tests, sondern lässt auch einfacher einsehen, was nun konkret von dem Code gebraucht wird.": "Zaleca się jednak, aby odwoływać się tylko do tych opcji konfiguracyjnych, które są rzeczywiście używane. Nie tylko upraszcza to testy jednostkowe, ale także ułatwia sprawdzenie, co jest rzeczywiście potrzebne w kodzie.",
        "Scopes": "Lunety",
        "Per Default sind alle Provider des DI Containers ein Singleton und werden dadurch nur einmal instantiiert. Das bedeutet in dem Beispiel von UserRepository gibt es immer nur eine Instanz von UserRepository während der gesamten Laufzeit. Zu keinem Zeitpunkt wird eine zweite Instanz erzeugt, außer der User macht dies manuell mit dem \"new\" Keyword.": "Domyślnie wszystkie providery kontenera DI są singletonami i dlatego są instancjonowane tylko raz. Oznacza to, że w przykładzie UserRepository zawsze istnieje tylko jedna instancja UserRepository podczas całego czasu działania. W żadnym momencie nie jest tworzona druga instancja, chyba że użytkownik zrobi to ręcznie, używając słowa kluczowego \"new\".",
        "Nun gibt es jedoch diverse Anwendungsfälle, in denen ein Provider nur für eine kurze Zeit instantiiert werden soll oder nur während eines bestimmten Ereignisses. Solch ein Ereignis könnte zum Beispiel ein HTTP-Request oder ein RPC-Call sein. Dies würde dann bedeuten, dass pro Ereignis jedes Mal eine neue Instanz erstellt wird und nachdem diese Instanz nicht mehr benutzt wird diese automatisch entfernt wird (durch den Garbage-Collector).": "Istnieją jednak różne przypadki użycia, w których dostawca powinien być tworzony tylko przez krótki czas lub tylko podczas określonego zdarzenia. Takim zdarzeniem może być na przykład żądanie HTTP lub wywołanie RPC. Oznaczałoby to, że za każdym razem, gdy wystąpi zdarzenie, tworzona jest nowa instancja, a gdy ta instancja nie jest już używana, jest automatycznie usuwana (przez garbage collector).",
        "Ein HTTP-Request ist ein klassisches Beispiel für einen Scope. So können zum Beispiel Provider wie eine Session, ein User-Objekt, oder andere Request-bezogenen Provider auf diesen Scope registriert werden. Um einen Scope zu erstellen, wird lediglich ein beliebiger Scopename gewählt und dann bei den Providern angegeben.": "Żądanie HTTP jest klasycznym przykładem zakresu. Na przykład do tego zakresu można zarejestrować dostawców takich jak sesja, obiekt użytkownika lub innych dostawców związanych z żądaniami. Aby utworzyć zakres, wystarczy wybrać dowolną nazwę zakresu, a następnie określić go za pomocą dostawców.",
        "Sobald ein Scope angegeben ist, ist dieser Provider nicht mehr direkt über den DI Container zu erhalten, sodass folgender Aufruf fehlschlägt:": "Gdy tylko zostanie określony zakres, nie można już uzyskać tego dostawcy bezpośrednio przez kontener DI, więc poniższe wywołanie kończy się niepowodzeniem:",
        "Stattdessen muss ein scoped DI Container erstellt werden. Dies würde jedes Mal geschehen sobald ein HTTP-Request reinkommt:": "Zamiast tego należy utworzyć kontener DI o określonym zakresie. Będzie się to działo za każdym razem, gdy nadejdzie żądanie HTTP:",
        "Auf diesen scoped DI Container können nun auch Provider angefordert werden, die in diesem Scope auch registriert sind, sowie alle Provider die keinen Scope definiert haben.": "Do tego kontenera DI można teraz zgłaszać żądania od dostawców, którzy również są zarejestrowani w tym zakresie, a także od wszystkich dostawców, którzy nie zdefiniowali zakresu.",
        "Da alle Provider per default Singleton sind, wird auch hier jeder Aufruf zu `get(UserSession)` immer dieselbe Instanz pro scoped Container zurückgeben. Erstellt man mehrere scoped Container werden auch mehrere UserSession angelegt.": "Ponieważ wszystkie providery są domyślnie singletonami, każde wywołanie `get(UserSession)` zawsze zwróci tę samą instancję dla kontenera scoped. Jeśli zostanie utworzonych kilka kontenerów tematycznych, zostanie również utworzonych kilka sesji UserSessions.",
        "Applikationen, die mit dem Deepkit Framework arbeiten, haben per default einen `http`, einen `rpc`, und einen `cli` Scope. Siehe dazu jeweils das Kapitel <<cli>>, <<http>>, oder <<rpc>>.": "Aplikacje działające z Deepkit Framework mają domyślnie zakresy `http`, `rpc` i `cli`. Zobacz rozdział <<cli>>, <<http>> lub <<rpc>>.",
        "Setup Calls": "Konfiguracja połączeń",
        "Setup-Calls erlauben es das Ergebnis eines Providers zu manipulieren. Das ist nützlich um zum Beispiel eine weitere Dependency Injection Variante, das Method-Injection, zu nutzen.": "Wywołania konfiguracji umożliwiają manipulowanie wynikiem działania dostawcy. Jest to przydatne na przykład do stosowania innego wariantu wstrzykiwania zależności - wstrzykiwania metod.",
        "Setup-Calls sind nur mit der Modul-API beziehungsweise der App-API nutzbar und werden über dem Modul registriert.": "Wywołań konfiguracyjnych można używać tylko z interfejsem API modułu lub interfejsem API aplikacji i są one rejestrowane powyżej modułu.",
        "Die Methode `setupProvider` gibt dabei ein Proxy-Objekt von UserRepository zurück, auf welchem seine Methoden aufgerufen werden können. Zu beachten ist, dass diese Methoden-Aufrufen lediglich in eine Warteschlange platziert werden und zu diesem Zeitpunkt nicht ausgeführt werden. Entsprechend gibt es auch kein Return-Value zurück.": "Metoda `setupProvider` zwraca obiekt proxy UserRepository, na którym mogą być wywoływane jego metody. Należy zauważyć, że te wywołania metod są jedynie umieszczane w kolejce i nie są w tym momencie wykonywane. W związku z tym nie jest zwracana żadna wartość zwrotna.",
        "Neben Methoden-Aufrufen können auch Properties gesetzt werden.": "Oprócz wywoływania metod można również ustawiać właściwości.",
        "Auch diese Zuweisung wird lediglich in einer Warteschlange platziert.": "To zadanie jest również po prostu umieszczane w kolejce.",
        "Die Aufrufe beziehungsweise die Zuweisungen in der Warteschlange werden dann auf das eigentliche Resultat des Providers ausgeführt, sobald dieser erstellt wird. Das heisst bei einem ClassProvider werden diese auf die Klassen-Instanz angewendet, sobald die Instanz erstellt wird, bei einem FactoryProvider auf das Resultat der Factory, und bei einem ValueProvider auf den Provider.": "Wywołania lub zadania w kolejce są następnie wykonywane na rzeczywistym wyniku dostawcy, gdy tylko zostanie on utworzony. Oznacza to, że w przypadku ClassProvider są one stosowane do instancji klasy zaraz po jej utworzeniu, w przypadku FactoryProvider - do wyniku działania fabryki, a w przypadku ValueProvider - do dostawcy.",
        "Um nicht nur statische Werte, sondern auch andere Provider zu referenzieren kann die Funktion `injectorReference` verwendet werden. Diese gibt eine Referenz zu einem Provider zurück, welcher beim Ausführen der Setup-Calls ebenfalls vom DI Container angefordert wird.": "Aby odwoływać się nie tylko do wartości statycznych, ale także do innych dostawców, można użyć funkcji `injectorReference`. Zwraca to referencję do dostawcy, który jest również żądany przez kontener DI podczas wykonywania poleceń konfiguracji.",
        "*Abstractions/Interfaces*": "*Abstrakcje/Interfejsy*.",
        "Es können auch Setup-Calls einem Interface zugewiesen werden.": "Wywołania konfiguracji można również przypisać do interfejsu.",
        "CLI": "CLI",
        "Command-line Interface (CLI) Programme sind Programme, die über das Terminal in Form von Text-Eingabe und Text-Ausgabe interagieren. Der Vorteil in dieser Variante mit der Anwendung zu interagieren, ist, dass lediglich ein Terminal entweder lokal oder über eine SSH-Verbindung bestehen muss.": "Programy z interfejsem wiersza poleceń (CLI) to programy, które komunikują się z użytkownikiem za pośrednictwem terminala w postaci tekstu wprowadzanego i wyprowadzanego. Zaletą interakcji z aplikacją w tym wariancie jest to, że potrzebny jest tylko terminal - lokalny lub przez połączenie SSH.",
        "Eine CLI-Anwendung in Deepkit hat den vollen Zugriff auf den DI-Container und kann so auf alle Provider und Konfigurationsoptionen zugreifen.": "Aplikacja CLI w Deepkit ma pełny dostęp do kontenera DI, a zatem może uzyskać dostęp do wszystkich dostawców i opcji konfiguracyjnych.",
        "Die Argumente und Optionen der CLI-Anwendung werden über Methoden-Parameter via TypeScript Typen gesteuert und werden automatisch serialisiert und validiert.": "Argumenty i opcje aplikacji CLI są kontrolowane przez parametry metod za pomocą typów TypeScript i są automatycznie serializowane i walidowane.",
        "CLI ist einer von drei Einstiegspunkten zu einer Deepkit Framework Anwendung. Im Deepkit Framework wird die Anwendung immer über ein CLI-Program gestartet, das selbst vom User in TypeScript geschrieben ist. Es gibt daher keine Deepkit spezifisches globales CLI tool, um eine Deepkit Anwendung zu starten. Auf diese Weise starten Sie den HTTP/RPC-Server, führen Migrationen aus oder führen eigene Befehle aus. Das alles geschieht über denselben Einstiegspunkt, dieselbe Datei. Sobald das Deepkit Framework durch den Import von `FrameworkModule` aus `@deepkit/framework` benutzt wird, erhält die Anwendung zusätzliche Commands für den Application Server, Migrations, und mehr.": "CLI jest jednym z trzech punktów wejścia do aplikacji Deepkit Framework. W Deepkit Framework aplikacja jest zawsze uruchamiana za pomocą programu CLI, który sam jest napisany w języku TypeScript przez użytkownika. Nie istnieje zatem globalne narzędzie CLI do uruchamiania aplikacji Deepkit, specyficzne dla programu Deepkit. W ten sposób uruchamia się serwer HTTP/RPC, wykonuje migracje lub uruchamia własne polecenia. Wszystko to odbywa się za pośrednictwem tego samego punktu wejścia, tego samego pliku. Po użyciu frameworka Deepkit poprzez zaimportowanie `FrameworkModule` z `@deepkit/framework`, aplikacja otrzymuje dodatkowe polecenia dla serwera aplikacji, migracji i innych.",
        "Das CLI-Framework erlaubt es auf einfache Art eigene Commands zu registrieren und basiert dabei auf einfachen Klassen. Tatsächlich basiert es auf `@deepkit/app`, einem kleinen Paket, das nur für diesen Zweck gedacht ist und auch eigenständig ohne das Deepkit Framework verwendet werden kann. In diesem Paket finden sich Decorators, die benötigt werden, um die CLI-Controller-Klasse zu dekorieren.": "Szkielet CLI umożliwia łatwe rejestrowanie własnych poleceń i jest oparty na prostych klasach. W rzeczywistości jest on oparty na `@deepkit/app`, małym pakiecie, który jest przeznaczony tylko do tego celu i może być również używany niezależnie bez frameworka Deepkit. W tym pakiecie znajdują się dekoratory, które są potrzebne do dekorowania klasy kontrolera CLI.",
        "Controller werden vom Dependency Injection Container verwaltet beziehungsweise instanziiert und können daher andere Provider verwenden. Siehe das Kapitel <<dependency-injection>> für weitere Details.": "Kontrolery są zarządzane lub inicjowane przez kontener Dependency Injection i dlatego mogą korzystać z innych dostawców. Więcej informacji na ten temat znajduje się w rozdziale <<wstrzykiwanie zależności>>.",
        "Da CLI-Programme in Deepkit auf den Runtime Types basieren, ist es notwendig @deepkit/type bereits korrekt installiert zu haben. Siehe dazu <<runtime-types-installation>>.": "Ponieważ programy CLI w Deepkit bazują na typach runtime, konieczne jest, aby @deepkit/type był już poprawnie zainstalowany. Zobacz <<runtime-types-installation>>.",
        "Falls dies erfolgreich geschehen ist, kann @deepkit/app installiert werden oder das Deepkit Framework welches die Library bereits unter der Haube benutzt.": "Jeśli to się uda, można zainstalować @deepkit/app lub framework Deepkit, który już używa biblioteki pod maską.",
        "Zu beachten ist, dass `@deepkit/app` auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss.": "Zwróć uwagę, że `@deepkit/app` jest oparty na dekoratorach TypeScript i ta właściwość musi być odpowiednio aktywowana za pomocą `experimentalDecorators`.",
        "Um einen Befehl für Ihre Anwendung zu erstellen, müssen Sie einen CLI-Controller erstellen. Dabei handelt es sich um eine einfache Klasse, die eine Methode `exeecute` hat und mit Informationen über den Befehl ausgestattet ist.": "Aby utworzyć polecenie dla aplikacji, należy utworzyć kontroler CLI. Jest to prosta klasa, która posiada metodę `exeecute` i jest wyposażona w informacje o poleceniu.",
        "_Datei: app.ts_": "_Plik: app.ts_",
        "In dem Decorator `@cli.controller` wird als erstes Argument der eindeutige Name der CLI-Anwendung definiert. Weitere Optionen wie eine Beschreibung können im Objekt an der zweiten Stelle optional hinzufügt werden.": "W dekoratorze `@cli.controller` jako pierwszy argument zdefiniowana jest unikalna nazwa aplikacji CLI. W obiekcie na drugiej pozycji można opcjonalnie dodać dalsze opcje, takie jak opis.",
        "Dieser Code ist bereits eine komplette CLI-Anwendung und kann so gestartet werden:": "Ten kod jest już kompletną aplikacją CLI i może być uruchomiony w ten sposób:",
        "Zu sehen ist, dass ein \"test\" Command verfügbar ist. Um dieses auszuführen, muss der Name als Argument übergeben werden:": "Widać, że dostępne jest polecenie \"test\". Aby wykonać tę operację, należy przekazać nazwę jako argument:",
        "Es ist auch möglich, die Datei mittels `chmod +x app.ts` ausführbar zu machen, sodass der Command `./app.ts` bereits ausreicht, um es zu starten. Zu beachten ist, dass dann ein sogenannter": "Możliwe jest również uczynienie pliku wykonywalnym za pomocą `chmod +x app.ts`, tak aby do jego uruchomienia wystarczyło polecenie `./app.ts`. Należy zauważyć, że tzw.",
        "Shebang notwendig ist. Shebang bezeichnet die Zeichenkombination `#!` am Anfang eines Skriptprogramms. In dem Beispiel oben ist dies bereits vorhanden: `&#35;!/usr/bin/env ts-node-script` und nutzt den Skript-Modus von `ts-node`.": "Shebang jest niezbędny. Shebang oznacza kombinację znaków `#!` na początku programu skryptowego. W powyższym przykładzie jest to już obecne: `&#35;!/usr/bin/env ts-node-script` i używa trybu skryptowego `ts-node`.",
        "Auf diese Weise können beliebig viele Commands erstellt und registriert werden. Der in `@cli.controller` angegeben eindeutige Name sollte gut gewählt werden und erlaubt das Gruppieren von Commands mit dem `:` Zeichen (z.B. `user:create`, `user:remove`, etc).": "W ten sposób można utworzyć i zarejestrować dowolną liczbę poleceń. Unikalna nazwa podana w `@cli.controller` powinna być dobrze dobrana i umożliwiać grupowanie poleceń za pomocą znaku `:` (np. `user:create`, `user:remove`, itd.).",
        "Argumente": "Argumenty",
        "Um Argumente hinzuzufügen, werden neue Parameter auf die Methode `execute` hinzugefügt und mit dem Decorator `@arg` dekoriert.": "Aby dodać argumenty, nowe parametry są dodawane do metody `execute` i dekorowane dekoratorem `@arg`.",
        "Wenn Sie diesen Befehl jetzt ausführen, ohne einen Namen anzugeben, wird ein Fehler ausgegeben:": "Jeśli teraz wykonasz to polecenie bez podania nazwy, zostanie wyświetlony błąd:",
        "Durch die Verwendung von `--help` erhalten Sie weitere Informationen über die erforderlichen Argumente:": "Użycie `--help` pozwoli uzyskać więcej informacji o wymaganych argumentach:",
        "Sobald der Name als Argument übergeben wird, wird die Methode `execute` in TestCommand ausgeführt und der Name korrekt übergeben.": "Gdy tylko nazwa zostanie przekazana jako argument, metoda `execute` w TestCommand zostanie wykonana, a nazwa zostanie przekazana poprawnie.",
        "Flags": "Flagi",
        "Flags sind eine weitere Möglichkeit, Ihrem Befehl Werte zu übergeben. Meist sind diese Optional, doch müssen es nicht sein. Parameter, die mit `@flag name` dekoriert sind, können via `--name value` oder `--name=value` übergeben werden.": "Flagi to kolejny sposób przekazywania wartości do polecenia. W większości przypadków są one opcjonalne, ale nie muszą być. Parametry ozdobione `@flag nazwa` mogą być przekazywane przez `--nazwa wartość` lub `--nazwa=wartość`.",
        "In der Hilfe-Ansicht ist in den \"OPTIONS\" nun zu sehen, dass ein `--id` Flag notwendig ist. Gibt man dieses Korrekt an, erhält der Command diesen Wert.": "W widoku pomocy można teraz zobaczyć w \"OPCJACH\", że konieczna jest flaga `--id`. Jeśli zostanie to wprowadzone poprawnie, polecenie otrzyma tę wartość.",
        "Boolean Flags": "Boolean Flagi",
        "Flags haben den Vorteil, dass sie auch als wertlosen Flag verwendet werden können, um so zum Beispiel ein bestimmtes Verhalten zu aktivieren. Sobald ein Parameter als optionaler Boolean markiert ist, wird dieses Verhalten aktiviert.": "Flagi mają tę zaletę, że można ich także używać jako bezwartościowych flag, na przykład w celu aktywowania określonego zachowania. Gdy tylko parametr zostanie oznaczony jako opcjonalny Boolean, zachowanie to zostanie uaktywnione.",
        "Multiple Flags": "Wiele flag",
        "Um mehrere Werte demselben Flag zu übergeben, kann ein Flag als Array markiert werden.": "Aby przekazać kilka wartości do tej samej flagi, można ją oznaczyć jako tablicę.",
        "Single Character Flags": "Flagi jednoznakowe",
        "Um einem Flag zu erlauben, auch als ein einzelner Charakter übergeben zu werden, kann `@flag.char('x')` genutzt werden.": "Aby umożliwić przekazanie flagi również jako pojedynczego znaku, można użyć `@flag.char('x')`.",
        "Optional / Default": "Opcjonalne / Domyślne",
        "Die Signatur der Methode `execute` definiert, welche Argument oder Flags optional sind. Ist der Parameter als Optional markiert, so muss er nicht angegeben werden.": "Sygnatura metody `execute` określa, które argumenty lub flagi są opcjonalne. Jeśli parametr jest oznaczony jako opcjonalny, nie trzeba go podawać.",
        "Dasselbe für Parameter mit einem Default-Wert:": "To samo dotyczy parametrów z wartością domyślną:",
        "Dies gilt auch für Flags in derselben Art und Weise.": "W ten sam sposób dotyczy to również flag.",
        "Serialization / Validation": "Serializacja / walidacja",
        "Alle Argumente und Flags werden automatisch basierend auf dessen Typen deserialisiert, validiert und können mit zusätzlichen Einschränkungen versehen werden.": "Wszystkie argumenty i flagi są automatycznie deserializowane na podstawie ich typów, walidowane i mogą być opatrzone dodatkowymi ograniczeniami.",
        "So sind Argument, die als Number definiert sind, in dem Controller auch garantiert immer eine echte Nummer, obwohl das Command-Line Interface auf Text und somit Strings basiert. Die Umwandlung passiert dabei automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "W ten sposób argumenty zdefiniowane jako liczby mają zawsze gwarancję, że będą liczbami rzeczywistymi w sterowniku, nawet jeśli interfejs wiersza poleceń jest oparty na tekście, a więc na łańcuchach. Konwersja odbywa się automatycznie dzięki funkcji <<serializacja-luźna-konwersja>>.",
        "Zusätzliche Einschränkungen können mit den Typen-Decorators aus `@deepkit/type` definiert werden.": "Dodatkowe ograniczenia można zdefiniować za pomocą dekoratorów typów z `@deepkit/type`.",
        "Der Typ `Postive` bei `id` gibt an, dass nur positive Nummern gewollt sind. Übergibt der User nun eine negative Zahl, so wird der Code in `execute` gar nicht erst ausgeführt und es wird eine Fehlermeldung präsentiert.": "Typ `Postive` w `id` wskazuje, że poszukiwane są tylko liczby dodatnie. Jeśli użytkownik wprowadzi liczbę ujemną, kod w `execute` nie zostanie wykonany i zostanie wyświetlony komunikat o błędzie.",
        "Bei einer positiven Nummer funktioniert dies dann wieder wie zuvor. Durch diese zusätzliche sehr einfach zu bewerkstelligende Validierung, wird der Command deutlich robuster gegen Falscheingaben geschützt. Sieh dazu das Kapitel <<validation>> für mehr Informationen.": "Jeśli liczba ta jest dodatnia, polecenie działa tak jak poprzednio. To dodatkowe sprawdzanie poprawności, które jest bardzo łatwe do przeprowadzenia, sprawia, że polecenie jest znacznie bardziej odporne na błędne wpisy. Więcej informacji na ten temat można znaleźć w rozdziale <<walidacja>>.",
        "Description": "Opis",
        "Um einen Flag oder Argument zu beschreiben, kann `@flag.description` beziehungsweise `@arg.description` genutzt werden.": "Aby opisać flagę lub argument, można użyć `@flag.description` lub `@arg.description`.",
        "In der Hilfe-Ansicht erscheint diese Beschreibung hinter dem Flag beziehungsweise Argument:": "W widoku pomocy opis ten jest wyświetlany za flagą lub argumentem:",
        "Exit code": "Kod wyjścia",
        "Der Exit-Code ist standardmäßig 0, was bedeutet, dass der Befehl erfolgreich ausgeführt wurde. Um den Exit-Code zu ändern, sollten in der `exucute`-Methode eine Zahl ungleich 0 zurückgeben werden.": "Domyślnym kodem wyjścia jest 0, co oznacza, że polecenie zostało wykonane pomyślnie. Aby zmienić kod wyjścia, w metodzie `exucute` należy zwrócić liczbę inną niż 0.",
        "Die Klasse des Commands wird vom DI Container verwaltet, sodass Abhängigkeiten definiert werden können, die über den DI Container aufgelöst werden.": "Klasa polecenia jest zarządzana przez DI Container, dzięki czemu można zdefiniować zależności, które są rozwiązywane za pośrednictwem DI Container.",
        "HTTP": "HTTP",
        "HTTP-Abfragen zu bearbeiten ist mitunter die bekannteste Aufgabe für einen Server. Er wandelt dabei einen Input (HTTP-Request) in einen Output (HTTP-Response) um und führt dabei eine bestimmte Aufgabe aus. Ein Client kann dabei über einem HTTP-Request auf vielfältige Art und Weisen Daten an den Server senden, die korrekt ausgelesen und behandelt werden müssen. So sind neben dem HTTP-Body auch HTTP-Query oder HTTP-Header Werte möglich. Wie Daten konkret verarbeitet werden, hängt vom Server ab. Er ist es, der definiert, wo und wie die Werte vom Client zu senden sind.": "Przetwarzanie żądań HTTP jest jednym z najbardziej znanych zadań serwera. Przekształca on dane wejściowe (żądanie HTTP) w dane wyjściowe (odpowiedź HTTP) i wykonuje określone zadanie. Klient może na różne sposoby wysyłać do serwera dane za pomocą żądania HTTP, które muszą zostać odczytane i poprawnie obsłużone. Oprócz treści HTTP możliwe są również wartości zapytania HTTP lub nagłówka HTTP. To, w jaki sposób dane są faktycznie przetwarzane, zależy od serwera. To serwer określa, gdzie i w jaki sposób wartości mają być wysyłane przez klienta.",
        "Hierbei ist oberste Priorität nicht nur das korrekt auszuführen, was der User erwartet, sondern jeglichen Input aus dem HTTP-Request korrekt umzuwandeln (deserialisieren) und zu validieren.": "Priorytetem jest nie tylko prawidłowe wykonanie tego, czego oczekuje użytkownik, ale także prawidłowa konwersja (deserializacja) i walidacja danych wejściowych z żądania HTTP.",
        "Die Pipeline, in der ein HTTP-Request auf dem Server durchläuft, kann vielfältig und komplex sein. Viele einfache HTTP-Libraries übergeben für eine bestimmte Route lediglich den HTTP-Request und die HTTP-Response, und erwarten vom Entwickler, den HTTP-Response direkt zu bearbeiten. Eine Middleware-API erlaubt dabei die Pipeline beliebig zu erweitern.": "Rurociąg, przez który przechodzi żądanie HTTP na serwerze, może być różnorodny i złożony. Wiele prostych bibliotek HTTP przekazuje jedynie żądanie HTTP i odpowiedź HTTP dla określonej trasy i oczekuje od programisty bezpośredniego przetworzenia odpowiedzi HTTP. Interfejs API oprogramowania pośredniczącego umożliwia dowolne rozszerzanie rurociągu.",
        "_Express Beispiel_": "_przykład ekspresowy_.",
        "Dies ist für simple Anwendungsfälle sehr gut zugeschnitten, wird aber schnell unübersichtlich, wenn die Anwendung wächst, da alle Ein- und Ausgaben manuell serialisiert beziehungsweise deserialisiert und validiert werden müssen. Auch muss überlegt werden wie Objekte und Services wie zum Beispiel eine Datenbank Abstraktion aus der Anwendung selbst erhaltenen werden können. Es zwingt den Developer eine Architektur selbst obendrauf zu setzen, die diese zwingenden Funktionalitäten abbildet.": "Jest to bardzo dobre rozwiązanie dla prostych przypadków użycia, ale szybko staje się mylące, gdy aplikacja się rozrasta, ponieważ wszystkie dane wejściowe i wyjściowe muszą być serializowane lub deserializowane i walidowane ręcznie. Należy także zastanowić się, w jaki sposób obiekty i usługi, takie jak abstrakcja bazy danych, mogą być uzyskiwane z samej aplikacji. Zmusza to programistę do umieszczenia na wierzchu architektury, która odwzorowuje te obowiązkowe funkcje.",
        "Deepkit's HTTP Library nutzt die Stärke von TypeScript und Dependency Injection. Serialisierung/Deserialisierung und Validierung von jeglichen Werten passieren automatisch anhand der definierten Typen. Auch erlaubt es das Definieren von Routen entweder über eine funktionale API wie in dem Beispiel oben oder über Controller-Klassen, um die unterschiedlichen Bedürfnisse einer Architektur abzudecken.": "Biblioteka HTTP firmy Deepkit wykorzystuje możliwości języka TypeScript i wstrzykiwania zależności (Dependency Injection). Serializacja/deserializacja oraz sprawdzanie poprawności wszelkich wartości odbywa się automatycznie na podstawie zdefiniowanych typów. Umożliwia także definiowanie tras za pomocą funkcjonalnego interfejsu API, jak w powyższym przykładzie, lub za pomocą klas kontrolerów w celu zaspokojenia różnych potrzeb danej architektury.",
        "Es kann dabei entweder mit einem bereits vorhandenen HTTP-Server wie Node's `http` Modul oder mit dem Deepkit Framework genutzt werden. Beide API-Varianten haben Zugriff auf den Dependency Injection Container und können so bequem Objekte wie eine Datenbank-Abstraktion und Konfigurationen aus der Anwendung beziehen.": "Można go używać zarówno z istniejącym serwerem HTTP, takim jak moduł `http` Node'a, jak i z frameworkiem Deepkit. Oba warianty API mają dostęp do kontenera wstrzykiwania zależności, dzięki czemu mogą wygodnie pobierać z aplikacji takie obiekty, jak abstrakcja bazy danych i konfiguracje.",
        "_Deepkit Beispiel_": "_Przykład zestawu głębokiego_.",
        "Zu beachten ist, dass `@deepkit/http` für die Controller API auf TypeScript-Decorators basiert und dieses Feature entsprechend mit `experimentalDecorators` aktiviert werden muss sobald die Controller API verwendet wird.": "Zwróć uwagę, że `@deepkit/http` dla API kontrolera jest oparty na dekoratorach TypeScript i ta właściwość musi być odpowiednio aktywowana za pomocą `experimentalDecorators`, gdy tylko API kontrolera jest używane.",
        "Funktionale API": "Funkcjonalny interfejs API",
        "Die funktionale API basiert auf Funktionen und können über die Router Registry, der über den DI Container der App bezogen werden kann, registriert werden.": "Funkcjonalny interfejs API jest oparty na funkcjach i można go zarejestrować za pomocą rejestru routera, który można uzyskać za pośrednictwem kontenera DI aplikacji.",
        "Die Router Registry kann auch in Event Listener oder im Bootstrap bezogen werden, sodass basierend auf Modulen, Konfigurationen und sonstigen Providern diverse Routen registriert werden.": "Rejestr routerów można także uzyskać w Event Listener lub w bootstrapie, dzięki czemu można rejestrować różne trasy na podstawie modułów, konfiguracji i innych dostawców.",
        "Sobald Module verwendet werden, können funktionale Routen ebenfalls von Modulen dynamisch bereitgestellt werden.": "Po zastosowaniu modułów trasy funkcjonalne mogą być również dynamicznie udostępniane przez moduły.",
        "Siehe das Kapitel <<framework-modules>>, um mehr über App Module zu erfahren.": "Więcej informacji o modułach aplikacji można znaleźć w rozdziale <<framework-modules>>.",
        "Controller API": "API sterownika",
        "Die Controller API basiert auf Klassen und kann dabei über die App-API unter der Option `controllers` registriert werden.": "API kontrolerów jest oparte na klasach i można je zarejestrować za pomocą App-API w opcji `controllers`.",
        "Sobald Module verwendet werden, können Controller ebenfalls von Modulen bereitgestellt werden.": "Po zastosowaniu modułów, sterowniki mogą być również dostarczane przez moduły.",
        "Um dynamisch (je nach Konfigurationoption zum Beispiel) Controller bereitzustellen, kann der `process`-Hook verwendet werden.": "Aby dostarczać kontrolery dynamicznie (na przykład w zależności od opcji konfiguracyjnej), można użyć haka `process`.",
        "HTTP Server": "Serwer HTTP",
        "Sofern Deepkit Framework genutzt wird, ist dort ein HTTP Server bereits eingebaut. Die HTTP-Library kann jedoch auch ohne den Einsatz des Deepkit Frameworks mit einem eigenen HTTP-Server genutzt werden.": "Jeśli używany jest Deepkit Framework, serwer HTTP jest już wbudowany. Biblioteki HTTP można jednak używać także z własnym serwerem HTTP bez korzystania z frameworka Deepkit.",
        "HTTP Client": "Klient HTTP",
        "todo: fetch API, validation, und cast.": "todo: pobieranie API, sprawdzanie poprawności i rzutowanie.",
        "Route Names": "Nazwy tras",
        "Routen können einen eindeutigen Namen erhalten, welcher bei einer Weiterleitung referenziert werden kann. Je nach API unterscheidet sich die Art wie ein Name definiert wird.": "Trasom można nadać unikatową nazwę, do której można się odwoływać podczas przekierowania. W zależności od interfejsu API sposób definiowania nazwy jest różny.",
        "Von allen Routen mit einem Namen kann die URL durch `Router.resolveUrl()` angefordert werden.": "Dla wszystkich tras z nazwą, adres URL może być żądany przez `Router.resolveUrl()`.",
        "Die Router-Funktionen sowie die Controller-Klassen und Controller-Methoden können beliebige Abhängigkeiten definieren, die durch den Dependency Injection Container aufgelöst werden. So ist es zum Beispiel möglich bequem an eine Datenbank-Abstraktion oder Logger zu kommen.": "Funkcje routera, a także klasy kontrolerów i metody kontrolerów mogą definiować dowolne zależności, które są rozwiązywane przez kontener wstrzykiwania zależności. Umożliwia to na przykład wygodny dostęp do abstrakcji bazy danych lub rejestratora.",
        "Wenn zum Beispiel eine Datenbank als Provider zur Verfügung gestellt wurde, kann diese injiziert werden:": "Na przykład, jeśli baza danych została udostępniona jako dostawca, można ją wstrzyknąć:",
        "_Funktionaler API:_": "Funkcjonalne API:_.",
        "_Controller API:_": "API kontrolera:_",
        "Siehe das Kapitel <<dependency-injection>> für mehr Informationen.": "Więcej informacji na ten temat znajduje się w rozdziale <<wstrzykiwanie zależności>>.",
        "Input": "Wejście",
        "Alle nachfolgenden Input-Variationen funktionen bei der funktionalen wie auch der Controller API gleich. Sie erlauben es, Daten aus einen HTTP-Request typen-sicher und entkoppelt auszulesen.": "Wszystkie poniższe warianty wejść działają w ten sam sposób zarówno w interfejsie API funkcji, jak i kontrolera. Umożliwiają one odczytywanie danych z żądania HTTP w sposób bezpieczny dla typu i niezwiązany z innymi elementami.",
        "Dies führt nicht nur zu einer deutlichen erhöhten Sicherheit, sondern auch einfacheres Unit-Testen,": "Prowadzi to nie tylko do znacznego zwiększenia bezpieczeństwa, ale także do uproszczenia testów jednostkowych,",
        "da streng genommen nicht einmal ein HTTP-Request Objekt existieren muss, um die Route zu testen.": "ponieważ, ściśle rzecz biorąc, obiekt żądania HTTP nie musi nawet istnieć, aby można było przetestować trasę.",
        "Alle Parameter werden dabei automatisch in den definierten TypeScript-Typen umgewandelt (deserialisiert) und validiert. Dies geschieht über das `@deepkit/type` Paket und seinen <<serialisation>> und <<validation>> Features.": "Wszystkie parametry są automatycznie konwertowane (deserializowane) na zdefiniowane typy TypeScript i walidowane. Odbywa się to za pomocą pakietu `@deepkit/type` i jego funkcji <<serializacji>> i <<walidacji>>.",
        "Der Einfachheit halber sind nachfolgend alle Beispiel mit der funktionalen API abgebildet.": "Dla uproszczenia poniżej przedstawiono wszystkie przykłady z funkcjonalnym interfejsem API.",
        "Path Parameters": "Parametry ścieżki",
        "Path Parameter sind Werte, die aus der URL der Route extrahiert werden. Der Typ des Wertes richtet sich nach dem Typen an dem dazugehörigen Parameter der Funktion beziehungsweise Methode.": "Parametry ścieżki to wartości, które są pobierane z adresu URL trasy. Typ wartości zależy od typu odpowiadającego jej parametru funkcji lub metody.",
        "Die Umwandlung geschieht automatisch mit dem Feature <<serialisation-loosely-convertion>>.": "Konwersja jest wykonywana automatycznie za pomocą funkcji <<serializacja-luźna-konwersja>>.",
        "Ist ein Path Parameter als ein anderer Typ als String definiert, so wird dieser korrekt umgewandelt.": "Jeśli parametr ścieżki zostanie zdefiniowany jako typ inny niż łańcuch, zostanie on poprawnie przekonwertowany.",
        "Es können auch zusätzliche Validierung-Einschränken auf den Typen angewendet werden.": "Do typów można także stosować dodatkowe ograniczenia walidacji.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel <<http-validation>> zu finden.": "Można stosować wszystkie typy walidacji z `@deepkit/type`. Więcej na ten temat można znaleźć w rozdziale <<http-validation>>.",
        "Die Path Parameter haben standardmäßig bei dem URL-Matching `[^/]+` als Regular-Expression gesetzt. Das RegExp dazu kann wie folgt angepasst werden:": "Domyślnie parametry Ścieżki mają ustawione `[^/]+` jako wyrażenie regularne do dopasowywania adresów URL. RegExp do tego celu można dostosować w następujący sposób:",
        "Dies ist nur in Ausnahmefällen nötig, da oft die Typen in Kombination mit Validierung-Typen selbst bereits mögliche Werte korrekt einschränken.": "Jest to konieczne tylko w wyjątkowych przypadkach, ponieważ często typy w połączeniu z typami walidacji już same w sobie prawidłowo ograniczają możliwe wartości.",
        "Query Parameters": "Parametry zapytań",
        "Query Parameter sind Werte aus der URL hinter dem `?`-Zeichen und können mit dem Typ `HttpQuery<T>` ausgelesen werden. Der Name des Parameters entspricht dabei dem Namen des Query-Parameters.": "Parametry zapytania są wartościami z adresu URL za znakiem `?` i mogą być odczytywane za pomocą typu `HttpQuery<T>`. Nazwa parametru odpowiada nazwie parametru zapytania.",
        "Auch Query Parameter sind automatisch deserialisiert und validiert.": "Parametry zapytań są również automatycznie deserializowane i walidowane.",
        "Alle Validierung-Typen aus `@deepkit/type` können angewendet werden. Hierzu ist mehr in dem Kapitel  <<http-validation>> zu finden.": "Można stosować wszystkie typy walidacji z `@deepkit/type`. Więcej na ten temat można znaleźć w rozdziale <<http-validation>>.",
        "*Warnung*: Parameterwerte werden nicht escaped/sanitized. Ihre direkte Rückgabe in einer Zeichenkette in einer Route als HTML öffnet eine Sicherheitslücke (XSS). Stelle sicher, dass niemals externen Eingabe vertraut werden und filtere/sanitize/konvertiere Daten, wo nötig.": "*Ostrzeżenie*: Wartości parametrów nie podlegają ucieczce ani sanityzacji. Zwracanie ich bezpośrednio w postaci ciągu znaków w trasie jako HTML powoduje powstanie luki w zabezpieczeniach (XSS). Należy dopilnować, aby nie ufano zewnętrznym danym wejściowym i w razie potrzeby filtrować/oczyszczać/konwertować dane.",
        "Query Model": "Model zapytania",
        "Bei sehr vielen Query Parametern kann es schnell unübersichtlich werden. Um hier wieder Ordnung hereinzubringen, kann ein Model (Klasse oder Interface) genutzt werden, die alle möglichen Query-Parameter zusammenfasst.": "Przy dużej liczbie parametrów zapytania może to szybko stać się mylące. Aby przywrócić porządek, można użyć modelu (klasy lub interfejsu), który łączy wszystkie możliwe parametry zapytania.",
        "Die Properties in dem angegebenen Model können alle TypeScript-Typen und Validierung-Typen beinhalten, die `@deepkit/type` unterstützt. Sieh dazu das Kapitel <<serialisation>> und <<validation>>.": "Właściwości w określonym modelu mogą zawierać wszystkie typy TypeScript i typy walidacji, które obsługuje `@deepkit/type`. Zobacz rozdziały <<serializacja>> i <<walidacja>>.",
        "Body": "Ciało",
        "Für HTTP-Methoden, die einen HTTP-Body erlauben, kann auch ein body model festgelegt werden.": "W przypadku metod HTTP, które dopuszczają ciało HTTP, można również określić model ciała.",
        "Der Body-Inhaltstyp von dem HTTP-Request muss entweder `application/x-www-form-urlencoded`, `multipart/form-data` oder `application/json` sein, damit Deepkit dies automatisch in JavaScript Objekte umwandeln kann.": "Typ zawartości ciała żądania HTTP musi być `application/x-www-form-urlencoded`, `multipart/form-data` lub `application/json`, aby Deepkit mógł automatycznie przekonwertować to na obiekty JavaScript.",
        "Header": "Nagłówek",
        "Stream": "Strumień",
        "Manual Validation Handling": "Ręczna obsługa walidacji",
        "Um manuell die Validierung des Body-Models zu übernehmen, kann ein spezieller Typ `HttpBodyValidation<T>` benutzt werden. Er erlaubt es, auch invalide Body-Daten zu empfangen und ganz spezifisch auf Fehlermeldungen zu reagieren.": "Aby ręcznie przejąć sprawdzanie poprawności modelu ciała, można użyć specjalnego typu `HttpBodyValidation<T>`. Umożliwia on odbieranie nieprawidłowych danych ciała i reagowanie na komunikaty o błędach.",
        "Sobald `valid()` den Wert `false` zurückgibt, können die Werte in dem angegebenen Model in einem fehlerhaften Zustand sein. Das bedeutet, dass die Validierung fehlgeschlagen ist. Wenn `HttpBodyValidation` nicht verwendet wird und eine fehlerhafte HTTP-Request eingeht, würde die Anfrage direkt abgebrochen werden und der Code in der Funktion nie ausgeführt. Verwende `HttpBodyValidation` nur dann, wenn zum Beispiel Fehlermeldungen bezüglich des Bodys manuell in derselben Route verwertet werden sollen.": "Gdy tylko `valid()` zwraca wartość `false`, wartości w określonym modelu mogą być w błędnym stanie. Oznacza to, że walidacja nie powiodła się. Jeśli `HttpBodyValidation` nie zostanie użyty i zostanie odebrane nieprawidłowe żądanie HTTP, żądanie zostanie przerwane bezpośrednio, a kod w funkcji nigdy nie zostanie wykonany. Używaj `HttpBodyValidation` tylko wtedy, gdy na przykład komunikaty o błędach dotyczące ciała mają być przetwarzane ręcznie w tej samej trasie.",
        "File Upload": "Przesyłanie plików",
        "Ein spezieller Property-Typ an dem Body-Model kann genutzt werden, um dem Client zu erlauben, Dateien hochzuladen. Es können beliebig viele `UploadedFile` verwendet werden.": "Aby umożliwić klientowi przesyłanie plików, można użyć specjalnego typu właściwości w modelu ciała. Można użyć dowolnej liczby `UploadedFile`.",
        "Standardmäßig speichert der Router alle hochgeladenen Dateien in einen Temp-Ordner und entfernt diese, sobald der Code in der Route ausgeführt wurde. Es ist daher notwendig, die Datei in dem angegebenen Pfad in `path` auszulesen und an einen permanenten Ort zu speichern (lokale Festplatte, Cloud Storage, Datenbank).": "Domyślnie router przechowuje wszystkie przesłane pliki w folderze tymczasowym i usuwa je po wykonaniu kodu trasy. Dlatego konieczne jest odczytanie pliku znajdującego się w ścieżce określonej w `path` i zapisanie go w trwałym miejscu (na lokalnym dysku twardym, w chmurze, w bazie danych).",
        "Validation in einem HTTP-Server ist ein zwingend notwendige Funktionalität, da fast immer mit Daten gearbeitet wird, die nicht vertrauenswürdig sind. Um an so mehr Stellen Daten validiert werden, umso stabiler ist der Server. Die Validierung in HTTP-Routen kann bequem über Typen und Validierung-Einschränkungen genutzt werden und wird mit einem hoch-optimierten Validator aus `@deepkit/type` geprüft, sodass es nicht zu Performanceproblemen diesbezüglich kommen kann. Es ist daher dringend empfehlenswert diese Validierungsfähigkeiten auch zu nutzen. Besser ein Mal zu viel, als ein Mal zu wenig.": "Walidacja w serwerze HTTP jest obowiązkową funkcją, ponieważ prawie zawsze przetwarzane są dane, które nie są godne zaufania. Im więcej miejsc, w których dane są walidowane, tym stabilniejszy serwer. Walidacja w trasach HTTP może być wygodnie używana poprzez typy i ograniczenia walidacyjne i jest sprawdzana za pomocą wysoce zoptymalizowanego walidatora z `@deepkit/type`, dzięki czemu nie ma problemów z wydajnością w tym zakresie. Dlatego bardzo zalecane jest korzystanie z tych możliwości walidacji. Lepiej raz za dużo niż raz za mało.",
        "Alle Inputs wie Path-Parameter, Query-Parameter, und Body-Parameter werden automatisch auf den angegebenen TypeScript-Typ validiert. Sind zusätzliche Einschränkungen über Typen von `@deepkit/type` angegeben, werden diese ebenfalls geprüft.": "Wszystkie dane wejściowe, takie jak parametry ścieżki, parametry zapytania i parametry ciała, są automatycznie sprawdzane pod kątem określonego typu TypeScript. Jeśli dodatkowe ograniczenia są określone przez typy `@deepkit/type`, to są one również sprawdzane.",
        "Siehe das Kapitel <<validation>> für mehr Informationen dazu.": "Więcej informacji na ten temat można znaleźć w rozdziale <<walidacja>>.",
        "Output": "Wyjście",
        "Eine Route kann verschiedene Datenstrukturen zurückgeben. Einige von ihnen werden auf besondere Weise behandelt, wie z. B. Weiterleitungen und Templates, und andere, wie einfache Objekte, werden einfach als JSON gesendet.": "Trasa może zwracać różne struktury danych. Niektóre z nich są obsługiwane w specjalny sposób, jak np. przekierowania i szablony, a inne, np. proste obiekty, są po prostu wysyłane jako JSON.",
        "JSON": "JSON",
        "Per Default werden normale JavaScript-Werte als JSON mit dem Header `application/json; charset=utf-8` an den Client zurückgesendet.": "Domyślnie zwykłe wartości JavaScript są zwracane do klienta jako JSON z nagłówkiem `application/json; charset=utf-8`.",
        "Ist ein expliziter Return-Typ bei der Funktion oder Methode angegeben, werden entsprechend dieses Typen die Daten in JSON mit dem Deepkit JSON Serializer serialisiert.": "Jeśli dla funkcji lub metody określono jednoznaczny typ zwrotu, dane są serializowane w JSON za pomocą Deepkit JSON Serializer zgodnie z tym typem.",
        "HTML": "HTML",
        "Um HTML zu senden, gibt es zwei Möglichkeiten. Entweder wird das Objekt `HtmlResponse` oder Template-Engine mit TSX verwendet.": "Aby wysłać kod HTML, można skorzystać z dwóch możliwości. Używany jest albo obiekt `HtmlResponse` albo Template-Engine z TSX.",
        "Die Template-Engine Variante mit TSX hat dabei den Vorteil, dass genutzte Variablen automatisch HTML-escaped werden. Siehe dazu das Kapitel <<template>>.": "Wariant silnika szablonów z TSX ma tę zaletę, że używane zmienne są automatycznie kodowane w języku HTML. Więcej informacji na ten temat można znaleźć w rozdziale <<template>>.",
        "Custom Content": "Zawartość własna",
        "Es ist neben HTML und JSON auch möglich Text- oder Binäre-Daten mit einer bestimmten Content-Type zu senden. Dies geschieht über das Objekt `Response`": "Oprócz HTML i JSON można również wysyłać dane tekstowe lub binarne o określonym typie zawartości. Odbywa się to za pomocą obiektu `Response`.",
        "HTTP Errors": "Błędy HTTP",
        "Es ist durch das Werfen von diversen HTTP-Errors möglich, die Verarbeitung eines HTTP-Requests sofort zu unterbrechen und den entsprechenden HTTP-Status des Errors auszugeben.": "Rzucając różne błędy HTTP, można natychmiast przerwać przetwarzanie żądania HTTP i podać stan HTTP odpowiadający błędowi.",
        "Per default werden alle Errors als JSON dem Client zurückgegeben. Dieses Verhalten kann man beliebig im Event-System unter dem Event `httpWorkflow.onControllerError` anpassen. Siehe dazu die Sektion <<http-events>>.": "Domyślnie wszystkie błędy są zwracane do klienta w formacie JSON. To zachowanie można dowolnie dostosować w systemie zdarzeń pod zdarzeniem `httpWorkflow.onControllerError`. Więcej informacji na ten temat można znaleźć w rozdziale <<http-events>>.",
        "Der Error `HttpAccessDeniedError` stellt hierbei eine besonderheit dar. Sobald er geworfen wird, springt der HTTP Workflow (see <<http-events>>) nicht zu `controllerError` sondern zu `accessDenied`.": "Błąd `HttpAccessDeniedError` jest przypadkiem szczególnym. Gdy tylko zostanie on rzucony, przepływ pracy HTTP (zobacz <<http-events>>) nie przeskakuje do `controllerError`, ale do `accessDenied`.",
        "Benutzerdefinierte HTTP-Errors können mit `createHttpError` angelegt und geworfen werden.": "Niestandardowe błędy HTTP mogą być tworzone i rzucane za pomocą `createHttpError`.",
        "Zusätzliche Header": "Dodatkowe nagłówki",
        "Um den Header einer HTTP-Response zu verändert, kann auf den Objekten `Response`, `JSONResponse`, und `HTMLResponse` zusätzliche Methoden aufgerufen werden.": "Aby zmienić nagłówek odpowiedzi HTTP, można wywołać dodatkowe metody na obiektach `Response`, `JSONResponse` i `HTMLResponse`.",
        "Redirect": "Przekierowanie",
        "Um eine 301 oder 302 Weiterleitung als Antwort zurückzugeben, kann `Redirect.toRoute` oder `Redirect.toUrl` verwendet werden.": "Aby zwrócić przekierowanie 301 lub 302 jako odpowiedź, można użyć `Redirect.toRoute` lub `Redirect.toUrl`.",
        "Die Methode `Redirect.toRoute` verwendet hierbei den Namen der Route. Wie ein Routen-Name gesetzt werden kann, ist in der Sektion <<http-route-name>> einzusehen. Wenn diese referenzierte Route (Query oder Pfad) Parameter beinhaltet, können diese über das zweite Argument angegeben werden:": "Metoda `Redirect.toRoute` używa nazwy trasy. Jak ustawić nazwę trasy, można zobaczyć w sekcji <<http-route-name>>. Jeśli trasa, do której się odwołujemy (zapytanie lub ścieżka), zawiera parametry, można je określić za pomocą drugiego argumentu:",
        "Alternativ kann auf eine URL mit `Redirect.toUrl` weitergeleitet werden.": "Alternatywnie można przekierować na adres URL za pomocą polecenia `Redirect.toUrl`.",
        "Standardmäßig benutzen beide einen 302-Weiterleitung. Dies kann über das Argument `statusCode` angepasst werden.": "Domyślnie w obu przypadkach używane jest przekierowanie 302. Można to dostosować za pomocą argumentu `statusCode`.",
        "Scope": "Zakres",
        "Alle HTTP-Controller und funktionalen Routen werden innerhalb des `http` Dependency Injection Scope verwaltet. HTTP-Controller werden entsprechend für jeden HTTP-Request neu instantiiert. Das bedeutet auch, dass beide auf Provider, die für den Scope `http` registriert sind, zugreifen können. So sind zusätzlich `HttpRequest` und `HttpResponse` aus `@deepkit/http` als Abhängigkeit nutzbar. Wenn Deepkit Framework benutzt, ist auch `SessionHandler` aus `@deepkit/framework` verfügbar.": "Wszystkie kontrolery HTTP i trasy funkcjonalne są zarządzane w ramach zakresu wstrzykiwania zależności `http`. Kontrolery HTTP są odpowiednio inicjowane dla każdego żądania HTTP. Oznacza to również, że oba mogą mieć dostęp do dostawców zarejestrowanych dla zakresu `http`. W ten sposób dodatkowo `HttpRequest` i `HttpResponse` z `@deepkit/http` mogą być użyte jako zależności. Jeśli używany jest Deepkit Framework, dostępny jest również `SessionHandler` z `@deepkit/framework`.",
        "Es kann durchaus nützlich sein, Provider in den `http` Scope zu platzieren, um zum Beispiel Services für jeden HTTP-Request neu zu instantiieren. Sobald der HTTP-Request bearbeitet wurde, wird der `http` scoped DI Container gelöscht und so alle seine Provider Instanzen vom Garbage Collector (GC) aufgeräumt.": "Użyteczne może być umieszczenie dostawców w zakresie `http`, na przykład w celu zainicjowania usług dla każdego żądania HTTP. Po przetworzeniu żądania HTTP, kontener DI z atrybutem `http` jest usuwany, dzięki czemu wszystkie jego instancje providerów są usuwane przez garbage collector (GC).",
        "Siehe das Kapitel <<dependency-injection-scopes>>, um zu erfahren, wie Provider in den `http` Scope platziert werden können.": "Zobacz rozdział <<dependency-injection-scopes>>, aby dowiedzieć się, jak umieszczać providery w zakresie `http`.",
        "Events": "Wydarzenia",
        "Das HTTP-Modul basiert auf einer Workflow-Engine, die verschiedene Event-Tokens bereitstellt, mit denen sich in den gesamten Prozess der Verarbeitung eines HTTP-Requests eingeklinkt werden kann.": "Moduł HTTP jest oparty na silniku przepływu pracy, który udostępnia różne tokeny zdarzeń, które można wykorzystać do powiązania z całym procesem przetwarzania żądania HTTP.",
        "Die Workflow-Engine ist dabei eine endliche State-Machine, die für jeden HTTP-Request eine neu State-Machine Instanz anlegt und dann von Position zu Position springt. Die erste Position ist dabei der `start` und die letzte die `response`. In jede Position kann zusätzlicher Code ausgeführt werden.": "Silnik przepływu pracy jest maszyną stanów skończonych, która tworzy nową instancję maszyny stanów dla każdego żądania HTTP, a następnie przeskakuje z pozycji na pozycję. Pierwsza pozycja to \"początek\", a ostatnia to \"odpowiedź\". W każdej pozycji można wykonać dodatkowy kod.",
        "Jedes Event-Token hat seinen eigenen Event-Typen mit zusätzlichen Informationen.": "Każdy token zdarzenia ma swój własny typ zdarzenia z dodatkowymi informacjami.",
        "Da alle HTTP-Events auf der Workflow-Engine basieren, kann deren Verhalten abgeändert werden, indem das angegebene Event benutzt wird und dort mit der `event.next()` Methode weitergesprungen wird.": "Ponieważ wszystkie zdarzenia HTTP bazują na silniku przepływu pracy, jego zachowanie można modyfikować poprzez użycie określonego zdarzenia i przeskakiwanie do niego za pomocą metody `event.next()`.",
        "Das HTTP-Modul verwendet seine eigenen Event-Listener auf diese Event-Tokens, um die Bearbeitung von HTTP-Requests zu implementieren. Alle diese Event-Listener haben eine Priorität von 100, d.h. wenn Sie auf ein Event hören, wird Ihr Listener standardmäßig zuerst ausgeführt (da die Standardpriorität 0 ist). Fügen Sie eine Priorität von über 100 hinzu, um nach den Event-Listener des HTTP-Modules zu laufen.": "Moduł HTTP wykorzystuje własne nasłuchiwanie zdarzeń na tych tokenach zdarzeń do przetwarzania żądań HTTP. Wszystkie te nasłuchiwacze zdarzeń mają priorytet 100, co oznacza, że gdy użytkownik nasłuchuje zdarzeń, jego nasłuchiwacz zostanie domyślnie wykonany jako pierwszy (ponieważ domyślny priorytet wynosi 0). Dodaj priorytet powyżej 100, aby uruchamiał się po listach zdarzeń modułu HTTP.",
        "Nehmen wir zum Beispiel an, Sie wollen das Ereignis abfangen, bei dem ein Controller aufgerufen wird. Wenn ein bestimmter Controller aufgerufen werden soll, prüfen wir, ob der Benutzer Zugriff darauf hat. Wenn der Benutzer Zugriff hat, fahren wir fort. Aber falls nicht, springen wir zur nächsten Workflow-Position `accessDenied`. Dort wird dann das Prozedere eines Access-Denied automatisch weiterverarbeitet.": "Na przykład załóżmy, że chcesz przechwycić zdarzenie, w którym wywoływany jest kontroler. Jeśli ma zostać wywołany konkretny kontroler, sprawdzamy, czy użytkownik ma do niego dostęp. Jeśli użytkownik ma dostęp, kontynuujemy. Jeśli jednak nie, przechodzimy do następnego elementu przepływu pracy - `accessDenied`. W takim przypadku procedura odmowy dostępu jest automatycznie przetwarzana dalej.",
        "Security": "Bezpieczeństwo",
        "Sessions": "Sesje",
        "Middleware": "Middleware",
        "Resolver": "Resolver",
        "Der Router unterstützt eine Möglichkeit zur Auflösung komplexer Parametertypen. Wenn zum Beispiel eine Route wie `/user/:id` gegeben ist, kann diese `id` mithilfe eines Resolvers in ein `User`-Objekt außerhalb der Route aufgelöst werden. Dies führt zu einer weiteren Abkopplung von der HTTP-Abstraktion und des Routen-Codes, und vereinfacht so weiter das Testen und die Modularität.": "Router obsługuje sposób rozwiązywania złożonych typów parametrów. Na przykład, biorąc pod uwagę trasę taką jak `/user/:id`, ten `id` może być rozwiązany do obiektu `user` poza trasą przy użyciu resolvera. To jeszcze bardziej oddziela abstrakcję HTTP od kodu trasy, co jeszcze bardziej upraszcza testowanie i modularność.",
        "Der User muss hierbei nicht zwingend von einem Parameter abhängen. So könnte er genauso gut von einer Session bzw. einem HTTP-Header abhängen, und nur dann bereitgestellt werden, wenn der User eingeloggt ist. In `RouteParameterResolverContext` sind viele Informationen über den HTTP-Request verfügbar, sodass viele Anwendungsfälle so abbildbar sind.": "Użytkownik nie musi koniecznie polegać na parametrze. Równie dobrze może ona zależeć od sesji lub nagłówka HTTP i być udostępniana tylko wtedy, gdy użytkownik jest zalogowany. W \"RouteParameterResolverContext\" dostępnych jest wiele informacji o żądaniu HTTP, dzięki czemu można w ten sposób odwzorować wiele przypadków użycia.",
        "Im Prinzip ist es auch möglich, komplexe Parametertypen über den Dependency Injection Container aus dem Scope `http` bereitstellen zu lassen, da diese ebenfalls in der Routen-Funktion bzw. Methode verfügbar sind. Dies hat jedoch den Nachteil, dass kein asynchrone Funktionsaufrufe verwendet werden können, da der DI container durchweg synchron ist.": "W zasadzie możliwe jest również posiadanie złożonych typów parametrów dostarczanych przez kontener Dependency Injection z zakresu `http`, ponieważ są one również dostępne w funkcji lub metodzie trasy. Ma to jednak tę wadę, że nie można używać asynchronicznych wywołań funkcji, ponieważ kontener DI jest przez cały czas synchroniczny.",
        "RPC": "RPC",
        "Controller": "Kontroler",
        "Server": "Serwer",
        "Client": "Klient",
        "Authentication": "Uwierzytelnianie",
        "Transport Protocol": "Protokół transportowy",
        "WebSockets": "WebSockets",
        "TCP": "TCP",
        "Peer To Peer": "Peer To Peer",
        "SQLite": "SQLite",
        "MySQL": "MySQL",
        "Postgres": "Postgres",
        "MongoDB": "MongoDB",
        "Connection": "Połączenie",
        "Read Replica": "Przeczytaj replikę",
        "Primitives": "Prymitywna",
        "Primary Key": "Klucz podstawowy",
        "Auto Increment": "Automatyczna inkrementacja",
        "MongoDB ObjectID": "MongoDB ObjectID",
        "Optional / Nullable": "Opcjonalne / Nullable",
        "Embedded Types": "Typy wbudowane",
        "Default Values": "Wartości domyślne",
        "Default Expressions": "Domyślne wyrażenia",
        "Complex Types": "Rodzaje złożone",
        "Exclude": "Z wyłączeniem .",
        "Database Specific Column Types": "Typy kolumn specyficzne dla bazy danych",
        "Session / Unit Of Work": "Sesja / jednostka pracy",
        "Identity Map": "Mapa Tożsamości",
        "Change Detection": "Wykrywanie zmian",
        "Request/Response": "Wniosek/odpowiedź",
        "Query": "Zapytanie",
        "Find": "Znajdź stronę",
        "Filter": "Filtr",
        "Equal": "Equal",
        "Greater / Smaller": "Większy / Mniejszy",
        "RegExp": "RegExp",
        "Grouping AND/OR": "Grupowanie AND/OR",
        "In": "Na stronie",
        "Order": "Zamówienie",
        "Pagination": "Paginacja",
        "Aggregation": "Agregacja",
        "Join": "Dołącz do",
        "Returning": "Powrót",
        "Patch": "Łata",
        "Delete": "Usuń",
        "Lift": "Lift",
        "Repository": "Repozytorium",
        "Relations": "Relacje",
        "One To Many": "Jeden do wielu",
        "Many To Many": "Wiele do wielu",
        "One To One": "Jeden do jednego",
        "Constraints": "Ograniczenia",
        "On Delete/Update: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT": "Przy usuwaniu/aktualizacji: RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT",
        "Inheritance": "Dziedziczenie",
        "Table Per Class": "Stół na klasę",
        "Single Table Inheritance": "Dziedziczenie pojedynczej tabeli",
        "Index": "Indeks",
        "Case Sensitivity": "Czułość na wielkość liter",
        "Character Sets": "Zestawy znaków",
        "Collations": "Kolacje",
        "Batching": "Dozowanie",
        "Caching": "Buforowanie",
        "Multitenancy": "Multitenancy",
        "Query Events": "Zdarzenia związane z zapytaniem",
        "Unit Of Work Events": "Wydarzenia w jednostce pracy",
        "Transactions": "Transakcje",
        "Isolations": "Izolacja",
        "Locking": "Blokowanie",
        "Optimistic Locking": "Optymistyczne blokowanie",
        "Pessimistic Locking": "Blokada pesymistyczna",
        "Custom Types": "Typy niestandardowe",
        "Logging": "Rejestrowanie",
        "Migration": "Migracja",
        "Seeding": "Siewnik",
        "Raw Database Access": "Nieprzetworzony dostęp do bazy danych",
        "SQL": "SQL",
        "App Configuration": "Konfiguracja aplikacji",
        "Composite Primary Key": "Złożony klucz podstawowy",
        "Plugins": "Wtyczki",
        "Soft-Delete": "Soft-Delete",
        "Broker": "Broker",
        "Key/Value": "Klucz/wartość",
        "Publish / Subscribe": "Opublikuj / Subskrybuj",
        "Template": "Szablon",
        "Eine serverseitige TSX (JSX) basierte Template-Engine, mit der HTML auf eine typen-sichere Art generiert werden kann.": "Silnik szablonów oparty na TSX (JSX) po stronie serwera, który może generować HTML w sposób bezpieczny dla typów.",
        "Components": "Elementy",
        "Function Components": "Komponenty funkcji",
        "Class Components": "Komponenty klasy",
        "Dynamic HTML": "Dynamiczny HTML",
        "Optimization": "Optymalizacja",
        "Framework": "Ramy",
        "Modules": "Moduły",
        "Configuration": "Konfiguracja",
        "Application Server": "Serwer aplikacji",
        "Public Directory": "Katalog publiczny",
        "File Structure": "Struktura pliku",
        "Logger": "Rejestrator",
        "Auto-CRUD": "Auto-CRUD",
        "Workflow": "Przepływ pracy",
        "Testing": "Testowanie",
        "Debugger": "Debugger",
        "Module": "Moduły",
        "Profiler": "Profiler",
        "Deployment": "Wdrażanie",
        "Compiling": "Kompilacja",
        "Packaging": "Opakowania",
        "Docker": "Docker"
    }
}
